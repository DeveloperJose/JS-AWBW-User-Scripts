// ==UserScript==
// @name            Improved AWBW Music Player
// @description     An improved version of the comprehensive audio player that attempts to recreate the cart experience with more sound effects, more music, and more customizability.
// @namespace       https://awbw.amarriner.com/
// @author          DeveloperJose, _twiggy
// @match           https://awbw.amarriner.com/*
// @icon            https://developerjose.netlify.app/img/music-player-icon.png
// @require         https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js
// @require         https://cdn.jsdelivr.net/npm/spark-md5@3.0.2/spark-md5.min.js
// @require         https://cdn.jsdelivr.net/npm/can-autoplay@3.0.2/build/can-autoplay.min.js
// @require         https://cdn.jsdelivr.net/npm/vue@2.7.16/dist/vue.min.js
// @run-at          document-end
// @version         5.1.0
// @supportURL      https://github.com/DeveloperJose/JS-AWBW-User-Scripts/issues
// @contributionURL https://ko-fi.com/developerjose
// @license         MIT
// @unwrap
// @grant           none
// ==/UserScript==
var awbw_music_player = function(exports, canAutoplay2, SparkMD52, Vue2) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  var __vite_style__ = document.createElement("style");
  __vite_style__.textContent = '/* This file is used to style the music player settings */\n\niframe {\n  border: none;\n}\n\n.cls-settings-menu {\n  display: none;\n  /* display: flex; */\n  top: 40px;\n  flex-direction: column;\n  width: 750px;\n  border: black 1px solid;\n  z-index: 20;\n  text-align: center;\n  align-items: center;\n  font-family: "Nova Square", cursive !important;\n}\n\n.cls-settings-menu label {\n  background-color: white;\n  font-size: 12px;\n}\n\n.cls-settings-menu .cls-group-box > label {\n  width: 100%;\n  font-size: 13px;\n  background-color: #d6e0ed;\n  padding-top: 2px;\n  padding-bottom: 2px;\n}\n\n.cls-settings-menu .cls-vertical-box {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-evenly;\n  align-items: center;\n  padding-left: 5px;\n  padding-right: 5px;\n  padding-top: 1px;\n  padding-bottom: 1px;\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n\n.cls-settings-menu .cls-horizontal-box {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-evenly;\n  align-items: center;\n  padding-left: 5px;\n  padding-right: 5px;\n  padding-top: 1px;\n  padding-bottom: 1px;\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n\n/* Puts the checkbox next to the label */\n.cls-settings-menu .cls-vertical-box[id$="options"] {\n  align-items: center;\n  align-self: center;\n}\n\n.cls-settings-menu .cls-vertical-box[id$="options"] .cls-horizontal-box {\n  width: 100%;\n  justify-content: center;\n}\n\n.cls-settings-menu .cls-vertical-box[id$="options"] .cls-horizontal-box input {\n  vertical-align: middle;\n}\n\n/* .cls-settings-menu .cls-vertical-box[id$="options"] .cls-horizontal-box label {\n  display: block;\n  padding-right: 10px;\n  padding-left: 22px;\n  text-indent: -22px;\n} */\n\n/* .cls-settings-menu .cls-horizontal-box[id$="random-themes"],\n.cls-settings-menu .cls-horizontal-box[id$="soundtrack"] {\n  justify-content: center;\n} */\n\n.cls-settings-menu-box {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-evenly;\n  padding-left: 5px;\n  padding-right: 5px;\n  padding-top: 1px;\n  padding-bottom: 1px;\n  width: 100%;\n}\n\n.cls-settings-menu image {\n  vertical-align: middle;\n}\n\n.cls-settings-menu label[id$="version"] {\n  width: 100%;\n  font-size: 10px;\n  color: #888888;\n  background-color: #f0f0f0;\n}\n\n.cls-settings-menu a[id$="update"] {\n  font-size: 12px;\n  background-color: #ff0000;\n  color: white;\n  width: 100%;\n}\n.cls-settings-menu .co_caret {\n  position: absolute;\n  top: 28px;\n  left: 25px;\n  border: none;\n  z-index: 30;\n}\n\n.cls-settings-menu .co_portrait {\n  border-color: #009966;\n  z-index: 30;\n  border: 2px solid;\n  vertical-align: middle;\n  align-self: center;\n}\n\n.cls-settings-menu input[type="range"][id$="themes-start-on-day"] {\n  --c: rgb(168, 73, 208); /* active color */\n}\n/* \n * CSS Custom Range Slider\n * https://www.sitepoint.com/css-custom-range-slider/ \n */\n\n.cls-settings-menu input[type="range"] {\n  --c: rgb(53 57 60); /* active color */\n  --l: 15px; /* line thickness*/\n  --h: 30px; /* thumb height */\n  --w: 15px; /* thumb width */\n\n  width: 100%;\n  height: var(--h); /* needed for Firefox*/\n  --_c: color-mix(in srgb, var(--c), #000 var(--p, 0%));\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  background: none;\n  cursor: pointer;\n  overflow: hidden;\n  display: inline-block;\n}\n.cls-settings-menu input:focus-visible,\n.cls-settings-menu input:hover {\n  --p: 25%;\n}\n\n/* chromium */\n.cls-settings-menu input[type="range" i]::-webkit-slider-thumb {\n  height: var(--h);\n  width: var(--w);\n  background: var(--_c);\n  border-image: linear-gradient(90deg, var(--_c) 50%, #ababab 0) 0 1 / calc(50% - var(--l) / 2) 100vw/0 100vw;\n  -webkit-appearance: none;\n  appearance: none;\n  transition: 0.3s;\n}\n/* Firefox */\n.cls-settings-menu input[type="range"]::-moz-range-thumb {\n  height: var(--h);\n  width: var(--w);\n  background: var(--_c);\n  border-image: linear-gradient(90deg, var(--_c) 50%, #ababab 0) 0 1 / calc(50% - var(--l) / 2) 100vw/0 100vw;\n  -webkit-appearance: none;\n  appearance: none;\n  transition: 0.3s;\n}\n@supports not (color: color-mix(in srgb, red, red)) {\n  .cls-settings-menu input {\n    --_c: var(--c);\n  }\n}\n/*$vite$:1*/';
  document.head.appendChild(__vite_style__);
  function logInfo(message, ...args) {
    console.log("[AWBW Improved Music Player]", message, ...args);
  }
  function logError(message, ...args) {
    console.error("[AWBW Improved Music Player]", message, ...args);
  }
  function logDebug(message, ...args) {
    console.debug("[AWBW Improved Music Player]", message, ...args);
  }
  function debounce$1(ms, callback, immediate = false) {
    let timeout;
    return function(...args) {
      const context = this;
      const later = () => {
        timeout = null;
        if (!immediate) {
          callback.apply(context, args);
        }
      };
      const callNow = immediate && !timeout;
      if (typeof timeout === "number") {
        window.clearTimeout(timeout);
      }
      timeout = window.setTimeout(later, ms);
      if (callNow) {
        callback.apply(context, args);
      }
    };
  }
  const IFRAME_ID = "music-player-iframe";
  const broadcastChannel = new BroadcastChannel("awbw-music-player");
  function isIFrameActive() {
    var _a;
    const iframe = document.getElementById(IFRAME_ID);
    if (!iframe) return false;
    const href = ((_a = iframe.contentDocument) == null ? void 0 : _a.location.href) ?? iframe.src;
    return href !== null && href !== "" && href !== "about:blank";
  }
  function getCurrentDocument() {
    if (!isIFrameActive()) return window.document;
    const iframe = document.getElementById(IFRAME_ID);
    return (iframe == null ? void 0 : iframe.contentDocument) ?? window.document;
  }
  function initializeIFrame(init_fn) {
    const hasFrame = document.getElementById(IFRAME_ID);
    if (hasFrame) return;
    const iframe = document.createElement("iframe");
    iframe.style.display = "none";
    iframe.id = IFRAME_ID;
    iframe.name = IFRAME_ID;
    document.body.appendChild(iframe);
    iframe.addEventListener("load", (event2) => onIFrameLoad(event2, init_fn));
    hijackLinks(window.document);
    init_fn();
    window.addEventListener("popstate", (event2) => {
      const href = window.location.href;
      const iframe2 = document.getElementById(IFRAME_ID);
      if (!iframe2 || href.includes("game.php")) {
        window.location.reload();
        return;
      }
      iframe2.src = href;
      const state = event2.state;
      if (!state || !state.scrollX || !state.scrollY) return;
      window.scrollTo(state.scrollX, state.scrollY);
    });
  }
  function onIFrameLoad(event2, initFn) {
    const iframe = event2.target;
    if (!iframe || !iframe.contentDocument) return;
    const href = iframe.contentDocument.location.href ?? iframe.src;
    if (href === null || href === "" || href === "about:blank") return;
    for (const child of Array.from(document.body.children)) {
      if (child === iframe) continue;
      if (child.id === "overDiv") continue;
      child.remove();
    }
    iframe.style.display = "block";
    iframe.style.width = "100%";
    iframe.style.height = "100%";
    document.body.style.width = "100%";
    document.body.style.height = "100%";
    document.body.style.overflow = "hidden";
    if (document.body.parentElement) {
      document.body.parentElement.style.width = "100%";
      document.body.parentElement.style.height = "100%";
    }
    const state = { scrollX: window.scrollX, scrollY: window.scrollY };
    window.history.pushState(state, "", href);
    document.title = iframe.contentDocument.title;
    hijackLinks(iframe.contentDocument);
    initFn();
  }
  function hijackLinks(doc) {
    if (!doc) {
      logError("Could not find the document to hijack links.");
      return;
    }
    const links = doc.querySelectorAll("a");
    if (!links) {
      logError("Could not find any links to hijack.");
      return;
    }
    for (const link of Array.from(links)) {
      const isGamePageLink = link.href.includes("game.php") || link.classList.contains("anchor") && link.name.includes("game_");
      const isMovePlannerLink = link.href.includes("moveplanner.php");
      const isJSLink = link.href.startsWith("javascript:");
      if (isJSLink) continue;
      else if (link.href === "" || isMovePlannerLink) continue;
      else if (isGamePageLink) link.target = "_top";
      else link.target = IFRAME_ID;
    }
  }
  var PageType = /* @__PURE__ */ ((PageType2) => {
    PageType2["Maintenance"] = "Maintenance";
    PageType2["ActiveGame"] = "ActiveGame";
    PageType2["MapEditor"] = "MapEditor";
    PageType2["MovePlanner"] = "MovePlanner";
    PageType2["LiveQueue"] = "LiveQueue";
    PageType2["MainPage"] = "MainPage";
    PageType2["Default"] = "Default";
    return PageType2;
  })(PageType || {});
  function getCurrentPageType() {
    const doc = getCurrentDocument();
    const isMaintenance = doc.querySelector("#server-maintenance-alert") !== null;
    if (isMaintenance) return "Maintenance";
    if (doc.location.href.indexOf("game.php") > -1) return "ActiveGame";
    if (doc.location.href.indexOf("editmap.php?") > -1) return "MapEditor";
    if (doc.location.href.indexOf("moveplanner.php") > -1) return "MovePlanner";
    if (doc.location.href.indexOf("live_queue.php") > -1) return "LiveQueue";
    if (doc.location.href === "https://awbw.amarriner.com/") return "MainPage";
    return "Default";
  }
  function getCoordsDiv() {
    return getCurrentDocument().querySelector("#coords");
  }
  function getReplayControls() {
    return getCurrentDocument().querySelector(".replay-controls");
  }
  function getReplayOpenBtn() {
    return getCurrentDocument().querySelector(".replay-open");
  }
  function getReplayCloseBtn() {
    return getCurrentDocument().querySelector(".replay-close");
  }
  function getReplayForwardBtn() {
    return getCurrentDocument().querySelector(".replay-forward");
  }
  function getReplayForwardActionBtn() {
    return getCurrentDocument().querySelector(".replay-forward-action");
  }
  function getReplayBackwardBtn() {
    return getCurrentDocument().querySelector(".replay-backward");
  }
  function getReplayBackwardActionBtn() {
    return getCurrentDocument().querySelector(".replay-backward-action");
  }
  function getReplayDaySelectorCheckBox() {
    return getCurrentDocument().querySelector(".replay-day-selector");
  }
  function getConnectionErrorDiv() {
    return getCurrentDocument().querySelector(".connection-error-msg");
  }
  function getLiveQueueSelectPopup() {
    return getCurrentDocument().querySelector("#live-queue-select-popup");
  }
  function getLiveQueueBlockerPopup() {
    return getCurrentDocument().querySelector(".live-queue-blocker-popup");
  }
  function getBuildingDiv(buildingID) {
    return getCurrentDocument().querySelector(`.game-building[data-building-id='${buildingID}']`);
  }
  function getAllDamageSquares() {
    return Array.from(getCurrentDocument().getElementsByClassName("dmg-square"));
  }
  const moveAnimationDelayMS = 5;
  function moveDivToOffset(div, dx, dy, steps, ...followUpAnimations) {
    var _a;
    if (steps <= 1) {
      if (!followUpAnimations || followUpAnimations.length === 0) return;
      const nextSet = (_a = followUpAnimations.shift()) == null ? void 0 : _a.then;
      if (!nextSet) return;
      moveDivToOffset(div, nextSet[0], nextSet[1], nextSet[2], ...followUpAnimations);
      return;
    }
    window.setTimeout(() => moveDivToOffset(div, dx, dy, steps - 1, ...followUpAnimations), moveAnimationDelayMS);
    let left = parseFloat(div.style.left);
    let top2 = parseFloat(div.style.top);
    left += dx;
    top2 += dy;
    div.style.left = left + "px";
    div.style.top = top2 + "px";
  }
  function addUpdateCursorObserver(onCursorMove2) {
    const coordsDiv = getCoordsDiv();
    if (!coordsDiv) return;
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type !== "childList") return;
        if (!mutation.target) return;
        if (!mutation.target.textContent) return;
        let coordsText = mutation.target.textContent;
        coordsText = coordsText.substring(1, coordsText.length - 1);
        const splitCoords = coordsText.split(",");
        const cursorX = Number(splitCoords[0]);
        const cursorY = Number(splitCoords[1]);
        onCursorMove2(cursorX, cursorY);
      }
    });
    observer.observe(coordsDiv, { childList: true });
  }
  const ORANGE_STAR_COs = /* @__PURE__ */ new Set(["andy", "max", "sami", "nell", "hachi", "jake", "rachel"]);
  const BLUE_MOON_COs = /* @__PURE__ */ new Set(["olaf", "grit", "colin", "sasha"]);
  const GREEN_EARTH_COs = /* @__PURE__ */ new Set(["eagle", "drake", "jess", "javier"]);
  const YELLOW_COMET_COs = /* @__PURE__ */ new Set(["kanbei", "sonja", "sensei", "grimm"]);
  const BLACK_HOLE_COs = /* @__PURE__ */ new Set(["flak", "lash", "adder", "hawke", "sturm", "jugger", "koal", "kindle", "vonbolt"]);
  const AW2_ONLY_COs = /* @__PURE__ */ new Set(["hachi", "colin", "sensei", "jess", "flak", "adder", "lash", "hawke"]);
  const AW_DS_ONLY_COs = /* @__PURE__ */ new Set([
    "jake",
    "rachel",
    "sasha",
    "javier",
    "grimm",
    "kindle",
    "jugger",
    "koal",
    "vonbolt"
  ]);
  function getAllCONames(properCase = false) {
    if (!properCase)
      return [...ORANGE_STAR_COs, ...BLUE_MOON_COs, ...GREEN_EARTH_COs, ...YELLOW_COMET_COs, ...BLACK_HOLE_COs];
    const allCOs = [...ORANGE_STAR_COs, ...BLUE_MOON_COs, ...GREEN_EARTH_COs, ...YELLOW_COMET_COs, ...BLACK_HOLE_COs];
    allCOs[allCOs.indexOf("vonbolt")] = "Von Bolt";
    return allCOs.map((co) => co[0].toUpperCase() + co.slice(1));
  }
  function areAnimationsEnabled() {
    return typeof gameAnims !== "undefined" ? gameAnims : false;
  }
  function isBlackHoleCO(coName) {
    coName = coName.toLowerCase().replaceAll(" ", "");
    return BLACK_HOLE_COs.has(coName);
  }
  function getRandomCO(excludedCOs) {
    const COs = new Set(getAllCONames());
    for (const co of excludedCOs) COs.delete(co);
    if (COs.size === 0) return "map-editor";
    if (COs.size === 1) return [...COs][0];
    return [...COs][Math.floor(Math.random() * COs.size)];
  }
  var SpecialCOs = /* @__PURE__ */ ((SpecialCOs2) => {
    SpecialCOs2["Maintenance"] = "maintenance";
    SpecialCOs2["MapEditor"] = "map-editor";
    SpecialCOs2["MainPage"] = "main-page";
    SpecialCOs2["LiveQueue"] = "live-queue";
    SpecialCOs2["Default"] = "default";
    SpecialCOs2["Victory"] = "victory";
    SpecialCOs2["Defeat"] = "defeat";
    SpecialCOs2["COSelect"] = "co-select";
    SpecialCOs2["ModeSelect"] = "mode-select";
    return SpecialCOs2;
  })(SpecialCOs || {});
  var COPowerEnum = /* @__PURE__ */ ((COPowerEnum2) => {
    COPowerEnum2["NoPower"] = "N";
    COPowerEnum2["COPower"] = "Y";
    COPowerEnum2["SuperCOPower"] = "S";
    return COPowerEnum2;
  })(COPowerEnum || {});
  const siloDelayMS = areAnimationsEnabled() ? 3e3 : 0;
  const attackDelayMS = areAnimationsEnabled() ? 1e3 : 0;
  function getMyUsername() {
    const document2 = getCurrentDocument();
    const profileMenu = document2.querySelector("#profile-menu");
    if (!profileMenu) return null;
    const link = profileMenu.getElementsByClassName("dropdown-menu-link")[0];
    return link.href.split("username=")[1];
  }
  let myID = -1;
  function getMyID() {
    if (getCurrentPageType() !== PageType.ActiveGame) return -1;
    if (myID < 0) {
      getAllPlayersInfo().forEach((entry) => {
        if (entry.users_username === getMyUsername()) {
          myID = entry.players_id;
        }
      });
    }
    return myID;
  }
  function getPlayerInfo(pid) {
    if (getCurrentPageType() !== PageType.ActiveGame) return null;
    if (typeof playersInfo === "undefined") return null;
    return playersInfo[pid];
  }
  function getAllPlayersInfo() {
    if (getCurrentPageType() !== PageType.ActiveGame) return [];
    if (typeof playersInfo === "undefined") return [];
    return Object.values(playersInfo);
  }
  function isPlayerSpectator(pid) {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    if (typeof playerKeys === "undefined") return false;
    return !playerKeys.includes(pid);
  }
  function canPlayerActivateCOPower(pid) {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    const info = getPlayerInfo(pid);
    if (!info) return false;
    return info.players_co_power >= info.players_co_max_power;
  }
  function canPlayerActivateSuperCOPower(pid) {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    const info = getPlayerInfo(pid);
    if (!info) return false;
    return info.players_co_power >= info.players_co_max_spower;
  }
  function getBuildingInfo(x, y) {
    if (getCurrentPageType() !== PageType.ActiveGame) return null;
    if (typeof buildingsInfo === "undefined") return null;
    return buildingsInfo[x][y];
  }
  function isReplayActive() {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    const replayControls = getReplayControls();
    if (!replayControls) return false;
    const replayOpen = replayControls.style.display !== "none";
    return replayOpen && Object.keys(replay).length > 0;
  }
  function hasGameEnded() {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    if (typeof playersInfo === "undefined") return false;
    const numberOfRemainingPlayers = Object.values(playersInfo).filter((info) => info.players_eliminated === "N").length;
    return numberOfRemainingPlayers === 1;
  }
  function getCOImagePrefix() {
    if (typeof coTheme === "undefined") return "aw2";
    return coTheme;
  }
  function getServerTimeZone() {
    if (getCurrentPageType() !== PageType.ActiveGame) return "-05:00";
    if (typeof serverTimezone === "undefined") return "-05:00";
    if (!serverTimezone) return "-05:00";
    return serverTimezone;
  }
  function didGameEndToday() {
    if (!hasGameEnded()) return false;
    const serverTimezone2 = parseInt(getServerTimeZone());
    const endDate = new Date(gameEndDate);
    endDate.setHours(23, 59, 59);
    const now = /* @__PURE__ */ new Date();
    const timezoneOffset = now.getTimezoneOffset() / 60;
    const difference = +serverTimezone2 + timezoneOffset;
    const nowAdjustedToServer = new Date(now.getTime() + difference * 36e5);
    const endDateAdjustedToServer = new Date(endDate.getTime() + difference * 36e5);
    const oneDayMilliseconds = 24 * 60 * 60 * 1e3;
    return nowAdjustedToServer.getTime() - endDateAdjustedToServer.getTime() < oneDayMilliseconds;
  }
  function getCurrentGameDay() {
    if (getCurrentPageType() !== PageType.ActiveGame) return 1;
    if (typeof gameDay === "undefined") return 1;
    if (!isReplayActive()) return gameDay;
    const replayData = Object.values(replay);
    if (replayData.length === 0) return gameDay;
    const lastData = replayData[replayData.length - 1];
    if (typeof lastData === "undefined") return gameDay;
    if (typeof lastData.day === "undefined") return gameDay;
    return lastData.day;
  }
  class currentPlayer {
    /**
     * Get the internal info object containing the state of the current player.
     */
    static get info() {
      if (getCurrentPageType() !== PageType.ActiveGame) return null;
      if (typeof currentTurn === "undefined") return null;
      return getPlayerInfo(currentTurn);
    }
    /**
     * Determine whether a CO Power or Super CO Power is activated for the current player.
     * @returns - True if a regular CO power or a Super CO Power is activated.
     */
    static get isPowerActivated() {
      if (getCurrentPageType() !== PageType.ActiveGame) return false;
      return (this == null ? void 0 : this.coPowerState) !== "N";
    }
    /**
     * Gets state of the CO Power for the current player represented as a single letter.
     * @returns - The state of the CO Power for the current player.
     */
    static get coPowerState() {
      var _a;
      if (getCurrentPageType() !== PageType.ActiveGame) return "N";
      return (_a = this.info) == null ? void 0 : _a.players_co_power_on;
    }
    /**
     * Determine if the current player has been eliminated from the game.
     * @returns - True if the current player has been eliminated.
     */
    static get isEliminated() {
      var _a;
      if (getCurrentPageType() !== PageType.ActiveGame) return false;
      return ((_a = this.info) == null ? void 0 : _a.players_eliminated) === "Y";
    }
    /**
     * Gets the name of the CO for the current player.
     * If the game has ended, it will return "victory" or "defeat".
     * If we are in the map editor, it will return "map-editor".
     * @returns - The name of the CO for the current player.
     */
    static get coName() {
      var _a;
      if (getCurrentPageType() !== PageType.ActiveGame) return null;
      const myID2 = getMyID();
      const myInfo = getPlayerInfo(myID2);
      const myWin = (myInfo == null ? void 0 : myInfo.players_eliminated) === "N";
      const myLoss = (myInfo == null ? void 0 : myInfo.players_eliminated) === "Y";
      const endedToday = didGameEndToday();
      const isSpectator = isPlayerSpectator(myID2);
      const endGameTheme = isSpectator || myWin ? "victory" : "defeat";
      if (hasGameEnded()) {
        if (endedToday) return endGameTheme;
        if (!isReplayActive()) return "co-select";
        return endGameTheme;
      }
      if (myLoss) return "defeat";
      return (_a = this.info) == null ? void 0 : _a.co_name;
    }
  }
  function getAllPlayingCONames() {
    if (getCurrentPageType() === PageType.MapEditor) return /* @__PURE__ */ new Set(["map-editor"]);
    if (getCurrentPageType() !== PageType.ActiveGame) return /* @__PURE__ */ new Set();
    const allPlayers = new Set(getAllPlayersInfo().map((info) => info.co_name));
    const allTagPlayers = getAllTagCONames();
    return /* @__PURE__ */ new Set([...allPlayers, ...allTagPlayers]);
  }
  function isTagGame() {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    return typeof tagsInfo !== "undefined" && tagsInfo;
  }
  function getAllTagCONames() {
    if (getCurrentPageType() !== PageType.ActiveGame || !isTagGame()) return /* @__PURE__ */ new Set();
    if (typeof tagsInfo === "undefined") return /* @__PURE__ */ new Set();
    return new Set(Object.values(tagsInfo).map((tag) => tag.co_name));
  }
  function getUnitInfo(unitId) {
    if (getCurrentPageType() !== PageType.ActiveGame) return null;
    if (typeof unitsInfo === "undefined") return null;
    return unitsInfo[unitId];
  }
  function getUnitName(unitId) {
    var _a;
    if (getCurrentPageType() !== PageType.ActiveGame) return null;
    return (_a = getUnitInfo(unitId)) == null ? void 0 : _a.units_name;
  }
  function getUnitInfoFromCoords(x, y) {
    if (getCurrentPageType() !== PageType.ActiveGame) return null;
    if (typeof unitsInfo === "undefined") return null;
    return Object.values(unitsInfo).filter((info) => info.units_x == x && info.units_y == y).pop();
  }
  function isValidUnit(unitId) {
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    if (typeof unitsInfo === "undefined") return false;
    return unitId !== void 0 && unitsInfo[unitId] !== void 0;
  }
  function hasUnitMovedThisTurn(unitId) {
    var _a;
    if (getCurrentPageType() !== PageType.ActiveGame) return false;
    return isValidUnit(unitId) && ((_a = getUnitInfo(unitId)) == null ? void 0 : _a.units_moved) === 1;
  }
  function addConnectionErrorObserver(onConnectionError2) {
    const connectionErrorDiv = getConnectionErrorDiv();
    if (!connectionErrorDiv) return;
    const observer = new MutationObserver((mutationsList) => {
      for (const mutation of mutationsList) {
        if (mutation.type !== "childList") return;
        if (!mutation.target) return;
        if (!mutation.target.textContent) return;
        const closeMsg = mutation.target.textContent;
        onConnectionError2(closeMsg);
      }
    });
    observer.observe(connectionErrorDiv, { childList: true });
  }
  var GameType = /* @__PURE__ */ ((GameType2) => {
    GameType2["AW1"] = "AW1";
    GameType2["AW2"] = "AW2";
    GameType2["RBC"] = "RBC";
    GameType2["DS"] = "DS";
    return GameType2;
  })(GameType || {});
  var ThemeType = /* @__PURE__ */ ((ThemeType2) => {
    ThemeType2["REGULAR"] = "REGULAR";
    ThemeType2["CO_POWER"] = "CO_POWER";
    ThemeType2["SUPER_CO_POWER"] = "SUPER_CO_POWER";
    return ThemeType2;
  })(ThemeType || {});
  var RandomThemeType = /* @__PURE__ */ ((RandomThemeType2) => {
    RandomThemeType2["NONE"] = "NONE";
    RandomThemeType2["ALL_THEMES"] = "ALL_THEMES";
    RandomThemeType2["CURRENT_SOUNDTRACK"] = "CURRENT_SOUNDTRACK";
    return RandomThemeType2;
  })(RandomThemeType || {});
  function getCurrentThemeType() {
    const currentPowerState = currentPlayer == null ? void 0 : currentPlayer.coPowerState;
    if (currentPowerState === "Y") return "CO_POWER";
    if (currentPowerState === "S") return "SUPER_CO_POWER";
    return "REGULAR";
  }
  function getRandomGameType(excludedGameTypes = /* @__PURE__ */ new Set()) {
    const gameTypes = Object.values(GameType).filter((gameType) => !excludedGameTypes.has(gameType));
    return gameTypes[Math.floor(Math.random() * gameTypes.length)];
  }
  const STORAGE_KEY = "musicPlayerSettings";
  const onSettingsChangeListeners = [];
  function addSettingsChangeListener(fn) {
    onSettingsChangeListeners.push(fn);
  }
  var SettingsKey = /* @__PURE__ */ ((SettingsKey2) => {
    SettingsKey2["IS_PLAYING"] = "isPlaying";
    SettingsKey2["VOLUME"] = "volume";
    SettingsKey2["SFX_VOLUME"] = "sfxVolume";
    SettingsKey2["UI_VOLUME"] = "uiVolume";
    SettingsKey2["GAME_TYPE"] = "gameType";
    SettingsKey2["ALTERNATE_THEMES"] = "alternateThemes";
    SettingsKey2["ALTERNATE_THEME_DAY"] = "alternateThemeDay";
    SettingsKey2["RANDOM_THEMES_TYPE"] = "randomThemesType";
    SettingsKey2["CAPTURE_PROGRESS_SFX"] = "captureProgressSFX";
    SettingsKey2["PIPE_SEAM_SFX"] = "pipeSeamSFX";
    SettingsKey2["OVERRIDE_LIST"] = "overrideList";
    SettingsKey2["RESTART_THEMES"] = "restartThemes";
    SettingsKey2["AUTOPLAY_ON_OTHER_PAGES"] = "autoplayOnOtherPages";
    SettingsKey2["EXCLUDED_RANDOM_THEMES"] = "excludedRandomThemes";
    SettingsKey2["LOOP_RANDOM_SONGS_UNTIL_TURN_CHANGE"] = "loopRandomSongsUntilTurnChange";
    SettingsKey2["SFX_ON_OTHER_PAGES"] = "sfxOnOtherPages";
    SettingsKey2["THEME_TYPE"] = "themeType";
    SettingsKey2["CURRENT_RANDOM_CO"] = "currentRandomCO";
    SettingsKey2["ALL"] = "all";
    SettingsKey2["ADD_OVERRIDE"] = "addOverride";
    SettingsKey2["REMOVE_OVERRIDE"] = "removeOverride";
    SettingsKey2["ADD_EXCLUDED"] = "addExcluded";
    SettingsKey2["REMOVE_EXCLUDED"] = "removeExcluded";
    return SettingsKey2;
  })(SettingsKey || {});
  class musicSettings {
    static toJSON() {
      return JSON.stringify({
        isPlaying: this.__isPlaying,
        volume: this.__volume,
        sfxVolume: this.__sfxVolume,
        uiVolume: this.__uiVolume,
        gameType: this.__gameType,
        alternateThemes: this.__alternateThemes,
        alternateThemeDay: this.__alternateThemeDay,
        randomThemesType: this.__randomThemesType,
        captureProgressSFX: this.__captureProgressSFX,
        pipeSeamSFX: this.__pipeSeamSFX,
        overrideList: Array.from(this.__overrideList.entries()),
        restartThemes: this.__restartThemes,
        autoplayOnOtherPages: this.__autoplayOnOtherPages,
        excludedRandomThemes: Array.from(this.__excludedRandomThemes),
        loopRandomSongsUntilTurnChange: this.__loopRandomSongsUntilTurnChange,
        sfxOnOtherPages: this.__sfxOnOtherPages
      });
    }
    static runWithoutSavingSettings(fn) {
      this.isLoaded = false;
      this.saveChanges = false;
      fn();
      this.isLoaded = true;
      this.saveChanges = true;
    }
    static fromJSON(json) {
      const savedSettings = JSON.parse(json);
      for (let key in this) {
        key = key.substring(2);
        if (Object.hasOwn(savedSettings, key)) {
          if (key === "overrideList") {
            this.__overrideList = new Map(savedSettings[key]);
            continue;
          }
          if (key === "excludedRandomThemes") {
            this.__excludedRandomThemes = new Set(savedSettings[key]);
            continue;
          }
          this[key] = savedSettings[key];
        }
      }
      this.isLoaded = true;
      broadcastChannel.addEventListener("message", onStorageBroadcast);
    }
    static set isPlaying(val) {
      if (this.__isPlaying === val) return;
      this.__isPlaying = val;
      this.onSettingChangeEvent("isPlaying", val);
    }
    static get isPlaying() {
      return this.__isPlaying;
    }
    static set volume(val) {
      if (this.__volume === val) return;
      this.__volume = val;
      this.onSettingChangeEvent("volume", val);
    }
    static get volume() {
      return this.__volume;
    }
    static set sfxVolume(val) {
      if (this.__sfxVolume === val) return;
      this.__sfxVolume = val;
      this.onSettingChangeEvent("sfxVolume", val);
    }
    static get sfxVolume() {
      return this.__sfxVolume;
    }
    static set uiVolume(val) {
      if (this.__uiVolume === val) return;
      this.__uiVolume = val;
      this.onSettingChangeEvent("uiVolume", val);
    }
    static get uiVolume() {
      return this.__uiVolume;
    }
    static set gameType(val) {
      if (this.__gameType === val) return;
      this.__gameType = val;
      this.__currentRandomGameType = val;
      this.onSettingChangeEvent("gameType", val);
    }
    static get gameType() {
      return this.__gameType;
    }
    static set alternateThemes(val) {
      if (this.__alternateThemes === val) return;
      this.__alternateThemes = val;
      this.onSettingChangeEvent("alternateThemes", val);
    }
    static get alternateThemes() {
      return this.__alternateThemes;
    }
    static set alternateThemeDay(val) {
      if (this.__alternateThemeDay === val) return;
      this.__alternateThemeDay = val;
      this.onSettingChangeEvent("alternateThemeDay", val);
    }
    static get alternateThemeDay() {
      return this.__alternateThemeDay;
    }
    static set captureProgressSFX(val) {
      this.__captureProgressSFX = val;
      this.onSettingChangeEvent("captureProgressSFX", val);
    }
    static get captureProgressSFX() {
      return this.__captureProgressSFX;
    }
    static set pipeSeamSFX(val) {
      this.__pipeSeamSFX = val;
      this.onSettingChangeEvent("pipeSeamSFX", val);
    }
    static get pipeSeamSFX() {
      return this.__pipeSeamSFX;
    }
    static set overrideList(val) {
      this.__overrideList = new Map([...val.entries()].sort());
      this.onSettingChangeEvent("overrideList", val);
    }
    static get overrideList() {
      return this.__overrideList;
    }
    static addOverride(coName, gameType) {
      this.__overrideList.set(coName, gameType);
      this.__overrideList = new Map([...this.__overrideList.entries()].sort());
      this.onSettingChangeEvent("addOverride", [coName, gameType]);
    }
    static removeOverride(coName) {
      if (!this.__overrideList.has(coName)) return;
      this.__overrideList.delete(coName);
      this.__overrideList = new Map([...this.__overrideList.entries()].sort());
      this.onSettingChangeEvent("removeOverride", coName);
    }
    static getOverride(coName) {
      return this.__overrideList.get(coName);
    }
    static get restartThemes() {
      return this.__restartThemes;
    }
    static set restartThemes(val) {
      if (this.__restartThemes === val) return;
      this.__restartThemes = val;
      this.onSettingChangeEvent("restartThemes", val);
    }
    static get autoplayOnOtherPages() {
      return this.__autoplayOnOtherPages;
    }
    static set autoplayOnOtherPages(val) {
      if (this.__autoplayOnOtherPages === val) return;
      this.__autoplayOnOtherPages = val;
      this.onSettingChangeEvent("autoplayOnOtherPages", val);
    }
    static get excludedRandomThemes() {
      return this.__excludedRandomThemes;
    }
    static set excludedRandomThemes(val) {
      this.__excludedRandomThemes = val;
      this.onSettingChangeEvent("excludedRandomThemes", val);
    }
    static addExcludedRandomTheme(theme) {
      this.__excludedRandomThemes.add(theme);
      this.onSettingChangeEvent("addExcluded", theme);
    }
    static removeExcludedRandomTheme(theme) {
      if (!this.__excludedRandomThemes.has(theme)) return;
      this.__excludedRandomThemes.delete(theme);
      this.onSettingChangeEvent("removeExcluded", theme);
    }
    static get loopRandomSongsUntilTurnChange() {
      return this.__loopRandomSongsUntilTurnChange;
    }
    static set loopRandomSongsUntilTurnChange(val) {
      if (this.__loopRandomSongsUntilTurnChange === val) return;
      this.__loopRandomSongsUntilTurnChange = val;
      this.onSettingChangeEvent("loopRandomSongsUntilTurnChange", val);
    }
    static get sfxOnOtherPages() {
      return this.__sfxOnOtherPages;
    }
    static set sfxOnOtherPages(val) {
      if (this.__sfxOnOtherPages === val) return;
      this.__sfxOnOtherPages = val;
      this.onSettingChangeEvent("sfxOnOtherPages", val);
    }
    // ************* Non-user configurable settings from here on
    static set themeType(val) {
      if (this.__themeType === val) return;
      this.__themeType = val;
      this.onSettingChangeEvent("themeType", val);
    }
    static get themeType() {
      return this.__themeType;
    }
    static set randomThemesType(val) {
      if (this.__randomThemesType === val) return;
      this.__randomThemesType = val;
      this.onSettingChangeEvent("randomThemesType", val);
    }
    static get randomThemesType() {
      return this.__randomThemesType;
    }
    static get currentRandomCO() {
      if (!this.__currentRandomCO || this.__currentRandomCO == "") this.randomizeCO();
      return this.__currentRandomCO;
    }
    static get currentRandomGameType() {
      return this.__currentRandomGameType;
    }
    static randomizeCO() {
      const excludedCOs = /* @__PURE__ */ new Set([...this.__excludedRandomThemes, this.__currentRandomCO]);
      this.__currentRandomCO = getRandomCO(excludedCOs);
      const isPower = this.themeType !== "REGULAR";
      const excludedSoundtracks = /* @__PURE__ */ new Set();
      if (isPower) excludedSoundtracks.add(
        "AW1"
        /* AW1 */
      );
      this.__currentRandomGameType = getRandomGameType(excludedSoundtracks);
      this.onSettingChangeEvent("currentRandomCO", null);
    }
    static onSettingChangeEvent(key, value) {
      onSettingsChangeListeners.forEach((fn) => fn(key, value, !this.isLoaded));
    }
  }
  // User configurable settings
  __publicField(musicSettings, "__isPlaying", false);
  __publicField(musicSettings, "__volume", 0.5);
  __publicField(musicSettings, "__sfxVolume", 0.4);
  __publicField(musicSettings, "__uiVolume", 0.4);
  __publicField(musicSettings, "__gameType", "DS");
  __publicField(musicSettings, "__alternateThemes", true);
  __publicField(musicSettings, "__alternateThemeDay", 15);
  __publicField(musicSettings, "__randomThemesType", "NONE");
  __publicField(musicSettings, "__captureProgressSFX", true);
  __publicField(musicSettings, "__pipeSeamSFX", true);
  __publicField(musicSettings, "__overrideList", /* @__PURE__ */ new Map());
  __publicField(musicSettings, "__restartThemes", false);
  __publicField(musicSettings, "__autoplayOnOtherPages", true);
  __publicField(musicSettings, "__excludedRandomThemes", /* @__PURE__ */ new Set());
  __publicField(musicSettings, "__loopRandomSongsUntilTurnChange", false);
  __publicField(musicSettings, "__sfxOnOtherPages", true);
  // Non-user configurable settings
  __publicField(musicSettings, "__themeType", "REGULAR");
  __publicField(musicSettings, "__currentRandomCO", "");
  __publicField(musicSettings, "__currentRandomGameType", "DS");
  __publicField(musicSettings, "isLoaded", false);
  __publicField(musicSettings, "saveChanges", false);
  function loadSettingsFromLocalStorage() {
    let storageData = localStorage.getItem(STORAGE_KEY);
    if (!storageData || storageData === "undefined") {
      logInfo("No saved settings found, storing defaults");
      updateSettingsInLocalStorage();
      storageData = localStorage.getItem(STORAGE_KEY);
      if (!storageData) {
        logError("Failed to store default settings in local storage");
        return;
      }
    }
    musicSettings.fromJSON(storageData);
    onSettingsChangeListeners.forEach((fn) => fn("all", null, true));
    logDebug("Settings loaded from storage:", storageData);
    addSettingsChangeListener(onSettingsChange$2);
  }
  function allowSettingsToBeSaved() {
    musicSettings.saveChanges = true;
  }
  function onSettingsChange$2(key, value, _isFirstLoad) {
    if (key === "themeType" || key === "currentRandomCO") return;
    if (!musicSettings.saveChanges) return;
    updateSettingsInLocalStorage();
    broadcastChannel.postMessage({ type: "settings", key, value });
  }
  const updateSettingsInLocalStorage = debounce$1(500, __updateSettingsInLocalStorage);
  function __updateSettingsInLocalStorage() {
    const jsonSettings = musicSettings.toJSON();
    localStorage.setItem(STORAGE_KEY, jsonSettings);
    logDebug("Saving settings...", jsonSettings);
    return;
  }
  function onStorageBroadcast(event2) {
    if (event2.data.type !== "settings") return;
    const key = event2.data.key;
    const value = event2.data.value;
    logDebug("Received settings change:", key, value);
    musicSettings.runWithoutSavingSettings(() => {
      switch (key) {
        case "volume":
          musicSettings.volume = value;
          break;
        case "sfxVolume":
          musicSettings.sfxVolume = value;
          break;
        case "uiVolume":
          musicSettings.uiVolume = value;
          break;
        case "themeType":
          musicSettings.themeType = value;
          break;
        case "gameType":
          musicSettings.gameType = value;
          break;
        case "alternateThemes":
          musicSettings.alternateThemes = value;
          break;
        case "alternateThemeDay":
          musicSettings.alternateThemeDay = value;
          break;
        case "randomThemesType":
          musicSettings.randomThemesType = value;
          break;
        case "captureProgressSFX":
          musicSettings.captureProgressSFX = value;
          break;
        case "pipeSeamSFX":
          musicSettings.pipeSeamSFX = value;
          break;
        case "restartThemes":
          musicSettings.restartThemes = value;
          break;
        case "autoplayOnOtherPages":
          musicSettings.autoplayOnOtherPages = value;
          break;
        case "addOverride":
          musicSettings.addOverride(value[0], value[1]);
          break;
        case "removeOverride":
          musicSettings.removeOverride(value);
          break;
        case "addExcluded":
          musicSettings.addExcludedRandomTheme(value);
          break;
        case "removeExcluded":
          musicSettings.removeExcludedRandomTheme(value);
          break;
        case "loopRandomSongsUntilTurnChange":
          musicSettings.loopRandomSongsUntilTurnChange = value;
          break;
        case "sfxOnOtherPages":
          musicSettings.sfxOnOtherPages = value;
          break;
      }
    });
  }
  const BASE_URL = "https://developerjose.netlify.app";
  const BASE_MUSIC_URL = BASE_URL + "/music";
  const BASE_SFX_URL = BASE_MUSIC_URL + "/sfx";
  const NEUTRAL_IMG_URL = BASE_URL + "/img/music-player-icon.png";
  const PLAYING_IMG_URL = BASE_URL + "/img/music-player-playing.gif";
  const HASH_JSON_URL = BASE_MUSIC_URL + "/hashes.json";
  var SpecialTheme = ((SpecialTheme2) => {
    SpecialTheme2["Victory"] = BASE_MUSIC_URL + "/t-victory.ogg";
    SpecialTheme2["Defeat"] = BASE_MUSIC_URL + "/t-defeat.ogg";
    SpecialTheme2["Maintenance"] = BASE_MUSIC_URL + "/t-maintenance.ogg";
    SpecialTheme2["COSelect"] = BASE_MUSIC_URL + "/t-co-select.ogg";
    SpecialTheme2["ModeSelect"] = BASE_MUSIC_URL + "/t-mode-select.ogg";
    return SpecialTheme2;
  })(SpecialTheme || {});
  var GameSFX = /* @__PURE__ */ ((GameSFX2) => {
    GameSFX2["coGoldRush"] = "co-gold-rush";
    GameSFX2["powerActivateAllyCOP"] = "power-activate-ally-cop";
    GameSFX2["powerActivateAllySCOP"] = "power-activate-ally-scop";
    GameSFX2["powerActivateBHCOP"] = "power-activate-bh-cop";
    GameSFX2["powerActivateBHSCOP"] = "power-activate-bh-scop";
    GameSFX2["powerActivateAW1COP"] = "power-activate-aw1-cop";
    GameSFX2["powerSCOPAvailable"] = "power-scop-available";
    GameSFX2["powerCOPAvailable"] = "power-cop-available";
    GameSFX2["tagBreakAlly"] = "tag-break-ally";
    GameSFX2["tagBreakBH"] = "tag-break-bh";
    GameSFX2["tagSwap"] = "tag-swap";
    GameSFX2["unitAttackPipeSeam"] = "unit-attack-pipe-seam";
    GameSFX2["unitCaptureAlly"] = "unit-capture-ally";
    GameSFX2["unitCaptureEnemy"] = "unit-capture-enemy";
    GameSFX2["unitCaptureProgress"] = "unit-capture-progress";
    GameSFX2["unitMissileHit"] = "unit-missile-hit";
    GameSFX2["unitMissileSend"] = "unit-missile-send";
    GameSFX2["unitHide"] = "unit-hide";
    GameSFX2["unitUnhide"] = "unit-unhide";
    GameSFX2["unitSupply"] = "unit-supply";
    GameSFX2["unitTrap"] = "unit-trap";
    GameSFX2["unitLoad"] = "unit-load";
    GameSFX2["unitUnload"] = "unit-unload";
    GameSFX2["unitExplode"] = "unit-explode";
    GameSFX2["uiCursorMove"] = "ui-cursor-move";
    GameSFX2["uiInvalid"] = "ui-invalid";
    GameSFX2["uiMenuOpen"] = "ui-menu-open";
    GameSFX2["uiMenuClose"] = "ui-menu-close";
    GameSFX2["uiMenuMove"] = "ui-menu-move";
    GameSFX2["uiUnitSelect"] = "ui-unit-select";
    return GameSFX2;
  })(GameSFX || {});
  const onMovementStartMap = /* @__PURE__ */ new Map([
    [
      "APC",
      "move-tread-light"
      /* moveTreadLightLoop */
    ],
    [
      "Anti-Air",
      "move-tread-light"
      /* moveTreadLightLoop */
    ],
    [
      "Artillery",
      "move-tread-light"
      /* moveTreadLightLoop */
    ],
    [
      "B-Copter",
      "move-bcopter"
      /* moveBCopterLoop */
    ],
    [
      "Battleship",
      "move-naval"
      /* moveNavalLoop */
    ],
    [
      "Black Boat",
      "move-naval"
      /* moveNavalLoop */
    ],
    [
      "Black Bomb",
      "move-plane"
      /* movePlaneLoop */
    ],
    [
      "Bomber",
      "move-plane"
      /* movePlaneLoop */
    ],
    [
      "Carrier",
      "move-naval"
      /* moveNavalLoop */
    ],
    [
      "Cruiser",
      "move-naval"
      /* moveNavalLoop */
    ],
    [
      "Fighter",
      "move-plane"
      /* movePlaneLoop */
    ],
    [
      "Infantry",
      "move-inf"
      /* moveInfLoop */
    ],
    [
      "Lander",
      "move-naval"
      /* moveNavalLoop */
    ],
    [
      "Md.Tank",
      "move-tread-heavy"
      /* moveTreadHeavyLoop */
    ],
    [
      "Mech",
      "move-mech"
      /* moveMechLoop */
    ],
    [
      "Mega Tank",
      "move-tread-heavy"
      /* moveTreadHeavyLoop */
    ],
    [
      "Missile",
      "move-tires-heavy"
      /* moveTiresHeavyLoop */
    ],
    [
      "Neotank",
      "move-tread-heavy"
      /* moveTreadHeavyLoop */
    ],
    [
      "Piperunner",
      "move-piperunner"
      /* movePiperunnerLoop */
    ],
    [
      "Recon",
      "move-tires-light"
      /* moveTiresLightLoop */
    ],
    [
      "Rocket",
      "move-tires-heavy"
      /* moveTiresHeavyLoop */
    ],
    [
      "Stealth",
      "move-plane"
      /* movePlaneLoop */
    ],
    [
      "Sub",
      "move-sub"
      /* moveSubLoop */
    ],
    [
      "T-Copter",
      "move-tcopter"
      /* moveTCopterLoop */
    ],
    [
      "Tank",
      "move-tread-light"
      /* moveTreadLightLoop */
    ]
  ]);
  const onMovementRolloffMap = /* @__PURE__ */ new Map([
    [
      "APC",
      "move-tread-light-rolloff"
      /* moveTreadLightOneShot */
    ],
    [
      "Anti-Air",
      "move-tread-light-rolloff"
      /* moveTreadLightOneShot */
    ],
    [
      "Artillery",
      "move-tread-light-rolloff"
      /* moveTreadLightOneShot */
    ],
    [
      "B-Copter",
      "move-bcopter-rolloff"
      /* moveBCopterOneShot */
    ],
    [
      "Black Bomb",
      "move-plane-rolloff"
      /* movePlaneOneShot */
    ],
    [
      "Bomber",
      "move-plane-rolloff"
      /* movePlaneOneShot */
    ],
    [
      "Fighter",
      "move-plane-rolloff"
      /* movePlaneOneShot */
    ],
    [
      "Md. Tank",
      "move-tread-heavy-rolloff"
      /* moveTreadHeavyOneShot */
    ],
    [
      "Mega Tank",
      "move-tread-heavy-rolloff"
      /* moveTreadHeavyOneShot */
    ],
    [
      "Missile",
      "move-tires-heavy-rolloff"
      /* moveTiresHeavyOneShot */
    ],
    [
      "Neotank",
      "move-tread-heavy-rolloff"
      /* moveTreadHeavyOneShot */
    ],
    [
      "Recon",
      "move-tires-light-rolloff"
      /* moveTiresLightOneShot */
    ],
    [
      "Rocket",
      "move-tires-heavy-rolloff"
      /* moveTiresHeavyOneShot */
    ],
    [
      "Stealth",
      "move-plane-rolloff"
      /* movePlaneOneShot */
    ],
    [
      "T-Copter",
      "move-tcopter-rolloff"
      /* moveTCopterOneShot */
    ],
    [
      "Tank",
      "move-tread-light-rolloff"
      /* moveTreadLightOneShot */
    ]
  ]);
  const alternateThemes = /* @__PURE__ */ new Map([
    [GameType.AW1, /* @__PURE__ */ new Set(["sturm"])],
    [GameType.AW2, /* @__PURE__ */ new Set(["sturm"])],
    [GameType.RBC, /* @__PURE__ */ new Set(["andy", "olaf", "eagle", "drake", "grit", "kanbei", "sonja", "sturm"])],
    [GameType.DS, /* @__PURE__ */ new Set(["sturm", "vonbolt"])]
  ]);
  const specialLoops = /* @__PURE__ */ new Set(["vonbolt"]);
  function getAlternateMusicFilename(coName, gameType, themeType) {
    if (!alternateThemes.has(gameType)) return;
    const alternateThemesSet = alternateThemes.get(gameType);
    const faction = isBlackHoleCO(coName) ? "bh" : "ally";
    const isPowerActive = themeType !== ThemeType.REGULAR;
    if (gameType === GameType.RBC && isPowerActive) {
      return `t-${faction}-${themeType}`;
    }
    if (!(alternateThemesSet == null ? void 0 : alternateThemesSet.has(coName)) || isPowerActive) {
      return;
    }
    if (coName === "andy" && gameType == GameType.RBC) {
      return isPowerActive ? "t-clone-andy-cop" : "t-clone-andy";
    }
    return `t-${coName}-2`;
  }
  function getMusicFilename(coName, gameType, themeType, useAlternateTheme) {
    if (coName === SpecialCOs.MapEditor) return "t-map-editor";
    if (useAlternateTheme) {
      const alternateFilename = getAlternateMusicFilename(coName, gameType, themeType);
      if (alternateFilename) return alternateFilename;
    }
    const isPowerActive = themeType !== ThemeType.REGULAR;
    if (!isPowerActive || gameType === GameType.AW1) {
      return `t-${coName}`;
    }
    const isCOInRBC = !AW_DS_ONLY_COs.has(coName);
    if (gameType === GameType.RBC && isCOInRBC) {
      return `t-${coName}-cop`;
    }
    const faction = isBlackHoleCO(coName) ? "bh" : "ally";
    return `t-${faction}-${themeType}`;
  }
  function getMusicURL(coName, gameType, themeType, useAlternateTheme) {
    if (gameType === null || gameType === void 0) gameType = musicSettings.gameType;
    if (themeType === null || themeType === void 0) themeType = musicSettings.themeType;
    if (useAlternateTheme === null || useAlternateTheme === void 0) {
      useAlternateTheme = getCurrentGameDay() >= musicSettings.alternateThemeDay && musicSettings.alternateThemes;
    }
    coName = coName.toLowerCase().replaceAll(" ", "");
    if (coName === SpecialCOs.Victory) return SpecialTheme.Victory;
    if (coName === SpecialCOs.Defeat) return SpecialTheme.Defeat;
    if (coName === SpecialCOs.Maintenance) return SpecialTheme.Maintenance;
    if (coName === SpecialCOs.COSelect) return SpecialTheme.COSelect;
    if (coName === SpecialCOs.ModeSelect || coName === SpecialCOs.MainPage || coName === SpecialCOs.LiveQueue || coName === SpecialCOs.Default)
      return SpecialTheme.ModeSelect;
    const overrideType = musicSettings.getOverride(coName);
    if (overrideType) gameType = overrideType;
    const filename = getMusicFilename(coName, gameType, themeType, useAlternateTheme);
    if (gameType !== GameType.DS && AW_DS_ONLY_COs.has(coName)) gameType = GameType.DS;
    if (gameType === GameType.AW1 && AW2_ONLY_COs.has(coName)) gameType = GameType.AW2;
    let gameDir = gameType;
    if (!gameDir.startsWith("AW")) gameDir = "AW_" + gameDir;
    const url = `${BASE_MUSIC_URL}/${gameDir}/${filename}.ogg`;
    return url.toLowerCase().replaceAll("_", "-").replaceAll(" ", "");
  }
  function getCONameFromURL(url) {
    const parts = url.split("/");
    const filename = parts[parts.length - 1];
    const coName = filename.split(".")[0].substring(2);
    return coName;
  }
  function getSoundEffectURL(sfx) {
    return `${BASE_SFX_URL}/${sfx}.ogg`;
  }
  function getMovementSoundURL(unitName) {
    const sfx = onMovementStartMap.get(unitName);
    if (!sfx) return "";
    return `${BASE_SFX_URL}/${onMovementStartMap.get(unitName)}.ogg`;
  }
  function getMovementRollOffURL(unitName) {
    return `${BASE_SFX_URL}/${onMovementRolloffMap.get(unitName)}.ogg`;
  }
  function hasMovementRollOff(unitName) {
    return onMovementRolloffMap.has(unitName);
  }
  function hasSpecialLoop(srcURL) {
    const coName = getCONameFromURL(srcURL);
    return specialLoops.has(coName);
  }
  function getCurrentThemeURLs() {
    const coNames = getAllPlayingCONames();
    const audioList = /* @__PURE__ */ new Set();
    coNames.forEach((name) => {
      const regularURL = getMusicURL(name, musicSettings.gameType, ThemeType.REGULAR, false);
      const powerURL = getMusicURL(name, musicSettings.gameType, ThemeType.CO_POWER, false);
      const superPowerURL = getMusicURL(name, musicSettings.gameType, ThemeType.SUPER_CO_POWER, false);
      const alternateURL = getMusicURL(name, musicSettings.gameType, musicSettings.themeType, true);
      audioList.add(regularURL);
      audioList.add(alternateURL);
      audioList.add(powerURL);
      audioList.add(superPowerURL);
      if (specialLoops.has(name)) audioList.add(regularURL.replace(".ogg", "-loop.ogg"));
    });
    return audioList;
  }
  var ScriptName = /* @__PURE__ */ ((ScriptName2) => {
    ScriptName2["None"] = "none";
    ScriptName2["MusicPlayer"] = "music_player";
    ScriptName2["HighlightCursorCoordinates"] = "highlight_cursor_coordinates";
    return ScriptName2;
  })(ScriptName || {});
  const versions = /* @__PURE__ */ new Map([
    ["music_player", "5.1.0"],
    ["highlight_cursor_coordinates", "2.3.0"]
  ]);
  const updateURLs = /* @__PURE__ */ new Map([
    ["music_player", "https://update.greasyfork.org/scripts/518170/Improved%20AWBW%20Music%20Player.meta.js"],
    [
      "highlight_cursor_coordinates",
      "https://update.greasyfork.org/scripts/520884/AWBW%20Highlight%20Cursor%20Coordinates.meta.js"
    ]
  ]);
  const homepageURLs = /* @__PURE__ */ new Map([
    ["music_player", "https://greasyfork.org/en/scripts/518170-improved-awbw-music-player"],
    ["highlight_cursor_coordinates", "https://greasyfork.org/en/scripts/520884-awbw-highlight-cursor-coordinates"]
  ]);
  function checkIfUpdateIsAvailable(scriptName) {
    const isGreater = (a2, b) => {
      return a2.localeCompare(b, void 0, { numeric: true }) === 1;
    };
    return new Promise((resolve, reject) => {
      const updateURL = updateURLs.get(scriptName);
      if (!updateURL) return reject(`Failed to get the update URL for the script.`);
      return fetch(updateURL).then((response) => response.text()).then((text) => {
        var _a;
        if (!text) return reject(`Failed to get the HTML from the update URL for the script.`);
        const latestVersion = (_a = text.match(/@version\s+([0-9.]+)/)) == null ? void 0 : _a[1];
        if (!latestVersion) return reject(`Failed to get the latest version of the script.`);
        const currentVersion = versions.get(scriptName);
        if (!currentVersion) return reject(`Failed to get the current version of the script.`);
        const currentVersionParts = currentVersion.split(".");
        const latestVersionParts = latestVersion.split(".");
        const hasThreeParts = currentVersionParts.length === 3 && latestVersionParts.length === 3;
        if (!hasThreeParts) return reject(`The version number of the script is not in the correct format.`);
        const isUpdateAvailable = isGreater(latestVersion, currentVersion);
        logDebug(`Current version: ${currentVersion}, latest: ${latestVersion}, update needed: ${isUpdateAvailable}`);
        return resolve(isUpdateAvailable);
      }).catch((reason) => reject(reason));
    });
  }
  var GroupType = /* @__PURE__ */ ((GroupType2) => {
    GroupType2["Vertical"] = "cls-vertical-box";
    GroupType2["Horizontal"] = "cls-horizontal-box";
    return GroupType2;
  })(GroupType || {});
  function sanitize(str) {
    return str.toLowerCase().replaceAll(" ", "-");
  }
  var NodeID = /* @__PURE__ */ ((NodeID2) => {
    NodeID2["Parent"] = "parent";
    NodeID2["Hover"] = "hover";
    NodeID2["Background"] = "background";
    NodeID2["Button_Image"] = "button-image";
    NodeID2["Settings"] = "settings";
    NodeID2["Settings_Left"] = "settings-left";
    NodeID2["Settings_Center"] = "settings-center";
    NodeID2["Settings_Right"] = "settings-right";
    NodeID2["Version"] = "version";
    NodeID2["CO_Selector"] = "co-selector";
    NodeID2["CO_Portrait"] = "co-portrait";
    return NodeID2;
  })(NodeID || {});
  class CustomMenuSettingsUI {
    /**
     * Creates a new Custom Menu UI, to add it to AWBW you need to call {@link addToAWBWPage}.
     * @param prefix - A string used to prefix the IDs of the elements in the menu.
     * @param buttonImageURL - The URL of the image to be used as the button.
     * @param hoverText - The text to be displayed when hovering over the button.
     */
    constructor(prefix, buttonImageURL, hoverText = "") {
      /**
       * The root element or parent of the custom menu.
       */
      __publicField(this, "parent");
      /**
       * A map that contains the important nodes of the menu.
       * The keys are the names of the children, and the values are the elements themselves.
       * Allows for easy access to any element in the menu.
       */
      __publicField(this, "groups", /* @__PURE__ */ new Map());
      /**
       * A map that contains the group types for each group in the menu.
       * The keys are the names of the groups, and the values are the types of the groups.
       */
      __publicField(this, "groupTypes", /* @__PURE__ */ new Map());
      /**
       * An array of all the input elements in the menu.
       */
      __publicField(this, "inputElements", []);
      /**
       * An array of all the button elements in the menu.
       */
      __publicField(this, "buttonElements", []);
      /**
       * A boolean that represents whether the settings menu is open or not.
       */
      __publicField(this, "isSettingsMenuOpen", false);
      /**
       * A string used to prefix the IDs of the elements in the menu.
       */
      __publicField(this, "prefix");
      /**
       * A boolean that represents whether an update is available for the script.
       */
      __publicField(this, "isUpdateAvailable", false);
      /**
       * Text to be displayed when hovering over the main button.
       */
      __publicField(this, "parentHoverText", "");
      /**
       * A map that contains the tables in the menu.
       * The keys are the names of the tables, and the values are the table elements.
       */
      __publicField(this, "tableMap", /* @__PURE__ */ new Map());
      this.prefix = prefix;
      this.parentHoverText = hoverText;
      this.parent = document.createElement("div");
      this.parent.classList.add("game-tools-btn");
      this.parent.style.width = "34px";
      this.parent.style.height = "30px";
      this.setNodeID(
        this.parent,
        "parent"
        /* Parent */
      );
      const hoverSpan = document.createElement("span");
      hoverSpan.classList.add("game-tools-btn-text", "small_text");
      hoverSpan.innerText = hoverText;
      this.parent.appendChild(hoverSpan);
      this.setNodeID(
        hoverSpan,
        "hover"
        /* Hover */
      );
      const bgDiv = document.createElement("div");
      bgDiv.classList.add("game-tools-bg");
      bgDiv.style.backgroundImage = "linear-gradient(to right, #ffffff 0% , #888888 0%)";
      this.parent.appendChild(bgDiv);
      this.setNodeID(
        bgDiv,
        "background"
        /* Background */
      );
      bgDiv.addEventListener("mouseover", () => this.setHoverText(this.parentHoverText));
      bgDiv.addEventListener("mouseout", () => this.setHoverText(""));
      const btnLink = document.createElement("a");
      btnLink.classList.add("norm2");
      bgDiv.appendChild(btnLink);
      const btnImg = document.createElement("img");
      btnImg.src = buttonImageURL;
      btnLink.appendChild(btnImg);
      this.setNodeID(
        btnImg,
        "button-image"
        /* Button_Image */
      );
      const contextMenu = document.createElement("div");
      contextMenu.classList.add("cls-settings-menu");
      contextMenu.style.zIndex = "30";
      this.parent.appendChild(contextMenu);
      this.setNodeID(
        contextMenu,
        "settings"
        /* Settings */
      );
      const contextMenuBoxesContainer = document.createElement("div");
      contextMenuBoxesContainer.classList.add("cls-horizontal-box");
      contextMenu.appendChild(contextMenuBoxesContainer);
      const leftBox = document.createElement("div");
      leftBox.classList.add("cls-settings-menu-box");
      leftBox.style.display = "none";
      contextMenuBoxesContainer.appendChild(leftBox);
      this.setNodeID(
        leftBox,
        "settings-left"
        /* Settings_Left */
      );
      const centerBox = document.createElement("div");
      centerBox.classList.add("cls-settings-menu-box");
      centerBox.style.display = "none";
      contextMenuBoxesContainer.appendChild(centerBox);
      this.setNodeID(
        centerBox,
        "settings-center"
        /* Settings_Center */
      );
      const rightBox = document.createElement("div");
      rightBox.classList.add("cls-settings-menu-box");
      rightBox.style.display = "none";
      contextMenuBoxesContainer.appendChild(rightBox);
      this.setNodeID(
        rightBox,
        "settings-right"
        /* Settings_Right */
      );
      document.addEventListener("contextmenu", (event2) => {
        const element = event2.target;
        if (!element.id.startsWith(this.prefix)) return;
        event2.stopImmediatePropagation();
        event2.preventDefault();
        this.isSettingsMenuOpen = !this.isSettingsMenuOpen;
        if (this.isSettingsMenuOpen) {
          this.openContextMenu();
        } else {
          this.closeContextMenu();
        }
      });
      document.addEventListener("click", (event2) => {
        let elmnt = event2.target;
        if (!elmnt.id) {
          while (!elmnt.id) {
            elmnt = elmnt.parentNode;
            if (!elmnt) break;
          }
        }
        if (!elmnt) return;
        if (elmnt.id.startsWith(this.prefix) || elmnt.id === "overDiv") return;
        this.closeContextMenu();
      });
    }
    setNodeID(node, id) {
      node.id = `${this.prefix}_${id}`;
    }
    getNodeByID(id) {
      const fullID = `${this.prefix}_${id}`;
      const node = getCurrentDocument().getElementById(fullID) ?? this.parent.querySelector(`#${fullID}`);
      if (!node) {
        if (id !== "co-selector") console.log(`[DeveloperJose] Node with ID ${fullID} not found.`);
        return null;
      }
      const isSettingsSubMenu = id === "settings-left" || id === "settings-center" || id === "settings-right";
      const isHidden = node.style.display === "none";
      const hasChildren = node.children.length > 0;
      if (isSettingsSubMenu && isHidden && hasChildren) {
        node.style.display = "flex";
      }
      return node;
    }
    /**
     * Adds the custom menu to the AWBW page.
     */
    addToAWBWPage(div, prepend = false) {
      if (!div) {
        console.error("[DeveloperJose] Parent div is null, cannot add custom menu to the page.");
        return;
      }
      if (!prepend) {
        div.appendChild(this.parent);
        this.parent.style.borderLeft = "none";
        return;
      }
      div.prepend(this.parent);
      this.parent.style.borderRight = "none";
    }
    hasSettings() {
      var _a, _b, _c;
      const hasLeftMenu = ((_a = this.getNodeByID(
        "settings-left"
        /* Settings_Left */
      )) == null ? void 0 : _a.style.display) !== "none";
      const hasCenterMenu = ((_b = this.getNodeByID(
        "settings-center"
        /* Settings_Center */
      )) == null ? void 0 : _b.style.display) !== "none";
      const hasRightMenu = ((_c = this.getNodeByID(
        "settings-right"
        /* Settings_Right */
      )) == null ? void 0 : _c.style.display) !== "none";
      return hasLeftMenu || hasCenterMenu || hasRightMenu;
    }
    getGroup(groupName) {
      return this.groups.get(groupName);
    }
    /**
     * Changes the hover text of the main button.
     * @param text - The text to be displayed when hovering over the button.
     * @param replaceParent - Whether to replace the current hover text for the main button or not.
     */
    setHoverText(text, replaceParent = false) {
      const hoverSpan = this.getNodeByID(
        "hover"
        /* Hover */
      );
      if (!hoverSpan) return;
      if (replaceParent) this.parentHoverText = text;
      if (this.isUpdateAvailable) text += " (New Update Available!)";
      hoverSpan.innerText = text;
      hoverSpan.style.display = text === "" ? "none" : "block";
    }
    /**
     * Sets the progress of the UI by coloring the background of the main button.
     * @param progress - A number between 0 and 100 representing the percentage of the progress bar to fill.
     */
    setProgress(progress) {
      const bgDiv = this.getNodeByID(
        "background"
        /* Background */
      );
      if (!bgDiv) return;
      if (progress <= 0 || progress >= 100) {
        bgDiv.style.backgroundImage = "";
        return;
      }
      bgDiv.style.backgroundImage = "linear-gradient(to right, #ffffff " + String(progress) + "% , #888888 0%)";
    }
    /**
     * Sets the image of the main button.
     * @param imageURL - The URL of the image to be used on the button.
     */
    setImage(imageURL) {
      const btnImg = this.getNodeByID(
        "button-image"
        /* Button_Image */
      );
      btnImg.src = imageURL;
    }
    /**
     * Adds an event listener to the main button.
     * @param type - The type of event to listen for.
     * @param listener - The function to be called when the event is triggered.
     */
    addEventListener(type, listener, options = false) {
      const div = this.getNodeByID(
        "background"
        /* Background */
      );
      div == null ? void 0 : div.addEventListener(type, listener, options);
    }
    /**
     * Opens the context (right-click) menu.
     */
    openContextMenu() {
      var _a;
      const contextMenu = this.getNodeByID(
        "settings"
        /* Settings */
      );
      if (!contextMenu) return;
      const hasVersion = ((_a = this.getNodeByID(
        "version"
        /* Version */
      )) == null ? void 0 : _a.style.display) !== "none";
      if (!this.hasSettings() && !hasVersion) return;
      contextMenu.style.display = "flex";
      this.isSettingsMenuOpen = true;
    }
    /**
     * Closes the context (right-click) menu.
     */
    closeContextMenu() {
      const contextMenu = this.getNodeByID(
        "settings"
        /* Settings */
      );
      if (!contextMenu) return;
      contextMenu.style.display = "none";
      this.isSettingsMenuOpen = false;
      const overDiv = document.querySelector("#overDiv");
      const hasCOSelector = this.getNodeByID(
        "co-selector"
        /* CO_Selector */
      ) !== null;
      const isGamePageAndActive = getCurrentPageType() === PageType.ActiveGame;
      if (overDiv && hasCOSelector && isGamePageAndActive) {
        overDiv.style.visibility = "hidden";
      }
    }
    /**
     * Adds an input slider to the context menu.
     * @param name - The name of the slider.
     * @param min - The minimum value of the slider.
     * @param max - The maximum value of the slider.
     * @param step - The step value of the slider.
     * @param hoverText - The text to be displayed when hovering over the slider.
     * @param position - The position of the slider in the context menu.
     * @returns - The slider element.
     */
    addSlider(name, min, max, step, hoverText = "", position2 = "settings-center") {
      const submenu = this.getNodeByID(position2);
      if (!submenu) return;
      const sliderBox = document.createElement("div");
      sliderBox.classList.add("cls-vertical-box");
      sliderBox.classList.add("cls-group-box");
      submenu == null ? void 0 : submenu.appendChild(sliderBox);
      const label = document.createElement("label");
      sliderBox == null ? void 0 : sliderBox.appendChild(label);
      const slider = document.createElement("input");
      slider.id = `${this.prefix}-${sanitize(name)}`;
      slider.type = "range";
      slider.min = String(min);
      slider.max = String(max);
      slider.step = String(step);
      this.inputElements.push(slider);
      slider.addEventListener("input", (_e) => {
        let displayValue = slider.value;
        if (max === 1) displayValue = Math.round(parseFloat(displayValue) * 100) + "%";
        label.innerText = `${name}: ${displayValue}`;
      });
      sliderBox == null ? void 0 : sliderBox.appendChild(slider);
      slider.title = hoverText;
      slider.addEventListener("mouseover", () => this.setHoverText(hoverText));
      slider.addEventListener("mouseout", () => this.setHoverText(""));
      return slider;
    }
    addGroup(groupName, type = "cls-horizontal-box", position2 = "settings-center") {
      const submenu = this.getNodeByID(position2);
      if (!submenu) return;
      if (this.groups.has(groupName)) return this.groups.get(groupName);
      const groupBox = document.createElement("div");
      groupBox.classList.add("cls-vertical-box");
      groupBox.classList.add("cls-group-box");
      submenu == null ? void 0 : submenu.appendChild(groupBox);
      const groupLabel = document.createElement("label");
      groupLabel.innerText = groupName;
      groupBox == null ? void 0 : groupBox.appendChild(groupLabel);
      const group = document.createElement("div");
      group.id = `${this.prefix}-${sanitize(groupName)}`;
      group.classList.add(type);
      groupBox == null ? void 0 : groupBox.appendChild(group);
      this.groups.set(groupName, group);
      this.groupTypes.set(groupName, type);
      return group;
    }
    addRadioButton(name, groupName, hoverText = "") {
      return this.addInput(
        name,
        groupName,
        hoverText,
        "radio"
        /* Radio */
      );
    }
    addCheckbox(name, groupName, hoverText = "") {
      return this.addInput(
        name,
        groupName,
        hoverText,
        "checkbox"
        /* Checkbox */
      );
    }
    addButton(name, groupName, hoverText = "") {
      return this.addInput(
        name,
        groupName,
        hoverText,
        "button"
        /* Button */
      );
    }
    /**
     * Adds an input to the context menu in a specific group.
     * @param name - The name of the input.
     * @param groupName - The name of the group the input belongs to.
     * @param hoverText - The text to be displayed when hovering over the input.
     * @param type - The type of input to be added.
     * @returns - The input element.
     */
    addInput(name, groupName, hoverText = "", type) {
      const groupDiv = this.getGroup(groupName);
      const groupType = this.groupTypes.get(groupName);
      if (!groupDiv || !groupType) return;
      const inputBox = document.createElement("div");
      const otherType = groupType === "cls-horizontal-box" ? "cls-vertical-box" : "cls-horizontal-box";
      inputBox.classList.add(otherType);
      groupDiv.appendChild(inputBox);
      inputBox.title = hoverText;
      inputBox.addEventListener("mouseover", () => this.setHoverText(hoverText));
      inputBox.addEventListener("mouseout", () => this.setHoverText(""));
      let input;
      if (type === "button") {
        input = this.createButton(name, inputBox);
      } else {
        input = this.createInput(name, inputBox);
      }
      input.type = type;
      input.name = groupName;
      return input;
    }
    createButton(name, inputBox) {
      const input = document.createElement("button");
      input.innerText = name;
      inputBox.appendChild(input);
      this.buttonElements.push(input);
      return input;
    }
    createInput(name, inputBox) {
      const input = document.createElement("input");
      const label = document.createElement("label");
      label.appendChild(input);
      label.appendChild(document.createTextNode(name));
      inputBox.appendChild(label);
      this.inputElements.push(input);
      return input;
    }
    /**
     * Adds a special version label to the context menu.
     * @param version - The version to be displayed.
     */
    addVersion() {
      const version = versions.get(this.prefix);
      if (!version) return;
      const contextMenu = this.getNodeByID(
        "settings"
        /* Settings */
      );
      const versionDiv = document.createElement("label");
      versionDiv.innerText = `Version: ${version} (DeveloperJose Edition)`;
      contextMenu == null ? void 0 : contextMenu.appendChild(versionDiv);
      this.setNodeID(
        versionDiv,
        "version"
        /* Version */
      );
    }
    checkIfNewVersionAvailable() {
      const currentVersion = versions.get(this.prefix);
      const updateURL = updateURLs.get(this.prefix);
      const homepageURL = homepageURLs.get(this.prefix) || "";
      if (!currentVersion || !updateURL) return;
      checkIfUpdateIsAvailable(this.prefix).then((isUpdateAvailable) => {
        this.isUpdateAvailable = isUpdateAvailable;
        console.log("[DeveloperJose] Checking if a new version is available...", isUpdateAvailable);
        if (!isUpdateAvailable) return;
        const contextMenu = this.getNodeByID(
          "settings"
          /* Settings */
        );
        const versionDiv = document.createElement("a");
        versionDiv.id = this.prefix + "-update";
        versionDiv.href = homepageURL;
        versionDiv.target = "_blank";
        versionDiv.innerText = `(!) Update Available: Please click here to open the update page in a new tab. (!)`;
        contextMenu == null ? void 0 : contextMenu.append(versionDiv.cloneNode(true));
        if (this.hasSettings()) contextMenu == null ? void 0 : contextMenu.prepend(versionDiv);
      }).catch((error) => console.error(error));
    }
    addTable(name, rows, columns, groupName, hoverText = "") {
      const groupDiv = this.getGroup(groupName);
      if (!groupDiv) return;
      const table = document.createElement("table");
      table.classList.add("cls-settings-table");
      groupDiv.appendChild(table);
      table.title = hoverText;
      table.addEventListener("mouseover", () => this.setHoverText(hoverText));
      table.addEventListener("mouseout", () => this.setHoverText(""));
      const tableData = {
        table,
        rows,
        columns
      };
      this.tableMap.set(name, tableData);
      return table;
    }
    addItemToTable(name, item) {
      const tableData = this.tableMap.get(name);
      if (!tableData) return;
      const table = tableData.table;
      if (table.rows.length === 0) table.insertRow();
      const maxItemsPerRow = tableData.columns;
      const currentItemsInRow = table.rows[table.rows.length - 1].cells.length;
      if (currentItemsInRow >= maxItemsPerRow) table.insertRow();
      const currentRow = table.rows[table.rows.length - 1];
      const cell = currentRow.insertCell();
      cell.appendChild(item);
    }
    clearTable(name) {
      const tableData = this.tableMap.get(name);
      if (!tableData) return;
      const table = tableData.table;
      table.innerHTML = "";
    }
    /**
     * Calls the input event on all input elements in the menu.
     * Useful for updating the labels of all the inputs.
     */
    updateAllInputLabels() {
      const event2 = new Event("input");
      this.inputElements.forEach((input) => {
        input.dispatchEvent(event2);
      });
    }
    /**
     * Adds a CO selector to the context menu. Only one CO selector can be added to the menu.
     * @param groupName - The name of the group the CO selector should be added to.
     * @param hoverText - The text to be displayed when hovering over the CO selector.
     * @param onClickFn - The function to be called when a CO is selected from the selector.
     * @returns - The CO selector element.
     */
    addCOSelector(groupName, hoverText = "", onClickFn) {
      const groupDiv = this.getGroup(groupName);
      if (!groupDiv) return;
      const coSelector = document.createElement("a");
      coSelector.classList.add("game-tools-btn");
      coSelector.href = "javascript:void(0)";
      const imgCaret = this.createCOSelectorCaret();
      const imgCO = this.createCOPortraitImage("andy");
      coSelector.appendChild(imgCaret);
      coSelector.appendChild(imgCO);
      coSelector.title = hoverText;
      coSelector.addEventListener("mouseover", () => this.setHoverText(hoverText));
      coSelector.addEventListener("mouseout", () => this.setHoverText(""));
      this.setNodeID(
        coSelector,
        "co-selector"
        /* CO_Selector */
      );
      this.setNodeID(
        imgCO,
        "co-portrait"
        /* CO_Portrait */
      );
      groupDiv == null ? void 0 : groupDiv.appendChild(coSelector);
      const allCOs = getAllCONames(true).sort();
      let allColumnsHTML = "";
      for (let i = 0; i < 7; i++) {
        const startIDX = i * 4;
        const endIDX = startIDX + 4;
        const templateFn = (coName) => this.createCOSelectorItem(coName);
        const currentColumnHTML = allCOs.slice(startIDX, endIDX).map(templateFn).join("");
        allColumnsHTML += `<td><table>${currentColumnHTML}</table></td>`;
      }
      const selectorInnerHTML = `<table><tr>${allColumnsHTML}</tr></table>`;
      const selectorTitle = `<img src=terrain/ani/blankred.gif height=16 width=1 align=absmiddle>Select CO`;
      coSelector.onclick = () => {
        const ret = overlib(selectorInnerHTML, STICKY, CAPTION, selectorTitle, OFFSETY, 25, OFFSETX, -322, CLOSECLICK);
        const overdiv = document.querySelector("#overDiv");
        if (overdiv) overdiv.style.zIndex = "1000";
        return ret;
      };
      addCOSelectorListener((coName) => this.onCOSelectorClick(coName));
      addCOSelectorListener(onClickFn);
      return coSelector;
    }
    createCOSelectorItem(coName) {
      const location = "javascript:void(0)";
      const internalName = coName.toLowerCase().replaceAll(" ", "");
      const coPrefix = getCOImagePrefix();
      const imgSrc = `terrain/ani/${coPrefix}${internalName}.png?v=1`;
      const onClickFn = `awbw_music_player.notifyCOSelectorListeners('${internalName}');`;
      return `<tr><td class=borderwhite><img class=co_portrait src=${imgSrc}></td><td class=borderwhite align=center valign=center><span class=small_text><a onclick="${onClickFn}" href=${location}>${coName}</a></b></span></td></tr>`;
    }
    createCOSelectorCaret() {
      const imgCaret = document.createElement("img");
      imgCaret.classList.add("co_caret");
      imgCaret.src = "terrain/co_down_caret.gif";
      imgCaret.style.zIndex = "300";
      return imgCaret;
    }
    createCOPortraitImage(coName) {
      const imgCO = document.createElement("img");
      imgCO.classList.add("co_portrait");
      const coPrefix = getCOImagePrefix();
      imgCO.src = `terrain/ani/${coPrefix}${coName}.png?v=1`;
      if (!getAllCONames().includes(coName)) {
        imgCO.src = `terrain/${coName}`;
      }
      return imgCO;
    }
    createCOPortraitImageWithText(coName, text) {
      const div = document.createElement("div");
      div.classList.add("cls-vertical-box");
      const coImg = this.createCOPortraitImage(coName);
      div.appendChild(coImg);
      const coLabel = document.createElement("label");
      coLabel.textContent = text;
      div.appendChild(coLabel);
      return div;
    }
    onCOSelectorClick(coName) {
      const overDiv = document.querySelector("#overDiv");
      overDiv.style.visibility = "hidden";
      const imgCO = this.getNodeByID(
        "co-portrait"
        /* CO_Portrait */
      );
      const coPrefix = getCOImagePrefix();
      imgCO.src = `terrain/ani/${coPrefix}${coName}.png?v=1`;
    }
  }
  const coSelectorListeners = [];
  function addCOSelectorListener(listener) {
    coSelectorListeners.push(listener);
  }
  function notifyCOSelectorListeners(coName) {
    coSelectorListeners.forEach((listener) => listener(coName));
  }
  function getMenu() {
    var _a;
    const doc = getCurrentDocument();
    switch (getCurrentPageType()) {
      case PageType.Maintenance:
        return doc.querySelector("#main");
      case PageType.MapEditor:
        return doc.querySelector("#replay-misc-controls");
      case PageType.MovePlanner:
        return doc.querySelector("#map-controls-container");
      case PageType.ActiveGame:
        return (_a = doc.querySelector("#game-map-menu")) == null ? void 0 : _a.parentNode;
      // case PageType.LiveQueue:
      // case PageType.MainPage:
      default:
        return doc.querySelector("#nav-options");
    }
  }
  function onMusicBtnClick(_event) {
    musicSettings.isPlaying = !musicSettings.isPlaying;
  }
  function onSettingsChange$1(key, _value, isFirstLoad) {
    if (isFirstLoad) {
      if (volumeSlider) volumeSlider.value = musicSettings.volume.toString();
      if (sfxVolumeSlider) sfxVolumeSlider.value = musicSettings.sfxVolume.toString();
      if (uiVolumeSlider) uiVolumeSlider.value = musicSettings.uiVolume.toString();
      if (daySlider) daySlider.value = musicSettings.alternateThemeDay.toString();
      const selectedGameTypeRadio = gameTypeRadioMap.get(musicSettings.gameType);
      if (selectedGameTypeRadio) selectedGameTypeRadio.checked = true;
      const selectedRandomTypeRadio = randomRadioMap.get(musicSettings.randomThemesType);
      if (selectedRandomTypeRadio) selectedRandomTypeRadio.checked = true;
      captProgressBox.checked = musicSettings.captureProgressSFX;
      pipeSeamBox.checked = musicSettings.pipeSeamSFX;
      restartThemesBox.checked = musicSettings.restartThemes;
      autoplayPagesBox.checked = musicSettings.autoplayOnOtherPages;
      loopToggle.checked = musicSettings.loopRandomSongsUntilTurnChange;
      uiSFXPagesBox.checked = musicSettings.sfxOnOtherPages;
      alternateThemesBox.checked = musicSettings.alternateThemes;
      musicPlayerUI.updateAllInputLabels();
    }
    if (key === SettingsKey.ALL || key === SettingsKey.ADD_OVERRIDE || key === SettingsKey.REMOVE_OVERRIDE) {
      clearAndRepopulateOverrideList();
      if (musicSettings.overrideList.size === 0) {
        const noOverrides = musicPlayerUI.createCOPortraitImageWithText("followlist.gif", "No overrides set yet...");
        musicPlayerUI.addItemToTable("Overrides", noOverrides);
      }
    }
    if (key === SettingsKey.ALL || key === SettingsKey.ADD_EXCLUDED || key === SettingsKey.REMOVE_EXCLUDED) {
      clearAndRepopulateExcludedList();
      if (musicSettings.excludedRandomThemes.size === 0) {
        const noExcluded = musicPlayerUI.createCOPortraitImageWithText("followlist.gif", "No themes excluded yet...");
        musicPlayerUI.addItemToTable("Excluded Random Themes", noExcluded);
      }
    }
    const canUpdateDaySlider = (daySlider == null ? void 0 : daySlider.parentElement) && getCurrentPageType() === PageType.ActiveGame;
    if (canUpdateDaySlider) daySlider.parentElement.style.display = alternateThemesBox.checked ? "flex" : "none";
    if (shuffleBtn) shuffleBtn.disabled = musicSettings.randomThemesType === RandomThemeType.NONE;
    const currentSounds = getCurrentPageType() === PageType.MovePlanner ? "Sound Effects" : "Tunes";
    if (musicSettings.isPlaying) {
      musicPlayerUI.setHoverText(`Stop ${currentSounds}`, true);
      musicPlayerUI.setImage(PLAYING_IMG_URL);
    } else {
      musicPlayerUI.setHoverText(`Play ${currentSounds}`, true);
      musicPlayerUI.setImage(NEUTRAL_IMG_URL);
    }
  }
  const parseInputFloat = (event2) => parseFloat(event2.target.value);
  const parseInputInt = (event2) => parseInt(event2.target.value);
  const musicPlayerUI = new CustomMenuSettingsUI(ScriptName.MusicPlayer, NEUTRAL_IMG_URL, "Play Tunes");
  var Description = /* @__PURE__ */ ((Description2) => {
    Description2["Volume"] = "Adjust the volume of the CO theme music, power activations, and power themes.";
    Description2["SFX_Volume"] = "Adjust the volume of the unit movement, tag swap, captures, and other unit sounds.";
    Description2["UI_Volume"] = "Adjust the volume of the UI sound effects like moving your cursor, opening menus, and selecting units.";
    Description2["AW1"] = "Play the Advance Wars 1 soundtrack. There are no power themes just like the cartridge!";
    Description2["AW2"] = "Play the Advance Wars 2 soundtrack. Very classy like Md Tanks.";
    Description2["DS"] = "Play the Advance Wars: Dual Strike soundtrack. A bit better quality than with the DS speakers though.";
    Description2["RBC"] = "Play the Advance Wars: Re-Boot Camp soundtrack. Even the new power themes are here now!";
    Description2["No_Random"] = "Play the music depending on who the current CO is.";
    Description2["All_Random"] = "Play random music every turn from all soundtracks.";
    Description2["Current_Random"] = "Play random music every turn from the current soundtrack.";
    Description2["Shuffle"] = "Changes the current theme to a new random one.";
    Description2["SFX_Pages"] = "Play sound effects on other pages like 'Your Games', 'Profile', or during maintenance.";
    Description2["Capture_Progress"] = "Play a sound effect when a unit makes progress capturing a property.";
    Description2["Pipe_Seam_SFX"] = "Play a sound effect when a pipe seam is attacked.";
    Description2["Autoplay_Pages"] = "Autoplay music on other pages like 'Your Games', 'Profile', or during maintenance.";
    Description2["Restart_Themes"] = "Restart themes at the beginning of each turn (including replays). If disabled, themes will continue from where they left off previously.";
    Description2["Random_Loop_Toggle"] = "Loop random songs until a turn change happens. If disabled, when a random song ends a new random song will be chosen immediately even if the turn hasn't changed yet.";
    Description2["Alternate_Themes"] = "Play alternate themes like the Re-Boot Camp factory themes after a certain day. Enable this to be able to select what day alternate themes start.";
    Description2["Alternate_Day"] = "After what day should alternate themes like the Re-Boot Camp factory themes start playing? Can you find all the hidden themes?";
    Description2["Add_Override"] = "Adds an override for a specific CO so it always plays a specific soundtrack or to exclude it when playing random themes.";
    Description2["Override_Radio"] = "Only play songs from ";
    Description2["Remove_Override"] = "Removes the override for this specific CO.";
    Description2["Add_Excluded"] = "Add an override for a specific CO to exclude their themes when playing random themes.";
    return Description2;
  })(Description || {});
  const LEFT = NodeID.Settings_Left;
  const volumeSlider = musicPlayerUI.addSlider("Music Volume", 0, 1, 5e-3, "Adjust the volume of the CO theme music, power activations, and power themes.", LEFT);
  const sfxVolumeSlider = musicPlayerUI.addSlider("SFX Volume", 0, 1, 5e-3, "Adjust the volume of the unit movement, tag swap, captures, and other unit sounds.", LEFT);
  const uiVolumeSlider = musicPlayerUI.addSlider("UI Volume", 0, 1, 5e-3, "Adjust the volume of the UI sound effects like moving your cursor, opening menus, and selecting units.", LEFT);
  const soundtrackGroupID = "Soundtrack";
  musicPlayerUI.addGroup(soundtrackGroupID, GroupType.Horizontal, LEFT);
  const gameTypeRadioMap = /* @__PURE__ */ new Map();
  for (const gameType of Object.values(GameType)) {
    const description = Description[gameType];
    const radio = musicPlayerUI.addRadioButton(gameType, soundtrackGroupID, description);
    gameTypeRadioMap.set(gameType, radio);
  }
  const randomGroupID = "Random Themes";
  musicPlayerUI.addGroup(randomGroupID, GroupType.Horizontal, LEFT);
  const radioNormal = musicPlayerUI.addRadioButton(
    "Off",
    randomGroupID,
    "Play the music depending on who the current CO is."
    /* No_Random */
  );
  const radioAllRandom = musicPlayerUI.addRadioButton(
    "All Soundtracks",
    randomGroupID,
    "Play random music every turn from all soundtracks."
    /* All_Random */
  );
  const radioCurrentRandom = musicPlayerUI.addRadioButton(
    "Current Soundtrack",
    randomGroupID,
    "Play random music every turn from the current soundtrack."
    /* Current_Random */
  );
  const randomRadioMap = /* @__PURE__ */ new Map([
    [RandomThemeType.NONE, radioNormal],
    [RandomThemeType.ALL_THEMES, radioAllRandom],
    [RandomThemeType.CURRENT_SOUNDTRACK, radioCurrentRandom]
  ]);
  const shuffleBtn = musicPlayerUI.addButton(
    "Shuffle",
    randomGroupID,
    "Changes the current theme to a new random one."
    /* Shuffle */
  );
  const sfxGroupID = "Sound Effect (SFX) Options";
  musicPlayerUI.addGroup(sfxGroupID, GroupType.Vertical, LEFT);
  const uiSFXPagesBox = musicPlayerUI.addCheckbox(
    "Play Sound Effects Outside Of Game Pages",
    sfxGroupID,
    "Play sound effects on other pages like 'Your Games', 'Profile', or during maintenance."
    /* SFX_Pages */
  );
  const captProgressBox = musicPlayerUI.addCheckbox(
    "Capture Progress SFX",
    sfxGroupID,
    "Play a sound effect when a unit makes progress capturing a property."
    /* Capture_Progress */
  );
  const pipeSeamBox = musicPlayerUI.addCheckbox(
    "Pipe Seam Attack SFX",
    sfxGroupID,
    "Play a sound effect when a pipe seam is attacked."
    /* Pipe_Seam_SFX */
  );
  const musicGroupID = "Music Options";
  musicPlayerUI.addGroup(musicGroupID, GroupType.Vertical, LEFT);
  const autoplayPagesBox = musicPlayerUI.addCheckbox(
    "Autoplay Music Outside Of Game Pages",
    musicGroupID,
    "Autoplay music on other pages like 'Your Games', 'Profile', or during maintenance."
    /* Autoplay_Pages */
  );
  const restartThemesBox = musicPlayerUI.addCheckbox(
    "Restart Themes Every Turn",
    musicGroupID,
    "Restart themes at the beginning of each turn (including replays). If disabled, themes will continue from where they left off previously."
    /* Restart_Themes */
  );
  const loopToggle = musicPlayerUI.addCheckbox(
    "Loop Random Songs Until Turn Changes",
    musicGroupID,
    "Loop random songs until a turn change happens. If disabled, when a random song ends a new random song will be chosen immediately even if the turn hasn't changed yet."
    /* Random_Loop_Toggle */
  );
  const alternateThemesBox = musicPlayerUI.addCheckbox(
    "Alternate Themes",
    musicGroupID,
    "Play alternate themes like the Re-Boot Camp factory themes after a certain day. Enable this to be able to select what day alternate themes start."
    /* Alternate_Themes */
  );
  const daySlider = musicPlayerUI.addSlider("Alternate Themes Start On Day", 0, 30, 1, "After what day should alternate themes like the Re-Boot Camp factory themes start playing? Can you find all the hidden themes?", LEFT);
  const RIGHT = NodeID.Settings_Right;
  const addOverrideGroupID = "Override Themes";
  musicPlayerUI.addGroup(addOverrideGroupID, GroupType.Horizontal, RIGHT);
  let currentSelectedCO = "andy";
  function onCOSelectorClick(coName) {
    currentSelectedCO = coName;
  }
  musicPlayerUI.addCOSelector(addOverrideGroupID, "Adds an override for a specific CO so it always plays a specific soundtrack or to exclude it when playing random themes.", onCOSelectorClick);
  const overrideGameTypeRadioMap = /* @__PURE__ */ new Map();
  for (const gameType of Object.values(GameType)) {
    const radio = musicPlayerUI.addRadioButton(gameType, addOverrideGroupID, "Only play songs from " + gameType);
    overrideGameTypeRadioMap.set(gameType, radio);
    radio.checked = true;
  }
  const excludeRadio = musicPlayerUI.addRadioButton(
    "Exclude Random",
    addOverrideGroupID,
    "Add an override for a specific CO to exclude their themes when playing random themes."
    /* Add_Excluded */
  );
  const overrideBtn = musicPlayerUI.addButton(
    "Add",
    addOverrideGroupID,
    "Adds an override for a specific CO so it always plays a specific soundtrack or to exclude it when playing random themes."
    /* Add_Override */
  );
  const overrideListGroupID = "Current Overrides (Click to Remove)";
  musicPlayerUI.addGroup(overrideListGroupID, GroupType.Horizontal, RIGHT);
  const overrideDivMap = /* @__PURE__ */ new Map();
  const tableRows = 4;
  const tableCols = 7;
  musicPlayerUI.addTable(
    "Overrides",
    tableRows,
    tableCols,
    overrideListGroupID,
    "Removes the override for this specific CO."
    /* Remove_Override */
  );
  function addOverrideDisplayDiv(coName, gameType) {
    const displayDiv = musicPlayerUI.createCOPortraitImageWithText(coName, gameType);
    displayDiv.addEventListener("click", (_event) => {
      musicSettings.removeOverride(coName);
    });
    overrideDivMap.set(coName, displayDiv);
    musicPlayerUI.addItemToTable("Overrides", displayDiv);
    return displayDiv;
  }
  function clearAndRepopulateOverrideList() {
    overrideDivMap.forEach((div) => div.remove());
    overrideDivMap.clear();
    musicPlayerUI.clearTable(
      "Overrides"
      /* Override_Table */
    );
    for (const [coName, gameType] of musicSettings.overrideList) {
      addOverrideDisplayDiv(coName, gameType);
    }
  }
  const excludedListGroupID = "Themes Excluded From Randomizer (Click to Remove)";
  musicPlayerUI.addGroup(excludedListGroupID, GroupType.Horizontal, RIGHT);
  const excludedListDivMap = /* @__PURE__ */ new Map();
  musicPlayerUI.addTable(
    "Excluded Random Themes",
    tableRows,
    tableCols,
    excludedListGroupID,
    "Removes the override for this specific CO."
    /* Remove_Override */
  );
  function addExcludedDisplayDiv(coName) {
    const displayDiv = musicPlayerUI.createCOPortraitImageWithText(coName, "");
    displayDiv.addEventListener("click", (_event) => {
      musicSettings.removeExcludedRandomTheme(coName);
    });
    excludedListDivMap.set(coName, displayDiv);
    musicPlayerUI.addItemToTable("Excluded Random Themes", displayDiv);
    return displayDiv;
  }
  function clearAndRepopulateExcludedList() {
    excludedListDivMap.forEach((div) => div.remove());
    excludedListDivMap.clear();
    musicPlayerUI.clearTable(
      "Excluded Random Themes"
      /* Excluded_Table */
    );
    for (const coName of musicSettings.excludedRandomThemes) addExcludedDisplayDiv(coName);
  }
  musicPlayerUI.addVersion();
  function initializeMusicPlayerUI() {
    musicPlayerUI.setProgress(100);
    let prepend = false;
    switch (getCurrentPageType()) {
      // case PageType.LiveQueue:
      //   return;
      case PageType.ActiveGame:
        break;
      case PageType.MapEditor:
        musicPlayerUI.parent.style.borderTop = "none";
        break;
      case PageType.Maintenance:
        musicPlayerUI.parent.style.borderLeft = "";
        break;
      default:
        musicPlayerUI.parent.style.border = "none";
        musicPlayerUI.parent.style.backgroundColor = "#0000";
        musicPlayerUI.setProgress(-1);
        prepend = true;
        break;
    }
    musicPlayerUI.addToAWBWPage(getMenu(), prepend);
    addMusicUIListeners();
  }
  function addMusicUIListeners() {
    musicPlayerUI.addEventListener("click", onMusicBtnClick);
    addSettingsChangeListener(onSettingsChange$1);
    volumeSlider == null ? void 0 : volumeSlider.addEventListener("input", (event2) => musicSettings.volume = parseInputFloat(event2));
    sfxVolumeSlider == null ? void 0 : sfxVolumeSlider.addEventListener("input", (event2) => musicSettings.sfxVolume = parseInputFloat(event2));
    uiVolumeSlider == null ? void 0 : uiVolumeSlider.addEventListener("input", (event2) => musicSettings.uiVolume = parseInputFloat(event2));
    radioNormal.addEventListener("click", (_e) => musicSettings.randomThemesType = RandomThemeType.NONE);
    radioAllRandom.addEventListener("click", (_e) => musicSettings.randomThemesType = RandomThemeType.ALL_THEMES);
    radioCurrentRandom.addEventListener(
      "click",
      (_e) => musicSettings.randomThemesType = RandomThemeType.CURRENT_SOUNDTRACK
    );
    for (const gameType of Object.values(GameType)) {
      const radio = gameTypeRadioMap.get(gameType);
      radio == null ? void 0 : radio.addEventListener("click", (_e) => musicSettings.gameType = gameType);
    }
    shuffleBtn.addEventListener("click", (_e) => musicSettings.randomizeCO());
    captProgressBox.addEventListener("click", (_e) => musicSettings.captureProgressSFX = captProgressBox.checked);
    pipeSeamBox.addEventListener("click", (_e) => musicSettings.pipeSeamSFX = pipeSeamBox.checked);
    restartThemesBox.addEventListener("click", (_e) => musicSettings.restartThemes = restartThemesBox.checked);
    autoplayPagesBox.addEventListener("click", (_e) => musicSettings.autoplayOnOtherPages = autoplayPagesBox.checked);
    loopToggle.addEventListener("click", (_e) => musicSettings.loopRandomSongsUntilTurnChange = loopToggle.checked);
    uiSFXPagesBox.addEventListener("click", (_e) => musicSettings.sfxOnOtherPages = uiSFXPagesBox.checked);
    alternateThemesBox.addEventListener("click", (_e) => musicSettings.alternateThemes = alternateThemesBox.checked);
    daySlider == null ? void 0 : daySlider.addEventListener("input", (event2) => musicSettings.alternateThemeDay = parseInputInt(event2));
    overrideBtn.addEventListener("click", (_e) => {
      if (excludeRadio.checked) {
        musicSettings.addExcludedRandomTheme(currentSelectedCO);
        return;
      }
      let currentGameType;
      for (const [gameType, radio] of overrideGameTypeRadioMap) {
        if (radio.checked) currentGameType = gameType;
      }
      if (!currentGameType) return;
      musicSettings.addOverride(currentSelectedCO, currentGameType);
    });
  }
  addMusicUIListeners();
  function getQueryTurnFn() {
    return typeof queryTurn !== "undefined" ? queryTurn : null;
  }
  function getShowEventScreenFn() {
    return typeof showEventScreen !== "undefined" ? showEventScreen : null;
  }
  function getShowEndGameScreenFn() {
    return typeof showEndGameScreen !== "undefined" ? showEndGameScreen : null;
  }
  function getOpenMenuFn() {
    return typeof openMenu !== "undefined" ? openMenu : null;
  }
  function getCloseMenuFn() {
    return typeof closeMenu !== "undefined" ? closeMenu : null;
  }
  function getCreateDamageSquaresFn() {
    return typeof createDamageSquares !== "undefined" ? createDamageSquares : null;
  }
  function getUnitClickFn() {
    return typeof unitClickHandler !== "undefined" ? unitClickHandler : null;
  }
  function getWaitFn() {
    return typeof waitUnit !== "undefined" ? waitUnit : null;
  }
  function getAnimUnitFn() {
    return typeof animUnit !== "undefined" ? animUnit : null;
  }
  function getAnimExplosionFn() {
    return typeof animExplosion !== "undefined" ? animExplosion : null;
  }
  function getFogFn() {
    return typeof updateAirUnitFogOnMove !== "undefined" ? updateAirUnitFogOnMove : null;
  }
  function getFireFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Fire : null;
  }
  function getAttackSeamFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.AttackSeam : null;
  }
  function getMoveFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Move : null;
  }
  function getCaptFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Capt : null;
  }
  function getBuildFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Build : null;
  }
  function getLoadFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Load : null;
  }
  function getUnloadFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Unload : null;
  }
  function getSupplyFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Supply : null;
  }
  function getRepairFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Repair : null;
  }
  function getHideFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Hide : null;
  }
  function getUnhideFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Unhide : null;
  }
  function getJoinFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Join : null;
  }
  function getLaunchFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Launch : null;
  }
  function getNextTurnFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.NextTurn : null;
  }
  function getEliminationFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Elimination : null;
  }
  function getPowerFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Power : null;
  }
  function getGameOverFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.GameOver : null;
  }
  function getResignFn() {
    return typeof actionHandlers !== "undefined" ? actionHandlers.Resign : null;
  }
  let db = null;
  const dbName = "awbw_music_player";
  const dbVersion = 1;
  const urlQueue$1 = /* @__PURE__ */ new Set();
  const replacementListeners = /* @__PURE__ */ new Set();
  function addDatabaseReplacementListener(fn) {
    replacementListeners.add(fn);
  }
  function openDB() {
    const request = indexedDB.open(dbName, dbVersion);
    return new Promise((resolve, reject) => {
      request.onerror = (event2) => reject(event2);
      request.onupgradeneeded = (event2) => {
        if (!event2.target) return reject("No target for database upgrade.");
        const newDB = event2.target.result;
        newDB.createObjectStore("music");
      };
      request.onsuccess = (event2) => {
        if (!event2.target) return reject("No target for database success.");
        db = event2.target.result;
        db.onerror = (event22) => {
          reject(`Error accessing database: ${event22}`);
        };
        resolve();
      };
    });
  }
  function loadMusicFromDB(srcURL) {
    if (!srcURL || srcURL === "") return Promise.reject("Invalid URL.");
    if (urlQueue$1.has(srcURL)) return Promise.reject("URL is already queued for storage.");
    urlQueue$1.add(srcURL);
    return new Promise((resolve, reject) => {
      if (!db) return reject("Database is not open.");
      const transaction = db.transaction("music", "readonly");
      const store = transaction.objectStore("music");
      const request = store.get(srcURL);
      request.onsuccess = (event2) => {
        urlQueue$1.delete(srcURL);
        const blob = event2.target.result;
        if (!blob) {
          return storeURLInDB(srcURL).then((blob2) => resolve(URL.createObjectURL(blob2))).catch((reason) => reject(reason));
        }
        const url = URL.createObjectURL(blob);
        resolve(url);
      };
      request.onerror = (event2) => {
        urlQueue$1.delete(srcURL);
        reject(event2);
      };
    });
  }
  function storeBlobInDB(url, blob) {
    return new Promise((resolve, reject) => {
      if (!db) return reject("Database not open.");
      if (!url || url === "") return reject("Invalid URL.");
      const transaction = db.transaction("music", "readwrite");
      const store = transaction.objectStore("music");
      const request = store.put(blob, url);
      request.onsuccess = () => {
        resolve(blob);
        replacementListeners.forEach((fn) => fn(url));
      };
      request.onerror = (event2) => reject(event2);
    });
  }
  function storeURLInDB(url) {
    if (!db) return Promise.reject("Database not open.");
    if (!url || url === "") return Promise.reject("Invalid URL.");
    return fetch(url).then((response) => response.blob()).then((blob) => storeBlobInDB(url, blob));
  }
  function checkHashesInDB() {
    if (!db) return Promise.reject("Database not open.");
    return fetch(HASH_JSON_URL).then((response) => response.json()).then((hashes) => compareHashesAndReplaceIfNeeded(hashes));
  }
  function getBlobMD5(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (event2) => {
        var _a;
        if (!((_a = event2 == null ? void 0 : event2.target) == null ? void 0 : _a.result)) return reject("FileReader did not load the blob.");
        const md5 = SparkMD52.ArrayBuffer.hash(event2.target.result);
        resolve(md5);
      };
      reader.onerror = (event2) => reject(event2);
      reader.readAsArrayBuffer(blob);
    });
  }
  function compareHashesAndReplaceIfNeeded(hashesJson) {
    return new Promise((resolve, reject) => {
      if (!db) return reject("Database not open.");
      if (!hashesJson) return reject("No hashes found in server.");
      const transaction = db.transaction("music", "readonly");
      const store = transaction.objectStore("music");
      const request = store.openCursor();
      request.onerror = (event2) => reject(event2);
      request.onsuccess = (event2) => {
        const cursor = event2.target.result;
        if (!cursor) return resolve();
        const url = cursor.key;
        const blob = cursor.value;
        const serverHash = hashesJson[url];
        cursor.continue();
        if (!serverHash) {
          logDebug("No hash found in server for", url);
          return;
        }
        getBlobMD5(blob).then((hash) => {
          if (hash === serverHash) return;
          return storeURLInDB(url);
        }).catch((reason) => logError(`Error storing new version of ${url} in database: ${reason}`));
      };
    });
  }
  const audioMap = /* @__PURE__ */ new Map();
  const audioIDMap = /* @__PURE__ */ new Map();
  function playOneShotURL(srcURL, volume) {
    if (!musicSettings.isPlaying) return;
    const soundInstance = new Audio(srcURL);
    soundInstance.currentTime = 0;
    soundInstance.volume = volume;
    soundInstance.play();
  }
  function getVolumeForURL(url) {
    if (url.startsWith("blob:") || !url.startsWith("https://")) {
      logError("Blob URL when trying to get volume for", url);
      return musicSettings.volume;
    }
    if (url.includes("sfx")) {
      if (url.includes("ui")) return musicSettings.uiVolume;
      if (url.includes("power") && !url.includes("available")) return musicSettings.volume;
      return musicSettings.sfxVolume;
    }
    return musicSettings.volume;
  }
  const urlQueue = /* @__PURE__ */ new Set();
  const promiseMap = /* @__PURE__ */ new Map();
  function createNewAudio(srcURL, cacheURL) {
    const audioInMap = audioMap.get(srcURL);
    if (audioInMap) {
      logError("Race Condition! Please report this bug!", srcURL);
      return audioInMap;
    }
    const audio = new Howl({
      src: [cacheURL],
      format: ["ogg"],
      volume: getVolumeForURL(srcURL),
      // Redundant event listeners to ensure the audio is always at the correct volume
      onplay: (_id2) => audio.volume(getVolumeForURL(srcURL)),
      onload: (_id2) => audio.volume(getVolumeForURL(srcURL)),
      onseek: (_id2) => audio.volume(getVolumeForURL(srcURL)),
      onpause: (_id2) => audio.volume(getVolumeForURL(srcURL)),
      onloaderror: (_id2, error) => logError("Error loading audio:", srcURL, error),
      onplayerror: (_id2, error) => logError("Error playing audio:", srcURL, error)
    });
    audioMap.set(srcURL, audio);
    return audio;
  }
  function preloadAllCommonAudio(afterPreloadFunction) {
    const audioList = getCurrentThemeURLs();
    audioList.add(getSoundEffectURL(GameSFX.uiCursorMove));
    audioList.add(getSoundEffectURL(GameSFX.uiUnitSelect));
    logDebug("Pre-loading common audio", audioList);
    preloadAudioList(audioList, afterPreloadFunction);
  }
  function preloadAudioList(audioURLs, afterPreloadFunction = () => {
  }) {
    let numLoadedAudios = 0;
    const onAudioPreload = (action, url) => {
      numLoadedAudios++;
      const loadPercentage = numLoadedAudios / audioURLs.size * 100;
      musicPlayerUI.setProgress(loadPercentage);
      if (numLoadedAudios >= audioURLs.size) {
        numLoadedAudios = 0;
        if (afterPreloadFunction) afterPreloadFunction();
      }
      if (action === "error") {
        logInfo(`Could not pre-load: ${url}. This might not be a problem, the audio may still play normally later.`);
        audioMap.delete(url);
        return;
      }
      if (!audioMap.has(url)) {
        logError("Race condition on pre-load! Please report this bug!", url);
      }
    };
    audioURLs.forEach((url) => {
      if (audioMap.has(url)) {
        numLoadedAudios++;
        return;
      }
      preloadURL(url).then((audio) => {
        audio.once("load", () => onAudioPreload("load", url));
        audio.once("loaderror", () => onAudioPreload("error", url));
      }).catch((_reason) => onAudioPreload("error", url));
    });
    if (numLoadedAudios >= audioURLs.size) {
      if (afterPreloadFunction) afterPreloadFunction();
    }
  }
  async function preloadURL(srcURL) {
    const audio = audioMap.get(srcURL);
    if (audio) return audio;
    if (urlQueue.has(srcURL)) {
      const storedPromise = promiseMap.get(srcURL);
      if (!storedPromise) return Promise.reject(`No promise found for ${srcURL}, please report this bug!`);
      return storedPromise;
    }
    urlQueue.add(srcURL);
    const promise = loadMusicFromDB(srcURL).then(
      (localCacheURL) => createNewAudio(srcURL, localCacheURL),
      (reason) => {
        logDebug(reason, srcURL);
        return createNewAudio(srcURL, srcURL);
      }
    );
    promiseMap.set(srcURL, promise);
    return promise;
  }
  const unitIDAudioMap = /* @__PURE__ */ new Map();
  function playMovementSound(unitId) {
    if (!musicSettings.isPlaying) return;
    if (!unitIDAudioMap.has(unitId)) {
      const unitName = getUnitName(unitId);
      if (!unitName) return;
      const movementSoundURL = getMovementSoundURL(unitName);
      if (!movementSoundURL) {
        logError("No movement sound for", unitName);
        return;
      }
      unitIDAudioMap.set(unitId, new Audio(movementSoundURL));
    }
    const movementAudio = unitIDAudioMap.get(unitId);
    if (!movementAudio) return;
    movementAudio.currentTime = 0;
    movementAudio.loop = false;
    movementAudio.volume = musicSettings.sfxVolume;
    movementAudio.play();
  }
  function stopMovementSound(unitId, rolloff = true) {
    if (!musicSettings.isPlaying) return;
    if (!unitIDAudioMap.has(unitId)) return;
    const movementAudio = unitIDAudioMap.get(unitId);
    if (!movementAudio || movementAudio.paused) return;
    if (movementAudio.readyState != HTMLAudioElement.prototype.HAVE_ENOUGH_DATA) {
      movementAudio.addEventListener("canplaythrough", whenAudioLoadsPauseIt, { once: true });
      return;
    }
    movementAudio.pause();
    movementAudio.currentTime = 0;
    const unitName = getUnitName(unitId);
    if (!rolloff || !unitName) return;
    if (hasMovementRollOff(unitName)) {
      const audioURL = getMovementRollOffURL(unitName);
      playOneShotURL(audioURL, musicSettings.sfxVolume);
    }
  }
  function stopAllMovementSounds() {
    for (const unitId of unitIDAudioMap.keys()) {
      stopMovementSound(unitId, false);
    }
  }
  function whenAudioLoadsPauseIt(event2) {
    event2.target.pause();
  }
  let currentThemeURL = "";
  let currentLoops = 0;
  const specialLoopMap = /* @__PURE__ */ new Map();
  let currentlyDelaying = false;
  async function playMusicURL(srcURL) {
    const specialLoopURL = specialLoopMap.get(srcURL);
    if (specialLoopURL) srcURL = specialLoopURL;
    if (srcURL !== currentThemeURL) {
      stopThemeSong();
      currentThemeURL = srcURL;
    }
    const nextSong = audioMap.get(srcURL) ?? await preloadURL(srcURL);
    nextSong.loop(!hasSpecialLoop(srcURL));
    nextSong.volume(getVolumeForURL(srcURL));
    nextSong.on("play", () => onThemePlay(nextSong, srcURL));
    nextSong.on("load", () => playThemeSong());
    nextSong.on("end", () => onThemeEndOrLoop(srcURL));
    if (!nextSong.playing() && musicSettings.isPlaying) {
      logInfo("Now Playing: ", srcURL, " | Cached? =", nextSong._src !== srcURL);
      const newID = nextSong.play();
      if (!newID) return;
      audioIDMap.set(srcURL, newID);
    }
  }
  function playThemeSong() {
    if (!musicSettings.isPlaying) return;
    if (currentlyDelaying) return;
    let gameType = void 0;
    let coName = currentPlayer.coName;
    if (getCurrentPageType() === PageType.Maintenance) coName = SpecialCOs.Maintenance;
    else if (getCurrentPageType() === PageType.MapEditor) coName = SpecialCOs.MapEditor;
    else if (getCurrentPageType() === PageType.MainPage) coName = SpecialCOs.MainPage;
    else if (getCurrentPageType() === PageType.LiveQueue) coName = SpecialCOs.LiveQueue;
    else if (getCurrentPageType() === PageType.Default) coName = SpecialCOs.Default;
    const isEndTheme = coName === SpecialCOs.Victory || coName === SpecialCOs.Defeat;
    const isRandomTheme = musicSettings.randomThemesType !== RandomThemeType.NONE;
    if (isRandomTheme && !isEndTheme) {
      coName = musicSettings.currentRandomCO;
      if (musicSettings.randomThemesType === RandomThemeType.ALL_THEMES) gameType = musicSettings.currentRandomGameType;
    }
    if (!coName) {
      if (!currentThemeURL || currentThemeURL === "") return;
      playMusicURL(currentThemeURL);
      return;
    }
    playMusicURL(getMusicURL(coName, gameType));
  }
  function stopThemeSong(delayMS = 0) {
    if (delayMS > 0) {
      window.setTimeout(() => {
        currentlyDelaying = false;
        playThemeSong();
      }, delayMS);
      currentlyDelaying = true;
    }
    const currentTheme = audioMap.get(currentThemeURL);
    if (!currentTheme) return;
    logDebug("Pausing: ", currentThemeURL);
    currentTheme.pause();
  }
  function stopAllSounds() {
    stopThemeSong();
    stopAllMovementSounds();
    for (const audio of audioMap.values()) {
      if (audio.playing()) audio.pause();
    }
  }
  function onThemePlay(audio, srcURL) {
    currentLoops = 0;
    audio.volume(getVolumeForURL(srcURL));
    broadcastChannel.postMessage("pause");
    const isPowerTheme = musicSettings.themeType !== ThemeType.REGULAR;
    const isRandomTheme = musicSettings.randomThemesType !== RandomThemeType.NONE;
    const shouldRestart = musicSettings.restartThemes || isPowerTheme || isRandomTheme;
    const currentPosition = audio.seek();
    const isGamePageActive = getCurrentPageType() === PageType.ActiveGame;
    if (shouldRestart && isGamePageActive && currentPosition > 0.1) {
      audio.seek(0);
    }
    if (currentThemeURL !== srcURL && audio.playing()) {
      audio.pause();
      playThemeSong();
    }
    const audioID = audioIDMap.get(srcURL);
    if (!audioID) return;
    for (const id of audio._getSoundIds()) {
      if (id !== audioID) audio.stop(id);
    }
  }
  function onThemeEndOrLoop(srcURL) {
    currentLoops++;
    if (currentThemeURL !== srcURL) {
      logError("Playing more than one theme at a time! Please report this bug!", srcURL);
      return;
    }
    if (hasSpecialLoop(srcURL)) {
      const loopURL = srcURL.replace(".ogg", "-loop.ogg");
      specialLoopMap.set(srcURL, loopURL);
      playThemeSong();
    }
    if (srcURL === SpecialTheme.Victory || srcURL === SpecialTheme.Defeat) {
      if (currentLoops >= 3) playMusicURL(SpecialTheme.COSelect);
    }
    if (musicSettings.randomThemesType !== RandomThemeType.NONE && !musicSettings.loopRandomSongsUntilTurnChange) {
      musicSettings.randomizeCO();
      playThemeSong();
    }
  }
  function onSettingsChange(key, _value, isFirstLoad) {
    if (isFirstLoad) return;
    switch (key) {
      case SettingsKey.ADD_OVERRIDE:
      case SettingsKey.REMOVE_OVERRIDE:
      case SettingsKey.OVERRIDE_LIST:
      case SettingsKey.CURRENT_RANDOM_CO:
      case SettingsKey.IS_PLAYING:
        return musicSettings.isPlaying ? playThemeSong() : stopAllSounds();
      case SettingsKey.GAME_TYPE:
      case SettingsKey.ALTERNATE_THEME_DAY:
      case SettingsKey.ALTERNATE_THEMES:
        return window.setTimeout(() => playThemeSong(), 500);
      case SettingsKey.THEME_TYPE:
        return playThemeSong();
      case SettingsKey.REMOVE_EXCLUDED:
        if (musicSettings.excludedRandomThemes.size === 27) musicSettings.randomizeCO();
        return playThemeSong();
      case SettingsKey.EXCLUDED_RANDOM_THEMES:
      case SettingsKey.ADD_EXCLUDED:
        if (musicSettings.excludedRandomThemes.has(musicSettings.currentRandomCO)) musicSettings.randomizeCO();
        return playThemeSong();
      case SettingsKey.RANDOM_THEMES_TYPE: {
        const randomThemes = musicSettings.randomThemesType !== RandomThemeType.NONE;
        if (!randomThemes) return playThemeSong();
        musicSettings.randomizeCO();
        playThemeSong();
        return;
      }
      case SettingsKey.VOLUME: {
        const currentTheme = audioMap.get(currentThemeURL);
        if (currentTheme) currentTheme.volume(musicSettings.volume);
        if (!currentTheme) {
          const intervalID = window.setInterval(() => {
            const currentTheme2 = audioMap.get(currentThemeURL);
            if (currentTheme2) {
              currentTheme2.volume(musicSettings.volume);
              window.clearInterval(intervalID);
            }
          });
        }
        for (const srcURL of audioMap.keys()) {
          const audio = audioMap.get(srcURL);
          if (audio) audio.volume(getVolumeForURL(srcURL));
        }
        return;
      }
    }
  }
  const restartTheme = debounce$1(300, __restartTheme, true);
  function __restartTheme() {
    const currentTheme = audioMap.get(currentThemeURL);
    if (!currentTheme) return;
    currentTheme.seek(0);
  }
  function clearThemeDelay() {
    currentlyDelaying = false;
    playThemeSong();
  }
  function addThemeListeners() {
    addSettingsChangeListener(onSettingsChange);
    addDatabaseReplacementListener((url) => {
      const audio = audioMap.get(url);
      if (!audio) return;
      logInfo("A new version of", url, " is available. Replacing the old version.");
      if (audio.playing()) audio.stop();
      urlQueue.delete(url);
      promiseMap.delete(url);
      audioMap.delete(url);
      audioIDMap.delete(url);
      preloadURL(url).catch((reason) => logError(reason)).finally(() => playThemeSong());
    });
  }
  addThemeListeners();
  async function playSFX(sfx) {
    if (!musicSettings.isPlaying) return;
    if (!musicSettings.captureProgressSFX && sfx === GameSFX.unitCaptureProgress) return;
    if (!musicSettings.pipeSeamSFX && sfx === GameSFX.unitAttackPipeSeam) return;
    const sfxURL = getSoundEffectURL(sfx);
    const audio = audioMap.get(sfxURL) ?? await preloadURL(sfxURL);
    audio.volume(getVolumeForURL(sfxURL));
    audio.seek(0);
    if (audio.playing()) return;
    const newID = audio.play();
    if (!newID) return;
    audioIDMap.set(sfxURL, newID);
  }
  function stopSFX(sfx) {
    if (!musicSettings.isPlaying) return;
    const sfxURL = getSoundEffectURL(sfx);
    const audio = audioMap.get(sfxURL);
    if (!audio || !audio.playing()) return;
    audio.stop();
  }
  const CURSOR_THRESHOLD_MS = 25;
  let lastCursorCall$1 = Date.now();
  let lastCursorX = -1;
  let lastCursorY = -1;
  let currentMenuType = "None";
  const visibilityMap = /* @__PURE__ */ new Map();
  const movementResponseMap = /* @__PURE__ */ new Map();
  const clickedDamageSquaresMap = /* @__PURE__ */ new Map();
  const ahQueryTurn = getQueryTurnFn();
  const ahShowEventScreen = getShowEventScreenFn();
  const ahShowEndGameScreen = getShowEndGameScreenFn();
  const ahOpenMenu = getOpenMenuFn();
  const ahCloseMenu = getCloseMenuFn();
  const ahCreateDamageSquares = getCreateDamageSquaresFn();
  const ahUnitClick = getUnitClickFn();
  const ahWait = getWaitFn();
  const ahAnimUnit = getAnimUnitFn();
  const ahAnimExplosion = getAnimExplosionFn();
  const ahFog = getFogFn();
  const ahFire = getFireFn();
  const ahAttackSeam = getAttackSeamFn();
  const ahMove = getMoveFn();
  const ahCapt = getCaptFn();
  const ahBuild = getBuildFn();
  const ahLoad = getLoadFn();
  const ahUnload = getUnloadFn();
  const ahSupply = getSupplyFn();
  const ahRepair = getRepairFn();
  const ahHide = getHideFn();
  const ahUnhide = getUnhideFn();
  const ahJoin = getJoinFn();
  const ahLaunch = getLaunchFn();
  const ahNextTurn = getNextTurnFn();
  const ahElimination = getEliminationFn();
  const ahPower = getPowerFn();
  const ahGameOver = getGameOverFn();
  const ahResign = getResignFn();
  function addHandlers() {
    const currentPageType = getCurrentPageType();
    if (currentPageType === PageType.Maintenance) return;
    addUpdateCursorObserver(onCursorMove);
    switch (currentPageType) {
      case PageType.ActiveGame:
        addReplayHandlers();
        addGameHandlers();
        return;
      case PageType.MapEditor:
        return;
      case PageType.MovePlanner:
        return;
    }
  }
  function syncMusic() {
    musicSettings.themeType = getCurrentThemeType();
    playThemeSong();
    window.setTimeout(() => {
      musicSettings.themeType = getCurrentThemeType();
      playThemeSong();
    }, 500);
  }
  function refreshMusicForNextTurn(playDelayMS = 0) {
    visibilityMap.clear();
    musicSettings.randomizeCO();
    musicSettings.themeType = getCurrentThemeType();
    window.setTimeout(() => {
      musicSettings.themeType = getCurrentThemeType();
      if (musicSettings.restartThemes) restartTheme();
      playThemeSong();
      window.setTimeout(playThemeSong, 350);
    }, playDelayMS);
  }
  function addReplayHandlers() {
    queryTurn = onQueryTurn;
    const replayForwardActionBtn = getReplayForwardActionBtn();
    const replayBackwardActionBtn = getReplayBackwardActionBtn();
    const replayForwardBtn = getReplayForwardBtn();
    const replayBackwardBtn = getReplayBackwardBtn();
    const replayOpenBtn = getReplayOpenBtn();
    const replayCloseBtn = getReplayCloseBtn();
    const replayDaySelectorCheckBox = getReplayDaySelectorCheckBox();
    replayBackwardActionBtn.addEventListener("click", syncMusic);
    replayForwardActionBtn.addEventListener("click", syncMusic);
    replayForwardBtn.addEventListener("click", syncMusic);
    replayBackwardBtn.addEventListener("click", syncMusic);
    replayDaySelectorCheckBox.addEventListener("change", syncMusic);
    replayCloseBtn.addEventListener("click", syncMusic);
    replayBackwardActionBtn.addEventListener("click", stopAllMovementSounds);
    replayOpenBtn.addEventListener("click", stopAllMovementSounds);
    replayCloseBtn.addEventListener("click", stopAllMovementSounds);
    replayForwardBtn.addEventListener("click", clearThemeDelay);
    replayBackwardActionBtn.addEventListener("click", clearThemeDelay);
    replayBackwardBtn.addEventListener("click", clearThemeDelay);
    const stopExtraSFX = () => {
      stopSFX(GameSFX.powerActivateAW1COP);
      stopSFX(GameSFX.powerActivateAllyCOP);
      stopSFX(GameSFX.powerActivateAllySCOP);
      stopSFX(GameSFX.powerActivateBHCOP);
      stopSFX(GameSFX.powerActivateBHSCOP);
    };
    replayBackwardActionBtn.addEventListener("click", stopExtraSFX);
    replayForwardBtn.addEventListener("click", stopExtraSFX);
    replayBackwardBtn.addEventListener("click", stopExtraSFX);
    replayCloseBtn.addEventListener("click", stopExtraSFX);
    replayCloseBtn.addEventListener("click", () => refreshMusicForNextTurn(500));
  }
  function addGameHandlers() {
    showEventScreen = onShowEventScreen;
    showEndGameScreen = onShowEndGameScreen;
    openMenu = onOpenMenu;
    closeMenu = onCloseMenu;
    createDamageSquares = onCreateDamageSquares;
    unitClickHandler = onUnitClick;
    waitUnit = onUnitWait;
    animUnit = onAnimUnit;
    animExplosion = onAnimExplosion;
    updateAirUnitFogOnMove = onFogUpdate;
    actionHandlers.Fire = onFire;
    actionHandlers.AttackSeam = onAttackSeam;
    actionHandlers.Move = onMove;
    actionHandlers.Capt = onCapture;
    actionHandlers.Build = onBuild;
    actionHandlers.Load = onLoad;
    actionHandlers.Unload = onUnload;
    actionHandlers.Supply = onSupply;
    actionHandlers.Repair = onRepair;
    actionHandlers.Hide = onHide;
    actionHandlers.Unhide = onUnhide;
    actionHandlers.Join = onJoin;
    actionHandlers.Launch = onLaunch;
    actionHandlers.NextTurn = onNextTurn;
    actionHandlers.Elimination = onElimination;
    actionHandlers.Power = onPower;
    actionHandlers.GameOver = onGameOver;
    actionHandlers.Resign = onResign;
    addConnectionErrorObserver(onConnectionError);
  }
  function onCursorMove(cursorX, cursorY) {
    if (!musicSettings.isPlaying) return;
    const dx = Math.abs(cursorX - lastCursorX);
    const dy = Math.abs(cursorY - lastCursorY);
    const cursorMoved = dx >= 1 || dy >= 1;
    const timeSinceLastCursorCall = Date.now() - lastCursorCall$1;
    if (timeSinceLastCursorCall < CURSOR_THRESHOLD_MS) return;
    if (cursorMoved) {
      playSFX(GameSFX.uiCursorMove);
      lastCursorCall$1 = Date.now();
    }
    lastCursorX = cursorX;
    lastCursorY = cursorY;
  }
  function onQueryTurn(gameId, turn, turnPId, turnDay, replay2, initial) {
    const result = ahQueryTurn == null ? void 0 : ahQueryTurn.apply(ahQueryTurn, [gameId, turn, turnPId, turnDay, replay2, initial]);
    if (!musicSettings.isPlaying) return result;
    refreshMusicForNextTurn(250);
    return result;
  }
  function onShowEventScreen(event2) {
    ahShowEventScreen == null ? void 0 : ahShowEventScreen.apply(ahShowEventScreen, [event2]);
    if (!musicSettings.isPlaying) return;
    if (hasGameEnded()) {
      refreshMusicForNextTurn();
      return;
    }
    playThemeSong();
    window.setTimeout(playThemeSong, 500);
  }
  function onShowEndGameScreen(event2) {
    ahShowEndGameScreen == null ? void 0 : ahShowEndGameScreen.apply(ahShowEndGameScreen, [event2]);
    if (!musicSettings.isPlaying) return;
    refreshMusicForNextTurn();
  }
  function onOpenMenu(menu, x, y) {
    ahOpenMenu == null ? void 0 : ahOpenMenu.apply(openMenu, [menu, x, y]);
    if (!musicSettings.isPlaying) return;
    currentMenuType = "Regular";
    playSFX(GameSFX.uiMenuOpen);
    const menuOptions = getCurrentDocument().getElementsByClassName("menu-option");
    for (let i = 0; i < menuOptions.length; i++) {
      menuOptions[i].addEventListener("mouseenter", (_e) => playSFX(GameSFX.uiMenuMove));
      menuOptions[i].addEventListener("click", (event2) => {
        var _a, _b, _c, _d, _e, _f;
        const target = event2.target;
        if (!target) return;
        if (target.classList.contains("forbidden") || ((_a = target.parentElement) == null ? void 0 : _a.classList.contains("forbidden")) || ((_c = (_b = target.parentElement) == null ? void 0 : _b.parentElement) == null ? void 0 : _c.classList.contains("forbidden")) || ((_f = (_e = (_d = target.parentElement) == null ? void 0 : _d.parentElement) == null ? void 0 : _e.parentElement) == null ? void 0 : _f.classList.contains("forbidden"))) {
          playSFX(GameSFX.uiInvalid);
          return;
        }
        currentMenuType = "None";
        playSFX(GameSFX.uiMenuOpen);
      });
    }
  }
  function onCloseMenu() {
    ahCloseMenu == null ? void 0 : ahCloseMenu.apply(closeMenu, []);
    if (!musicSettings.isPlaying) return;
    const isMenuOpen = currentMenuType !== "None";
    if (isMenuOpen) {
      playSFX(GameSFX.uiMenuClose);
      clickedDamageSquaresMap.clear();
      currentMenuType = "None";
    }
  }
  function onCreateDamageSquares(attackerUnit, unitsInRange, movementInfo, movingUnit) {
    ahCreateDamageSquares == null ? void 0 : ahCreateDamageSquares.apply(createDamageSquares, [attackerUnit, unitsInRange, movementInfo, movingUnit]);
    if (!musicSettings.isPlaying) return;
    for (const damageSquare of getAllDamageSquares()) {
      damageSquare.addEventListener("click", (event2) => {
        if (!event2.target) return;
        const targetSpan = event2.target;
        playSFX(GameSFX.uiMenuOpen);
        if (clickedDamageSquaresMap.has(targetSpan)) {
          currentMenuType = "None";
          clickedDamageSquaresMap.clear();
          return;
        }
        currentMenuType = "DamageSquare";
        clickedDamageSquaresMap.set(targetSpan, true);
      });
    }
  }
  function onUnitClick(clicked) {
    ahUnitClick == null ? void 0 : ahUnitClick.apply(unitClickHandler, [clicked]);
    if (!musicSettings.isPlaying) return;
    const unitInfo = getUnitInfo(Number(clicked.id));
    if (!unitInfo) return;
    const myID2 = getMyID();
    const isUnitWaited = hasUnitMovedThisTurn(unitInfo.units_id);
    const isMyUnit = (unitInfo == null ? void 0 : unitInfo.units_players_id) === myID2;
    const isMyTurn = currentTurn === myID2;
    const canActionsBeTaken = !isUnitWaited && isMyUnit && isMyTurn && !isReplayActive();
    currentMenuType = canActionsBeTaken ? "UnitSelect" : "None";
    playSFX(GameSFX.uiUnitSelect);
  }
  function onUnitWait(unitId) {
    ahWait == null ? void 0 : ahWait.apply(waitUnit, [unitId]);
    if (!musicSettings.isPlaying) return;
    if (movementResponseMap.has(unitId)) {
      const response = movementResponseMap.get(unitId);
      if (response == null ? void 0 : response.trapped) {
        playSFX(GameSFX.unitTrap);
      }
      stopMovementSound(unitId, !(response == null ? void 0 : response.trapped));
      movementResponseMap.delete(unitId);
      return;
    }
    stopMovementSound(unitId);
  }
  function onAnimUnit(path, unitId, unitSpan, unitTeam, viewerTeam, i) {
    ahAnimUnit == null ? void 0 : ahAnimUnit.apply(animUnit, [path, unitId, unitSpan, unitTeam, viewerTeam, i]);
    if (!musicSettings.isPlaying) return;
    if (!isValidUnit(unitId) || !path || !i) return;
    if (i >= path.length) return;
    if (visibilityMap.has(unitId)) return;
    const unitVisible = path[i].unit_visible;
    if (!unitVisible) {
      visibilityMap.set(unitId, unitVisible);
      window.setTimeout(() => stopMovementSound(unitId, false), 1e3);
    }
  }
  function onAnimExplosion(unit) {
    ahAnimExplosion == null ? void 0 : ahAnimExplosion.apply(animExplosion, [unit]);
    if (!musicSettings.isPlaying) return;
    const unitId = unit.units_id;
    const unitFuel = unit.units_fuel;
    let sfx = GameSFX.unitExplode;
    if (getUnitName(unitId) === "Black Bomb" && unitFuel > 0) {
      sfx = GameSFX.unitMissileHit;
    }
    playSFX(sfx);
    stopMovementSound(unitId, false);
  }
  function onFogUpdate(x, y, mType, neighbours, unitVisible, change, delay) {
    ahFog == null ? void 0 : ahFog.apply(updateAirUnitFogOnMove, [x, y, mType, neighbours, unitVisible, change, delay]);
    if (!musicSettings.isPlaying) return;
    const unitInfo = getUnitInfoFromCoords(x, y);
    if (!unitInfo) return;
    if (change === "Add") {
      window.setTimeout(() => stopMovementSound(unitInfo.units_id, true), delay);
    }
  }
  function onFire(response) {
    if (!musicSettings.isPlaying) {
      ahFire == null ? void 0 : ahFire.apply(actionHandlers.Fire, [response]);
      return;
    }
    const attackerID = response.copValues.attacker.playerId;
    const defenderID = response.copValues.defender.playerId;
    const couldAttackerActivateSCOPBefore = canPlayerActivateSuperCOPower(attackerID);
    const couldAttackerActivateCOPBefore = canPlayerActivateCOPower(attackerID);
    const couldDefenderActivateSCOPBefore = canPlayerActivateSuperCOPower(defenderID);
    const couldDefenderActivateCOPBefore = canPlayerActivateCOPower(defenderID);
    ahFire == null ? void 0 : ahFire.apply(actionHandlers.Fire, [response]);
    const delay = areAnimationsEnabled() ? 750 : 0;
    const canAttackerActivateSCOPAfter = canPlayerActivateSuperCOPower(attackerID);
    const canAttackerActivateCOPAfter = canPlayerActivateCOPower(attackerID);
    const canDefenderActivateSCOPAfter = canPlayerActivateSuperCOPower(defenderID);
    const canDefenderActivateCOPAfter = canPlayerActivateCOPower(defenderID);
    const madeSCOPAvailable = !couldAttackerActivateSCOPBefore && canAttackerActivateSCOPAfter || !couldDefenderActivateSCOPBefore && canDefenderActivateSCOPAfter;
    const madeCOPAvailable = !couldAttackerActivateCOPBefore && canAttackerActivateCOPAfter || !couldDefenderActivateCOPBefore && canDefenderActivateCOPAfter;
    window.setTimeout(() => {
      if (madeSCOPAvailable) playSFX(GameSFX.powerSCOPAvailable);
      else if (madeCOPAvailable) playSFX(GameSFX.powerCOPAvailable);
    }, delay);
  }
  function wiggleTile(div, startDelay = 0) {
    const stepsX = 12;
    const stepsY = 4;
    const deltaX = 0.2;
    const deltaY = 0.05;
    const wiggleAnimation = () => {
      moveDivToOffset(
        div,
        deltaX,
        0,
        stepsX,
        { then: [0, -0.05, stepsY] },
        { then: [-0.2 * 2, 0, stepsX] },
        { then: [deltaX * 2, 0, stepsX] },
        { then: [0, -0.05, stepsY] },
        { then: [-0.2 * 2, 0, stepsX] },
        { then: [deltaX * 2, 0, stepsX] },
        { then: [0, deltaY, stepsY] },
        { then: [-0.2 * 2, 0, stepsX] },
        { then: [deltaX, 0, stepsX] },
        { then: [0, deltaY, stepsY] }
      );
    };
    window.setTimeout(wiggleAnimation, startDelay);
  }
  function onAttackSeam(response) {
    ahAttackSeam == null ? void 0 : ahAttackSeam.apply(actionHandlers.AttackSeam, [response]);
    if (!musicSettings.isPlaying) return;
    const seamWasDestroyed = response.seamHp <= 0;
    if (areAnimationsEnabled()) {
      const x = response.seamX;
      const y = response.seamY;
      const pipeSeamInfo = getBuildingInfo(x, y);
      if (!pipeSeamInfo) return;
      const pipeSeamDiv = getBuildingDiv(pipeSeamInfo.buildings_id);
      const wiggleDelay = seamWasDestroyed ? 0 : attackDelayMS;
      wiggleTile(pipeSeamDiv, wiggleDelay);
    }
    if (seamWasDestroyed) {
      playSFX(GameSFX.unitAttackPipeSeam);
      playSFX(GameSFX.unitExplode);
      return;
    }
    window.setTimeout(() => playSFX(GameSFX.unitAttackPipeSeam), attackDelayMS);
  }
  function onMove(response, loadFlag) {
    ahMove == null ? void 0 : ahMove.apply(actionHandlers.Move, [response, loadFlag]);
    if (!musicSettings.isPlaying) return;
    const unitId = response.unit.units_id;
    movementResponseMap.set(unitId, response);
    const movementDist = response.path.length;
    stopMovementSound(unitId, false);
    if (movementDist > 1) {
      playMovementSound(unitId);
    }
  }
  function onCapture(data) {
    ahCapt == null ? void 0 : ahCapt.apply(actionHandlers.Capt, [data]);
    if (!musicSettings.isPlaying) return;
    const finishedCapture = data.newIncome != null;
    if (!finishedCapture) {
      playSFX(GameSFX.unitCaptureProgress);
      return;
    }
    const myID2 = getMyID();
    const isSpectator = isPlayerSpectator(myID2);
    const isMyCapture = data.buildingInfo.buildings_team === myID2.toString() || isSpectator;
    const sfx = isMyCapture ? GameSFX.unitCaptureAlly : GameSFX.unitCaptureEnemy;
    playSFX(sfx);
  }
  function onBuild(data) {
    ahBuild == null ? void 0 : ahBuild.apply(actionHandlers.Build, [data]);
    if (!musicSettings.isPlaying) return;
    const myID2 = getMyID();
    const isMyBuild = data.newUnit.units_players_id == myID2;
    const isReplay = isReplayActive();
    if (!isMyBuild || isReplay) playSFX(GameSFX.unitSupply);
  }
  function onLoad(data) {
    ahLoad == null ? void 0 : ahLoad.apply(actionHandlers.Load, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitLoad);
  }
  function onUnload(data) {
    ahUnload == null ? void 0 : ahUnload.apply(actionHandlers.Unload, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitUnload);
  }
  function onSupply(data) {
    ahSupply == null ? void 0 : ahSupply.apply(actionHandlers.Supply, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitSupply);
  }
  function onRepair(data) {
    ahRepair == null ? void 0 : ahRepair.apply(actionHandlers.Repair, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitSupply);
  }
  function onHide(data) {
    ahHide == null ? void 0 : ahHide.apply(actionHandlers.Hide, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitHide);
    stopMovementSound(data.unitId);
  }
  function onUnhide(data) {
    ahUnhide == null ? void 0 : ahUnhide.apply(actionHandlers.Unhide, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitUnhide);
    stopMovementSound(data.unitId);
  }
  function onJoin(data) {
    ahJoin == null ? void 0 : ahJoin.apply(actionHandlers.Join, [data]);
    if (!musicSettings.isPlaying) return;
    stopMovementSound(data.joinID);
    stopMovementSound(data.joinedUnit.units_id);
  }
  function onLaunch(data) {
    ahLaunch == null ? void 0 : ahLaunch.apply(actionHandlers.Launch, [data]);
    if (!musicSettings.isPlaying) return;
    playSFX(GameSFX.unitMissileSend);
    window.setTimeout(() => playSFX(GameSFX.unitMissileHit), siloDelayMS);
  }
  function onNextTurn(data) {
    ahNextTurn == null ? void 0 : ahNextTurn.apply(actionHandlers.NextTurn, [data]);
    if (!musicSettings.isPlaying) return;
    if (data.swapCos) {
      playSFX(GameSFX.tagSwap);
    }
    refreshMusicForNextTurn();
  }
  function onElimination(data) {
    ahElimination == null ? void 0 : ahElimination.apply(actionHandlers.Elimination, [data]);
    if (!musicSettings.isPlaying) return;
    refreshMusicForNextTurn();
  }
  function onGameOver() {
    ahGameOver == null ? void 0 : ahGameOver.apply(actionHandlers.GameOver, []);
    if (!musicSettings.isPlaying) return;
    refreshMusicForNextTurn();
  }
  function onResign(data) {
    ahResign == null ? void 0 : ahResign.apply(actionHandlers.Resign, [data]);
    if (!musicSettings.isPlaying) return;
    refreshMusicForNextTurn();
  }
  function onPower(data) {
    ahPower == null ? void 0 : ahPower.apply(actionHandlers.Power, [data]);
    if (!musicSettings.isPlaying) return;
    const coName = data.coName;
    const isBH = isBlackHoleCO(coName);
    const isSuperCOPower = data.coPower === COPowerEnum.SuperCOPower;
    stopSFX(GameSFX.powerCOPAvailable);
    stopSFX(GameSFX.powerSCOPAvailable);
    window.setTimeout(() => {
      stopSFX(GameSFX.powerCOPAvailable);
      stopSFX(GameSFX.powerSCOPAvailable);
    }, 755);
    musicSettings.themeType = isSuperCOPower ? ThemeType.SUPER_CO_POWER : ThemeType.CO_POWER;
    switch (musicSettings.gameType) {
      case GameType.AW1:
        playSFX(GameSFX.powerActivateAW1COP);
        stopThemeSong(4500);
        return;
      case GameType.AW2:
      case GameType.DS:
      case GameType.RBC: {
        if (isSuperCOPower) {
          const sfx2 = isBH ? GameSFX.powerActivateBHSCOP : GameSFX.powerActivateAllySCOP;
          const delay2 = isBH ? 1916 : 1100;
          playSFX(sfx2);
          stopThemeSong(delay2);
          break;
        }
        const sfx = isBH ? GameSFX.powerActivateBHCOP : GameSFX.powerActivateAllyCOP;
        const delay = isBH ? 1019 : 881;
        playSFX(sfx);
        stopThemeSong(delay);
        break;
      }
    }
    if (coName === "Colin" && !isSuperCOPower) {
      window.setTimeout(() => playSFX(GameSFX.coGoldRush), 800);
    }
  }
  function onConnectionError(closeMsg) {
    closeMsg = closeMsg.toLowerCase();
    if (closeMsg.includes("connected to another game")) stopThemeSong();
  }
  let debugOverrides = false;
  function toggleDebugOverrides() {
    debugOverrides = !debugOverrides;
    if (debugOverrides) {
      for (const coName of getAllCONames()) {
        musicSettings.addOverride(coName, GameType.AW1);
        musicSettings.addExcludedRandomTheme(coName);
      }
    } else {
      for (const coName of getAllCONames()) {
        musicSettings.removeOverride(coName);
        musicSettings.removeExcludedRandomTheme(coName);
      }
    }
  }
  var e = function() {
    return (e = Object.assign || function(e2) {
      for (var t2, r2 = 1, s2 = arguments.length; r2 < s2; r2++) for (var a2 in t2 = arguments[r2]) Object.prototype.hasOwnProperty.call(t2, a2) && (e2[a2] = t2[a2]);
      return e2;
    }).apply(this, arguments);
  }, t = { kebab: /-(\w)/g, styleProp: /:(.*)/, styleList: /;(?![^(]*\))/g };
  function r(e2, t2) {
    return t2 ? t2.toUpperCase() : "";
  }
  function s(e2) {
    for (var s2, a2 = {}, c = 0, o = e2.split(t.styleList); c < o.length; c++) {
      var n = o[c].split(t.styleProp), i = n[0], l = n[1];
      (i = i.trim()) && ("string" == typeof l && (l = l.trim()), a2[s2 = i, s2.replace(t.kebab, r)] = l);
    }
    return a2;
  }
  function a() {
    for (var t2, r2, a2 = {}, c = arguments.length; c--; ) for (var o = 0, n = Object.keys(arguments[c]); o < n.length; o++) switch (t2 = n[o]) {
      case "class":
      case "style":
      case "directives":
        if (Array.isArray(a2[t2]) || (a2[t2] = []), "style" === t2) {
          var i = void 0;
          i = Array.isArray(arguments[c].style) ? arguments[c].style : [arguments[c].style];
          for (var l = 0; l < i.length; l++) {
            var y = i[l];
            "string" == typeof y && (i[l] = s(y));
          }
          arguments[c].style = i;
        }
        a2[t2] = a2[t2].concat(arguments[c][t2]);
        break;
      case "staticClass":
        if (!arguments[c][t2]) break;
        void 0 === a2[t2] && (a2[t2] = ""), a2[t2] && (a2[t2] += " "), a2[t2] += arguments[c][t2].trim();
        break;
      case "on":
      case "nativeOn":
        a2[t2] || (a2[t2] = {});
        for (var p = 0, f = Object.keys(arguments[c][t2] || {}); p < f.length; p++) r2 = f[p], a2[t2][r2] ? a2[t2][r2] = [].concat(a2[t2][r2], arguments[c][t2][r2]) : a2[t2][r2] = arguments[c][t2][r2];
        break;
      case "attrs":
      case "props":
      case "domProps":
      case "scopedSlots":
      case "staticStyle":
      case "hook":
      case "transition":
        a2[t2] || (a2[t2] = {}), a2[t2] = e({}, arguments[c][t2], a2[t2]);
        break;
      case "slot":
      case "key":
      case "ref":
      case "tag":
      case "show":
      case "keepAlive":
      default:
        a2[t2] || (a2[t2] = arguments[c][t2]);
    }
    return a2;
  }
  function ownKeys$1F(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1F(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1F(Object(source), true).forEach(function(key) {
        _defineProperty$20(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1F(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$20(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _typeof$4(obj) {
    "@babel/helpers - typeof";
    return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$4(obj);
  }
  var COMPONENT_UID_KEY = "_uid";
  var isVue3 = Vue2.version.startsWith("3");
  var REF_FOR_KEY = isVue3 ? "ref_for" : "refInFor";
  var ALLOWED_FIELDS_IN_DATA = ["class", "staticClass", "style", "attrs", "props", "domProps", "on", "nativeOn", "directives", "scopedSlots", "slot", "key", "ref", "refInFor"];
  var extend = Vue2.extend.bind(Vue2);
  if (isVue3) {
    var originalExtend = Vue2.extend;
    var KNOWN_COMPONENTS = ["router-link", "transition", "transition-group"];
    var originalVModelDynamicCreated = Vue2.vModelDynamic.created;
    var originalVModelDynamicBeforeUpdate = Vue2.vModelDynamic.beforeUpdate;
    Vue2.vModelDynamic.created = function(el, binding, vnode) {
      originalVModelDynamicCreated.call(this, el, binding, vnode);
      if (!el._assign) {
        el._assign = function() {
        };
      }
    };
    Vue2.vModelDynamic.beforeUpdate = function(el, binding, vnode) {
      originalVModelDynamicBeforeUpdate.call(this, el, binding, vnode);
      if (!el._assign) {
        el._assign = function() {
        };
      }
    };
    extend = (function patchedBootstrapVueExtend(definition) {
      if (_typeof$4(definition) === "object" && definition.render && !definition.__alreadyPatched) {
        var originalRender = definition.render;
        definition.__alreadyPatched = true;
        definition.render = function(h) {
          var patchedH = function patchedH2(tag, dataObjOrChildren, rawSlots) {
            var slots = rawSlots === void 0 ? [] : [Array.isArray(rawSlots) ? rawSlots.filter(Boolean) : rawSlots];
            var isTag2 = typeof tag === "string" && !KNOWN_COMPONENTS.includes(tag);
            var isSecondArgumentDataObject = dataObjOrChildren && _typeof$4(dataObjOrChildren) === "object" && !Array.isArray(dataObjOrChildren);
            if (!isSecondArgumentDataObject) {
              return h.apply(void 0, [tag, dataObjOrChildren].concat(slots));
            }
            var attrs = dataObjOrChildren.attrs, props2 = dataObjOrChildren.props, restData = _objectWithoutProperties(dataObjOrChildren, ["attrs", "props"]);
            var normalizedData = _objectSpread$1F(_objectSpread$1F({}, restData), {}, {
              attrs,
              props: isTag2 ? {} : props2
            });
            if (tag === "router-link" && !normalizedData.slots && !normalizedData.scopedSlots) {
              normalizedData.scopedSlots = {
                $hasNormal: function $hasNormal() {
                }
              };
            }
            return h.apply(void 0, [tag, normalizedData].concat(slots));
          };
          if (definition.functional) {
            var _ctx$children, _ctx$children$default;
            var ctx = arguments[1];
            var patchedCtx = _objectSpread$1F({}, ctx);
            patchedCtx.data = {
              attrs: _objectSpread$1F({}, ctx.data.attrs || {}),
              props: _objectSpread$1F({}, ctx.data.props || {})
            };
            Object.keys(ctx.data || {}).forEach(function(key) {
              if (ALLOWED_FIELDS_IN_DATA.includes(key)) {
                patchedCtx.data[key] = ctx.data[key];
              } else if (key in ctx.props) {
                patchedCtx.data.props[key] = ctx.data[key];
              } else if (!key.startsWith("on")) {
                patchedCtx.data.attrs[key] = ctx.data[key];
              }
            });
            var IGNORED_CHILDREN_KEYS = ["_ctx"];
            var children = ((_ctx$children = ctx.children) === null || _ctx$children === void 0 ? void 0 : (_ctx$children$default = _ctx$children.default) === null || _ctx$children$default === void 0 ? void 0 : _ctx$children$default.call(_ctx$children)) || ctx.children;
            if (children && Object.keys(patchedCtx.children).filter(function(k) {
              return !IGNORED_CHILDREN_KEYS.includes(k);
            }).length === 0) {
              delete patchedCtx.children;
            } else {
              patchedCtx.children = children;
            }
            patchedCtx.data.on = ctx.listeners;
            return originalRender.call(this, patchedH, patchedCtx);
          }
          return originalRender.call(this, patchedH);
        };
      }
      return originalExtend.call(this, definition);
    }).bind(Vue2);
  }
  var nextTick = Vue2.nextTick;
  var HAS_WINDOW_SUPPORT = typeof window !== "undefined";
  var HAS_DOCUMENT_SUPPORT = typeof document !== "undefined";
  var HAS_NAVIGATOR_SUPPORT = typeof navigator !== "undefined";
  var HAS_PROMISE_SUPPORT = typeof Promise !== "undefined";
  var HAS_MUTATION_OBSERVER_SUPPORT = typeof MutationObserver !== "undefined" || typeof WebKitMutationObserver !== "undefined" || typeof MozMutationObserver !== "undefined";
  var IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT;
  var WINDOW = HAS_WINDOW_SUPPORT ? window : {};
  var DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : {};
  var NAVIGATOR = HAS_NAVIGATOR_SUPPORT ? navigator : {};
  var USER_AGENT = (NAVIGATOR.userAgent || "").toLowerCase();
  var IS_JSDOM = USER_AGENT.indexOf("jsdom") > 0;
  var HAS_PASSIVE_EVENT_SUPPORT = function() {
    var passiveEventSupported = false;
    if (IS_BROWSER) {
      try {
        var options = {
          // This function will be called when the browser
          // attempts to access the passive property
          get passive() {
            passiveEventSupported = true;
          }
        };
        WINDOW.addEventListener("test", options, options);
        WINDOW.removeEventListener("test", options, options);
      } catch (_unused) {
        passiveEventSupported = false;
      }
    }
    return passiveEventSupported;
  }();
  var HAS_TOUCH_SUPPORT = IS_BROWSER && ("ontouchstart" in DOCUMENT.documentElement || NAVIGATOR.maxTouchPoints > 0);
  var HAS_POINTER_EVENT_SUPPORT = IS_BROWSER && Boolean(WINDOW.PointerEvent || WINDOW.MSPointerEvent);
  var HAS_INTERACTION_OBSERVER_SUPPORT = IS_BROWSER && "IntersectionObserver" in WINDOW && "IntersectionObserverEntry" in WINDOW && // Edge 15 and UC Browser lack support for `isIntersecting`
  // but we an use `intersectionRatio > 0` instead
  // 'isIntersecting' in window.IntersectionObserverEntry.prototype &&
  "intersectionRatio" in WINDOW.IntersectionObserverEntry.prototype;
  var NAME$2 = "BvConfig";
  var PROP_NAME$2 = "$bvConfig";
  var DEFAULT_BREAKPOINT = ["xs", "sm", "md", "lg", "xl"];
  var RX_ARRAY_NOTATION = /\[(\d+)]/g;
  var RX_BV_PREFIX = /^(BV?)/;
  var RX_DIGITS = /^\d+$/;
  var RX_EXTENSION = /^\..+/;
  var RX_HASH = /^#/;
  var RX_HASH_ID = /^#[A-Za-z]+[\w\-:.]*$/;
  var RX_HTML_TAGS = /(<([^>]+)>)/gi;
  var RX_HYPHENATE = /\B([A-Z])/g;
  var RX_LOWER_UPPER = /([a-z])([A-Z])/g;
  var RX_NUMBER = /^[0-9]*\.?[0-9]+$/;
  var RX_PLUS = /\+/g;
  var RX_REGEXP_REPLACE = /[-/\\^$*+?.()|[\]{}]/g;
  var RX_SPACES = /[\s\uFEFF\xA0]+/g;
  var RX_SPACE_SPLIT = /\s+/;
  var RX_STAR = /\/\*$/;
  var RX_START_SPACE_WORD = /(\s|^)(\w)/g;
  var RX_TRIM_LEFT = /^\s+/;
  var RX_UNDERSCORE = /_/g;
  var RX_UN_KEBAB = /-(\w)/g;
  var RX_DATE = /^\d+-\d\d?-\d\d?(?:\s|T|$)/;
  var RX_DATE_SPLIT = /-|\s|T/;
  var RX_TIME = /^([0-1]?[0-9]|2[0-3]):[0-5]?[0-9](:[0-5]?[0-9])?$/;
  var RX_HREF = /^.*(#[^#]+)$/;
  var RX_ENCODED_COMMA = /%2C/g;
  var RX_ENCODE_REVERSE = /[!'()*]/g;
  var RX_QUERY_START = /^(\?|#|&)/;
  var RX_ASPECT = /^\d+(\.\d*)?[/:]\d+(\.\d*)?$/;
  var RX_ASPECT_SEPARATOR = /[/:]/;
  var RX_COL_CLASS = /^col-/;
  var RX_ICON_PREFIX = /^BIcon/;
  var RX_STRIP_LOCALE_MODS = /-u-.+/;
  function _typeof$3(obj) {
    "@babel/helpers - typeof";
    return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$3(obj);
  }
  function _classCallCheck$7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    Object.defineProperty(subClass, "prototype", { value: Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }), writable: false });
    if (superClass) _setPrototypeOf$2(subClass, superClass);
  }
  function _createSuper$1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn$1(this, result);
    };
  }
  function _possibleConstructorReturn$1(self2, call) {
    if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized$1(self2);
  }
  function _assertThisInitialized$1(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2)) return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct$1(Class2, arguments, _getPrototypeOf$1(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
      return _setPrototypeOf$2(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function _construct$1(Parent, args, Class) {
    if (_isNativeReflectConstruct$2()) {
      _construct$1 = Reflect.construct;
    } else {
      _construct$1 = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf$2(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct$1.apply(null, arguments);
  }
  function _isNativeReflectConstruct$2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf$2(o, p) {
    _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf$2(o, p);
  }
  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf$1(o);
  }
  var Element = HAS_WINDOW_SUPPORT ? WINDOW.Element : /* @__PURE__ */ function(_Object) {
    _inherits$1(Element2, _Object);
    var _super = _createSuper$1(Element2);
    function Element2() {
      _classCallCheck$7(this, Element2);
      return _super.apply(this, arguments);
    }
    return Element2;
  }(/* @__PURE__ */ _wrapNativeSuper(Object));
  var HTMLElement = HAS_WINDOW_SUPPORT ? WINDOW.HTMLElement : /* @__PURE__ */ function(_Element) {
    _inherits$1(HTMLElement2, _Element);
    var _super2 = _createSuper$1(HTMLElement2);
    function HTMLElement2() {
      _classCallCheck$7(this, HTMLElement2);
      return _super2.apply(this, arguments);
    }
    return HTMLElement2;
  }(Element);
  var SVGElement = HAS_WINDOW_SUPPORT ? WINDOW.SVGElement : /* @__PURE__ */ function(_Element2) {
    _inherits$1(SVGElement2, _Element2);
    var _super3 = _createSuper$1(SVGElement2);
    function SVGElement2() {
      _classCallCheck$7(this, SVGElement2);
      return _super3.apply(this, arguments);
    }
    return SVGElement2;
  }(Element);
  var File = HAS_WINDOW_SUPPORT ? WINDOW.File : /* @__PURE__ */ function(_Object2) {
    _inherits$1(File2, _Object2);
    var _super4 = _createSuper$1(File2);
    function File2() {
      _classCallCheck$7(this, File2);
      return _super4.apply(this, arguments);
    }
    return File2;
  }(/* @__PURE__ */ _wrapNativeSuper(Object));
  function _typeof$2(obj) {
    "@babel/helpers - typeof";
    return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$2(obj);
  }
  var toType$1 = function toType2(value) {
    return _typeof$2(value);
  };
  var toRawType = function toRawType2(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  };
  var isUndefined = function isUndefined2(value) {
    return value === void 0;
  };
  var isNull = function isNull2(value) {
    return value === null;
  };
  var isUndefinedOrNull = function isUndefinedOrNull2(value) {
    return isUndefined(value) || isNull(value);
  };
  var isFunction$1 = function isFunction2(value) {
    return toType$1(value) === "function";
  };
  var isBoolean = function isBoolean2(value) {
    return toType$1(value) === "boolean";
  };
  var isString = function isString2(value) {
    return toType$1(value) === "string";
  };
  var isNumber = function isNumber2(value) {
    return toType$1(value) === "number";
  };
  var isNumeric$1 = function isNumeric2(value) {
    return RX_NUMBER.test(String(value));
  };
  var isArray = function isArray2(value) {
    return Array.isArray(value);
  };
  var isObject = function isObject2(obj) {
    return obj !== null && _typeof$2(obj) === "object";
  };
  var isPlainObject = function isPlainObject2(obj) {
    return Object.prototype.toString.call(obj) === "[object Object]";
  };
  var isDate = function isDate2(value) {
    return value instanceof Date;
  };
  var isEvent = function isEvent2(value) {
    return value instanceof Event;
  };
  var isFile = function isFile2(value) {
    return value instanceof File;
  };
  var isRegExp = function isRegExp2(value) {
    return toRawType(value) === "RegExp";
  };
  var isPromise = function isPromise2(value) {
    return !isUndefinedOrNull(value) && isFunction$1(value.then) && isFunction$1(value.catch);
  };
  function ownKeys$1E(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1E(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1E(Object(source), true).forEach(function(key) {
        _defineProperty$1$(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1E(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1$(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var assign = function assign2() {
    return Object.assign.apply(Object, arguments);
  };
  var create = function create2(proto, optionalProps) {
    return Object.create(proto, optionalProps);
  };
  var defineProperties = function defineProperties2(obj, props2) {
    return Object.defineProperties(obj, props2);
  };
  var defineProperty$1 = function defineProperty2(obj, prop2, descriptor) {
    return Object.defineProperty(obj, prop2, descriptor);
  };
  var getOwnPropertyNames = function getOwnPropertyNames2(obj) {
    return Object.getOwnPropertyNames(obj);
  };
  var keys = function keys2(obj) {
    return Object.keys(obj);
  };
  var hasOwnProperty = function hasOwnProperty2(obj, prop2) {
    return Object.prototype.hasOwnProperty.call(obj, prop2);
  };
  var toString$1 = function toString2(obj) {
    return Object.prototype.toString.call(obj);
  };
  var clone = function clone2(obj) {
    return _objectSpread$1E({}, obj);
  };
  var pick$1 = function pick2(obj, props2) {
    return keys(obj).filter(function(key) {
      return props2.indexOf(key) !== -1;
    }).reduce(function(result, key) {
      return _objectSpread$1E(_objectSpread$1E({}, result), {}, _defineProperty$1$({}, key, obj[key]));
    }, {});
  };
  var omit = function omit2(obj, props2) {
    return keys(obj).filter(function(key) {
      return props2.indexOf(key) === -1;
    }).reduce(function(result, key) {
      return _objectSpread$1E(_objectSpread$1E({}, result), {}, _defineProperty$1$({}, key, obj[key]));
    }, {});
  };
  var mergeDeep = function mergeDeep2(target, source) {
    if (isObject(target) && isObject(source)) {
      keys(source).forEach(function(key) {
        if (isObject(source[key])) {
          if (!target[key] || !isObject(target[key])) {
            target[key] = source[key];
          }
          mergeDeep2(target[key], source[key]);
        } else {
          assign(target, _defineProperty$1$({}, key, source[key]));
        }
      });
    }
    return target;
  };
  var sortKeys = function sortKeys2(obj) {
    return keys(obj).sort().reduce(function(result, key) {
      return _objectSpread$1E(_objectSpread$1E({}, result), {}, _defineProperty$1$({}, key, obj[key]));
    }, {});
  };
  var readonlyDescriptor = function readonlyDescriptor2() {
    return {
      enumerable: true,
      configurable: false,
      writable: false
    };
  };
  function ownKeys$1D(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1D(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1D(Object(source), true).forEach(function(key) {
        _defineProperty$1_(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1D(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1_(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray$9(arr) {
    return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$9();
  }
  function _nonIterableSpread$9() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$b(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$b(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$b(o, minLen);
  }
  function _iterableToArray$9(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$9(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$b(arr);
  }
  function _arrayLikeToArray$b(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var cloneDeep = function cloneDeep2(obj) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : obj;
    if (isArray(obj)) {
      return obj.reduce(function(result, val) {
        return [].concat(_toConsumableArray$9(result), [cloneDeep2(val, val)]);
      }, []);
    }
    if (isPlainObject(obj)) {
      return keys(obj).reduce(function(result, key) {
        return _objectSpread$1D(_objectSpread$1D({}, result), {}, _defineProperty$1_({}, key, cloneDeep2(obj[key], obj[key])));
      }, {});
    }
    return defaultValue;
  };
  var identity = function identity2(x) {
    return x;
  };
  var getRaw = function getRaw2(obj, path) {
    var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    path = isArray(path) ? path.join(".") : path;
    if (!path || !isObject(obj)) {
      return defaultValue;
    }
    if (path in obj) {
      return obj[path];
    }
    path = String(path).replace(RX_ARRAY_NOTATION, ".$1");
    var steps = path.split(".").filter(identity);
    if (steps.length === 0) {
      return defaultValue;
    }
    return steps.every(function(step) {
      return isObject(obj) && step in obj && !isUndefinedOrNull(obj = obj[step]);
    }) ? obj : isNull(obj) ? null : defaultValue;
  };
  var get = function get2(obj, path) {
    var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    var value = getRaw(obj, path);
    return isUndefinedOrNull(value) ? defaultValue : value;
  };
  var getEnv = function getEnv2(key) {
    var fallback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var env = typeof process !== "undefined" && process ? process.env || {} : {};
    if (!key) {
      return env;
    }
    return env[key] || fallback;
  };
  var getNoWarn = function getNoWarn2() {
    return getEnv("BOOTSTRAP_VUE_NO_WARN") || getEnv("NODE_ENV") === "production";
  };
  var warn = function warn2(message) {
    var source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!getNoWarn()) {
      console.warn("[BootstrapVue warn]: ".concat(source ? "".concat(source, " - ") : "").concat(message));
    }
  };
  var warnNotClient = function warnNotClient2(source) {
    if (IS_BROWSER) {
      return false;
    } else {
      warn("".concat(source, ": Can not be called during SSR."));
      return true;
    }
  };
  var warnNoPromiseSupport = function warnNoPromiseSupport2(source) {
    if (HAS_PROMISE_SUPPORT) {
      return false;
    } else {
      warn("".concat(source, ": Requires Promise support."));
      return true;
    }
  };
  var warnNoMutationObserverSupport = function warnNoMutationObserverSupport2(source) {
    if (HAS_MUTATION_OBSERVER_SUPPORT) {
      return false;
    } else {
      warn("".concat(source, ": Requires MutationObserver support."));
      return true;
    }
  };
  function _classCallCheck$6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$6(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$6(Constructor, protoProps, staticProps) {
    _defineProperties$6(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var BvConfig = /* @__PURE__ */ function() {
    function BvConfig2() {
      _classCallCheck$6(this, BvConfig2);
      this.$_config = {};
    }
    _createClass$6(BvConfig2, [{
      key: "setConfig",
      value: function setConfig2() {
        var _this = this;
        var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!isPlainObject(config)) {
          return;
        }
        var configKeys = getOwnPropertyNames(config);
        configKeys.forEach(function(key) {
          var subConfig = config[key];
          if (key === "breakpoints") {
            if (!isArray(subConfig) || subConfig.length < 2 || subConfig.some(function(b) {
              return !isString(b) || b.length === 0;
            })) {
              warn('"breakpoints" must be an array of at least 2 breakpoint names', NAME$2);
            } else {
              _this.$_config[key] = cloneDeep(subConfig);
            }
          } else if (isPlainObject(subConfig)) {
            _this.$_config[key] = getOwnPropertyNames(subConfig).reduce(function(config2, prop2) {
              if (!isUndefined(subConfig[prop2])) {
                config2[prop2] = cloneDeep(subConfig[prop2]);
              }
              return config2;
            }, _this.$_config[key] || {});
          }
        });
      }
      // Clear the config
    }, {
      key: "resetConfig",
      value: function resetConfig() {
        this.$_config = {};
      }
      // Returns a deep copy of the user config
    }, {
      key: "getConfig",
      value: function getConfig() {
        return cloneDeep(this.$_config);
      }
      // Returns a deep copy of the config value
    }, {
      key: "getConfigValue",
      value: function getConfigValue2(key) {
        var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
        return cloneDeep(getRaw(this.$_config, key, defaultValue));
      }
    }]);
    return BvConfig2;
  }();
  var setConfig = function setConfig2() {
    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var Vue$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Vue2;
    Vue$1.prototype[PROP_NAME$2] = Vue2.prototype[PROP_NAME$2] = Vue$1.prototype[PROP_NAME$2] || Vue2.prototype[PROP_NAME$2] || new BvConfig();
    Vue$1.prototype[PROP_NAME$2].setConfig(config);
  };
  function ownKeys$1C(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1C(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1C(Object(source), true).forEach(function(key) {
        _defineProperty$1Z(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1C(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1Z(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var checkMultipleVue = function() {
    var checkMultipleVueWarned = false;
    var MULTIPLE_VUE_WARNING = ["Multiple instances of Vue detected!", "You may need to set up an alias for Vue in your bundler config.", "See: https://bootstrap-vue.org/docs#using-module-bundlers"].join("\n");
    return function(Vue$1) {
      if (!checkMultipleVueWarned && Vue2 !== Vue$1 && !IS_JSDOM) {
        warn(MULTIPLE_VUE_WARNING);
      }
      checkMultipleVueWarned = true;
    };
  }();
  var installFactory = function installFactory2() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, components = _ref.components, directives = _ref.directives, plugins = _ref.plugins;
    var install2 = function install3(Vue3) {
      var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (install3.installed) {
        return;
      }
      install3.installed = true;
      checkMultipleVue(Vue3);
      setConfig(config, Vue3);
      registerComponents(Vue3, components);
      registerDirectives(Vue3, directives);
      registerPlugins(Vue3, plugins);
    };
    install2.installed = false;
    return install2;
  };
  var pluginFactory = function pluginFactory2() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var extend2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _objectSpread$1C(_objectSpread$1C({}, extend2), {}, {
      install: installFactory(options)
    });
  };
  var registerPlugins = function registerPlugins2(Vue3) {
    var plugins = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var plugin2 in plugins) {
      if (plugin2 && plugins[plugin2]) {
        Vue3.use(plugins[plugin2]);
      }
    }
  };
  var registerComponent = function registerComponent2(Vue3, name, def) {
    if (Vue3 && name && def) {
      Vue3.component(name, def);
    }
  };
  var registerComponents = function registerComponents2(Vue3) {
    var components = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var component in components) {
      registerComponent(Vue3, component, components[component]);
    }
  };
  var registerDirective = function registerDirective2(Vue3, name, def) {
    if (Vue3 && name && def) {
      Vue3.directive(name.replace(/^VB/, "B"), def);
    }
  };
  var registerDirectives = function registerDirectives2(Vue3) {
    var directives = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var directive2 in directives) {
      registerDirective(Vue3, directive2, directives[directive2]);
    }
  };
  var NAME_ALERT = "BAlert";
  var NAME_ASPECT = "BAspect";
  var NAME_AVATAR = "BAvatar";
  var NAME_AVATAR_GROUP = "BAvatarGroup";
  var NAME_BADGE = "BBadge";
  var NAME_BREADCRUMB = "BBreadcrumb";
  var NAME_BREADCRUMB_ITEM = "BBreadcrumbItem";
  var NAME_BREADCRUMB_LINK = "BBreadcrumbLink";
  var NAME_BUTTON = "BButton";
  var NAME_BUTTON_CLOSE = "BButtonClose";
  var NAME_BUTTON_GROUP = "BButtonGroup";
  var NAME_BUTTON_TOOLBAR = "BButtonToolbar";
  var NAME_CALENDAR = "BCalendar";
  var NAME_CARD = "BCard";
  var NAME_CARD_BODY = "BCardBody";
  var NAME_CARD_FOOTER = "BCardFooter";
  var NAME_CARD_GROUP = "BCardGroup";
  var NAME_CARD_HEADER = "BCardHeader";
  var NAME_CARD_IMG = "BCardImg";
  var NAME_CARD_IMG_LAZY = "BCardImgLazy";
  var NAME_CARD_SUB_TITLE = "BCardSubTitle";
  var NAME_CARD_TEXT = "BCardText";
  var NAME_CARD_TITLE = "BCardTitle";
  var NAME_CAROUSEL = "BCarousel";
  var NAME_CAROUSEL_SLIDE = "BCarouselSlide";
  var NAME_COL = "BCol";
  var NAME_COLLAPSE = "BCollapse";
  var NAME_CONTAINER = "BContainer";
  var NAME_DROPDOWN = "BDropdown";
  var NAME_DROPDOWN_DIVIDER = "BDropdownDivider";
  var NAME_DROPDOWN_FORM = "BDropdownForm";
  var NAME_DROPDOWN_GROUP = "BDropdownGroup";
  var NAME_DROPDOWN_HEADER = "BDropdownHeader";
  var NAME_DROPDOWN_ITEM = "BDropdownItem";
  var NAME_DROPDOWN_ITEM_BUTTON = "BDropdownItemButton";
  var NAME_DROPDOWN_TEXT = "BDropdownText";
  var NAME_EMBED = "BEmbed";
  var NAME_FORM = "BForm";
  var NAME_FORM_CHECKBOX = "BFormCheckbox";
  var NAME_FORM_CHECKBOX_GROUP = "BFormCheckboxGroup";
  var NAME_FORM_DATALIST = "BFormDatalist";
  var NAME_FORM_DATEPICKER = "BFormDatepicker";
  var NAME_FORM_FILE = "BFormFile";
  var NAME_FORM_GROUP = "BFormGroup";
  var NAME_FORM_INPUT = "BFormInput";
  var NAME_FORM_INVALID_FEEDBACK = "BFormInvalidFeedback";
  var NAME_FORM_RADIO = "BFormRadio";
  var NAME_FORM_RADIO_GROUP = "BFormRadioGroup";
  var NAME_FORM_RATING = "BFormRating";
  var NAME_FORM_ROW = "BFormRow";
  var NAME_FORM_SELECT = "BFormSelect";
  var NAME_FORM_SELECT_OPTION = "BFormSelectOption";
  var NAME_FORM_SELECT_OPTION_GROUP = "BFormSelectOptionGroup";
  var NAME_FORM_SPINBUTTON = "BFormSpinbutton";
  var NAME_FORM_TAG = "BFormTag";
  var NAME_FORM_TAGS = "BFormTags";
  var NAME_FORM_TEXT = "BFormText";
  var NAME_FORM_TEXTAREA = "BFormTextarea";
  var NAME_FORM_TIMEPICKER = "BFormTimepicker";
  var NAME_FORM_VALID_FEEDBACK = "BFormValidFeedback";
  var NAME_ICON = "BIcon";
  var NAME_ICON_BASE = "BIconBase";
  var NAME_IMG = "BImg";
  var NAME_IMG_LAZY = "BImgLazy";
  var NAME_INPUT_GROUP = "BInputGroup";
  var NAME_INPUT_GROUP_ADDON = "BInputGroupAddon";
  var NAME_INPUT_GROUP_APPEND = "BInputGroupAppend";
  var NAME_INPUT_GROUP_PREPEND = "BInputGroupPrepend";
  var NAME_INPUT_GROUP_TEXT = "BInputGroupText";
  var NAME_JUMBOTRON = "BJumbotron";
  var NAME_LINK = "BLink";
  var NAME_LIST_GROUP = "BListGroup";
  var NAME_LIST_GROUP_ITEM = "BListGroupItem";
  var NAME_MEDIA = "BMedia";
  var NAME_MEDIA_ASIDE = "BMediaAside";
  var NAME_MEDIA_BODY = "BMediaBody";
  var NAME_MODAL = "BModal";
  var NAME_MSG_BOX = "BMsgBox";
  var NAME_NAV = "BNav";
  var NAME_NAVBAR = "BNavbar";
  var NAME_NAVBAR_BRAND = "BNavbarBrand";
  var NAME_NAVBAR_NAV = "BNavbarNav";
  var NAME_NAVBAR_TOGGLE = "BNavbarToggle";
  var NAME_NAV_FORM = "BNavForm";
  var NAME_NAV_ITEM = "BNavItem";
  var NAME_NAV_ITEM_DROPDOWN = "BNavItemDropdown";
  var NAME_NAV_TEXT = "BNavText";
  var NAME_OVERLAY = "BOverlay";
  var NAME_PAGINATION = "BPagination";
  var NAME_PAGINATION_NAV = "BPaginationNav";
  var NAME_POPOVER = "BPopover";
  var NAME_PROGRESS = "BProgress";
  var NAME_PROGRESS_BAR = "BProgressBar";
  var NAME_ROW = "BRow";
  var NAME_SIDEBAR = "BSidebar";
  var NAME_SKELETON = "BSkeleton";
  var NAME_SKELETON_ICON = "BSkeletonIcon";
  var NAME_SKELETON_IMG = "BSkeletonImg";
  var NAME_SKELETON_TABLE = "BSkeletonTable";
  var NAME_SKELETON_WRAPPER = "BSkeletonWrapper";
  var NAME_SPINNER = "BSpinner";
  var NAME_TAB = "BTab";
  var NAME_TABLE = "BTable";
  var NAME_TABLE_CELL = "BTableCell";
  var NAME_TABLE_LITE = "BTableLite";
  var NAME_TABLE_SIMPLE = "BTableSimple";
  var NAME_TABS = "BTabs";
  var NAME_TBODY = "BTbody";
  var NAME_TFOOT = "BTfoot";
  var NAME_TH = "BTh";
  var NAME_THEAD = "BThead";
  var NAME_TIME = "BTime";
  var NAME_TOAST = "BToast";
  var NAME_TOASTER = "BToaster";
  var NAME_TOOLTIP = "BTooltip";
  var NAME_TR = "BTr";
  var NAME_COLLAPSE_HELPER = "BVCollapse";
  var NAME_FORM_BUTTON_LABEL_CONTROL = "BVFormBtnLabelControl";
  var NAME_FORM_RATING_STAR = "BVFormRatingStar";
  var NAME_POPOVER_HELPER = "BVPopover";
  var NAME_POPOVER_TEMPLATE = "BVPopoverTemplate";
  var NAME_POPPER = "BVPopper";
  var NAME_TAB_BUTTON_HELPER = "BVTabButton";
  var NAME_TOAST_POP = "BVToastPop";
  var NAME_TOOLTIP_HELPER = "BVTooltip";
  var NAME_TOOLTIP_TEMPLATE = "BVTooltipTemplate";
  var NAME_TRANSITION = "BVTransition";
  var NAME_TRANSPORTER = "BVTransporter";
  var NAME_TRANSPORTER_TARGET = "BVTransporterTarget";
  var EVENT_NAME_ACTIVATE_TAB = "activate-tab";
  var EVENT_NAME_BLUR = "blur";
  var EVENT_NAME_CANCEL = "cancel";
  var EVENT_NAME_CHANGE = "change";
  var EVENT_NAME_CHANGED = "changed";
  var EVENT_NAME_CLICK = "click";
  var EVENT_NAME_CLOSE = "close";
  var EVENT_NAME_CONTEXT = "context";
  var EVENT_NAME_CONTEXT_CHANGED = "context-changed";
  var EVENT_NAME_DESTROYED = "destroyed";
  var EVENT_NAME_DISABLE = "disable";
  var EVENT_NAME_DISABLED = "disabled";
  var EVENT_NAME_DISMISSED = "dismissed";
  var EVENT_NAME_DISMISS_COUNT_DOWN = "dismiss-count-down";
  var EVENT_NAME_ENABLE = "enable";
  var EVENT_NAME_ENABLED = "enabled";
  var EVENT_NAME_FILTERED = "filtered";
  var EVENT_NAME_FIRST = "first";
  var EVENT_NAME_FOCUS = "focus";
  var EVENT_NAME_FOCUSIN = "focusin";
  var EVENT_NAME_FOCUSOUT = "focusout";
  var EVENT_NAME_HEAD_CLICKED = "head-clicked";
  var EVENT_NAME_HIDDEN = "hidden";
  var EVENT_NAME_HIDE = "hide";
  var EVENT_NAME_IMG_ERROR = "img-error";
  var EVENT_NAME_INPUT = "input";
  var EVENT_NAME_LAST = "last";
  var EVENT_NAME_MOUSEENTER = "mouseenter";
  var EVENT_NAME_MOUSELEAVE = "mouseleave";
  var EVENT_NAME_NEXT = "next";
  var EVENT_NAME_OK = "ok";
  var EVENT_NAME_OPEN = "open";
  var EVENT_NAME_PAGE_CLICK = "page-click";
  var EVENT_NAME_PAUSED = "paused";
  var EVENT_NAME_PREV = "prev";
  var EVENT_NAME_REFRESH = "refresh";
  var EVENT_NAME_REFRESHED = "refreshed";
  var EVENT_NAME_REMOVE = "remove";
  var EVENT_NAME_ROW_CLICKED = "row-clicked";
  var EVENT_NAME_ROW_CONTEXTMENU = "row-contextmenu";
  var EVENT_NAME_ROW_DBLCLICKED = "row-dblclicked";
  var EVENT_NAME_ROW_HOVERED = "row-hovered";
  var EVENT_NAME_ROW_MIDDLE_CLICKED = "row-middle-clicked";
  var EVENT_NAME_ROW_SELECTED = "row-selected";
  var EVENT_NAME_ROW_UNHOVERED = "row-unhovered";
  var EVENT_NAME_SELECTED = "selected";
  var EVENT_NAME_SHOW = "show";
  var EVENT_NAME_SHOWN = "shown";
  var EVENT_NAME_SLIDING_END = "sliding-end";
  var EVENT_NAME_SLIDING_START = "sliding-start";
  var EVENT_NAME_SORT_CHANGED = "sort-changed";
  var EVENT_NAME_TAG_STATE = "tag-state";
  var EVENT_NAME_TOGGLE = "toggle";
  var EVENT_NAME_UNPAUSED = "unpaused";
  var EVENT_NAME_UPDATE = "update";
  var HOOK_EVENT_NAME_BEFORE_DESTROY = isVue3 ? "vnodeBeforeUnmount" : "hook:beforeDestroy";
  var HOOK_EVENT_NAME_DESTROYED = isVue3 ? "vNodeUnmounted" : "hook:destroyed";
  var MODEL_EVENT_NAME_PREFIX = "update:";
  var ROOT_EVENT_NAME_PREFIX = "bv";
  var ROOT_EVENT_NAME_SEPARATOR = "::";
  var EVENT_OPTIONS_PASSIVE = {
    passive: true
  };
  var EVENT_OPTIONS_NO_CAPTURE = {
    passive: true,
    capture: false
  };
  var PROP_TYPE_ANY = void 0;
  var PROP_TYPE_ARRAY = Array;
  var PROP_TYPE_BOOLEAN = Boolean;
  var PROP_TYPE_DATE = Date;
  var PROP_TYPE_FUNCTION = Function;
  var PROP_TYPE_NUMBER = Number;
  var PROP_TYPE_OBJECT = Object;
  var PROP_TYPE_REG_EXP = RegExp;
  var PROP_TYPE_STRING = String;
  var PROP_TYPE_ARRAY_FUNCTION = [PROP_TYPE_ARRAY, PROP_TYPE_FUNCTION];
  var PROP_TYPE_ARRAY_OBJECT = [PROP_TYPE_ARRAY, PROP_TYPE_OBJECT];
  var PROP_TYPE_ARRAY_OBJECT_STRING = [PROP_TYPE_ARRAY, PROP_TYPE_OBJECT, PROP_TYPE_STRING];
  var PROP_TYPE_ARRAY_STRING = [PROP_TYPE_ARRAY, PROP_TYPE_STRING];
  var PROP_TYPE_BOOLEAN_NUMBER = [PROP_TYPE_BOOLEAN, PROP_TYPE_NUMBER];
  var PROP_TYPE_BOOLEAN_NUMBER_STRING = [PROP_TYPE_BOOLEAN, PROP_TYPE_NUMBER, PROP_TYPE_STRING];
  var PROP_TYPE_BOOLEAN_STRING = [PROP_TYPE_BOOLEAN, PROP_TYPE_STRING];
  var PROP_TYPE_DATE_STRING = [PROP_TYPE_DATE, PROP_TYPE_STRING];
  var PROP_TYPE_FUNCTION_STRING = [PROP_TYPE_FUNCTION, PROP_TYPE_STRING];
  var PROP_TYPE_NUMBER_STRING = [PROP_TYPE_NUMBER, PROP_TYPE_STRING];
  var PROP_TYPE_NUMBER_OBJECT_STRING = [PROP_TYPE_NUMBER, PROP_TYPE_OBJECT, PROP_TYPE_STRING];
  var PROP_TYPE_OBJECT_FUNCTION = [PROP_TYPE_OBJECT, PROP_TYPE_FUNCTION];
  var PROP_TYPE_OBJECT_STRING = [PROP_TYPE_OBJECT, PROP_TYPE_STRING];
  var SLOT_NAME_ADD_BUTTON_TEXT = "add-button-text";
  var SLOT_NAME_APPEND = "append";
  var SLOT_NAME_ASIDE = "aside";
  var SLOT_NAME_BADGE = "badge";
  var SLOT_NAME_BOTTOM_ROW = "bottom-row";
  var SLOT_NAME_BUTTON_CONTENT = "button-content";
  var SLOT_NAME_CUSTOM_FOOT = "custom-foot";
  var SLOT_NAME_DECREMENT = "decrement";
  var SLOT_NAME_DEFAULT = "default";
  var SLOT_NAME_DESCRIPTION = "description";
  var SLOT_NAME_DISMISS = "dismiss";
  var SLOT_NAME_DROP_PLACEHOLDER = "drop-placeholder";
  var SLOT_NAME_ELLIPSIS_TEXT = "ellipsis-text";
  var SLOT_NAME_EMPTY = "empty";
  var SLOT_NAME_EMPTYFILTERED = "emptyfiltered";
  var SLOT_NAME_FILE_NAME = "file-name";
  var SLOT_NAME_FIRST = "first";
  var SLOT_NAME_FIRST_TEXT = "first-text";
  var SLOT_NAME_FOOTER = "footer";
  var SLOT_NAME_HEADER = "header";
  var SLOT_NAME_HEADER_CLOSE = "header-close";
  var SLOT_NAME_ICON_CLEAR = "icon-clear";
  var SLOT_NAME_ICON_EMPTY = "icon-empty";
  var SLOT_NAME_ICON_FULL = "icon-full";
  var SLOT_NAME_ICON_HALF = "icon-half";
  var SLOT_NAME_IMG = "img";
  var SLOT_NAME_INCREMENT = "increment";
  var SLOT_NAME_INVALID_FEEDBACK = "invalid-feedback";
  var SLOT_NAME_LABEL = "label";
  var SLOT_NAME_LAST_TEXT = "last-text";
  var SLOT_NAME_LEAD = "lead";
  var SLOT_NAME_LOADING = "loading";
  var SLOT_NAME_MODAL_BACKDROP = "modal-backdrop";
  var SLOT_NAME_MODAL_CANCEL = "modal-cancel";
  var SLOT_NAME_MODAL_FOOTER = "modal-footer";
  var SLOT_NAME_MODAL_HEADER = "modal-header";
  var SLOT_NAME_MODAL_HEADER_CLOSE = "modal-header-close";
  var SLOT_NAME_MODAL_OK = "modal-ok";
  var SLOT_NAME_MODAL_TITLE = "modal-title";
  var SLOT_NAME_NAV_NEXT_DECADE = "nav-next-decade";
  var SLOT_NAME_NAV_NEXT_MONTH = "nav-next-month";
  var SLOT_NAME_NAV_NEXT_YEAR = "nav-next-year";
  var SLOT_NAME_NAV_PEV_DECADE = "nav-prev-decade";
  var SLOT_NAME_NAV_PEV_MONTH = "nav-prev-month";
  var SLOT_NAME_NAV_PEV_YEAR = "nav-prev-year";
  var SLOT_NAME_NAV_THIS_MONTH = "nav-this-month";
  var SLOT_NAME_NEXT_TEXT = "next-text";
  var SLOT_NAME_OVERLAY = "overlay";
  var SLOT_NAME_PAGE = "page";
  var SLOT_NAME_PLACEHOLDER = "placeholder";
  var SLOT_NAME_PREPEND = "prepend";
  var SLOT_NAME_PREV_TEXT = "prev-text";
  var SLOT_NAME_ROW_DETAILS = "row-details";
  var SLOT_NAME_TABLE_BUSY = "table-busy";
  var SLOT_NAME_TABLE_CAPTION = "table-caption";
  var SLOT_NAME_TABLE_COLGROUP = "table-colgroup";
  var SLOT_NAME_TABS_END = "tabs-end";
  var SLOT_NAME_TABS_START = "tabs-start";
  var SLOT_NAME_TEXT = "text";
  var SLOT_NAME_THEAD_TOP = "thead-top";
  var SLOT_NAME_TITLE = "title";
  var SLOT_NAME_TOAST_TITLE = "toast-title";
  var SLOT_NAME_TOP_ROW = "top-row";
  var SLOT_NAME_VALID_FEEDBACK = "valid-feedback";
  var from = function from2() {
    return Array.from.apply(Array, arguments);
  };
  var arrayIncludes = function arrayIncludes2(array, value) {
    return array.indexOf(value) !== -1;
  };
  var concat = function concat2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return Array.prototype.concat.apply([], args);
  };
  var createArray = function createArray2(length, fillFn) {
    var mapFn = isFunction$1(fillFn) ? fillFn : function() {
      return fillFn;
    };
    return Array.apply(null, {
      length
    }).map(mapFn);
  };
  var flatten = function flatten2(array) {
    return array.reduce(function(result, item) {
      return concat(result, item);
    }, []);
  };
  var flattenDeep = function flattenDeep2(array) {
    return array.reduce(function(result, item) {
      return concat(result, Array.isArray(item) ? flattenDeep2(item) : item);
    }, []);
  };
  var hasNormalizedSlot = function hasNormalizedSlot2(names) {
    var $scopedSlots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var $slots = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    names = concat(names).filter(identity);
    return names.some(function(name) {
      return $scopedSlots[name] || $slots[name];
    });
  };
  var normalizeSlot = function normalizeSlot2(names) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var $scopedSlots = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var $slots = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    names = concat(names).filter(identity);
    var slot;
    for (var i = 0; i < names.length && !slot; i++) {
      var name = names[i];
      slot = $scopedSlots[name] || $slots[name];
    }
    return isFunction$1(slot) ? slot(scope) : slot;
  };
  var normalizeSlotMixin = extend({
    methods: {
      // Returns `true` if the either a `$scopedSlot` or `$slot` exists with the specified name
      // `name` can be a string name or an array of names
      hasNormalizedSlot: function hasNormalizedSlot$1() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SLOT_NAME_DEFAULT;
        var scopedSlots = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.$scopedSlots;
        var slots = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.$slots;
        return hasNormalizedSlot(name, scopedSlots, slots);
      },
      // Returns an array of rendered VNodes if slot found, otherwise `undefined`
      // `name` can be a string name or an array of names
      normalizeSlot: function normalizeSlot$1() {
        var name = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : SLOT_NAME_DEFAULT;
        var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var scopedSlots = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.$scopedSlots;
        var slots = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : this.$slots;
        var vNodes = normalizeSlot(name, scope, scopedSlots, slots);
        return vNodes ? concat(vNodes) : vNodes;
      }
    }
  });
  var toInteger = function toInteger2(value) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    var integer = parseInt(value, 10);
    return isNaN(integer) ? defaultValue : integer;
  };
  var toFloat = function toFloat2(value) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
    var float = parseFloat(value);
    return isNaN(float) ? defaultValue : float;
  };
  var toFixed = function toFixed2(val, precision) {
    return toFloat(val).toFixed(toInteger(precision, 0));
  };
  var kebabCase = function kebabCase2(str) {
    return str.replace(RX_HYPHENATE, "-$1").toLowerCase();
  };
  var pascalCase = function pascalCase2(str) {
    str = kebabCase(str).replace(RX_UN_KEBAB, function(_, c) {
      return c ? c.toUpperCase() : "";
    });
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  var startCase = function startCase2(str) {
    return str.replace(RX_UNDERSCORE, " ").replace(RX_LOWER_UPPER, function(str2, $1, $2) {
      return $1 + " " + $2;
    }).replace(RX_START_SPACE_WORD, function(str2, $1, $2) {
      return $1 + $2.toUpperCase();
    });
  };
  var lowerFirst = function lowerFirst2(str) {
    str = isString(str) ? str.trim() : String(str);
    return str.charAt(0).toLowerCase() + str.slice(1);
  };
  var upperFirst = function upperFirst2(str) {
    str = isString(str) ? str.trim() : String(str);
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  var escapeRegExp = function escapeRegExp2(str) {
    return str.replace(RX_REGEXP_REPLACE, "\\$&");
  };
  var toString = function toString2(val) {
    var spaces = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    return isUndefinedOrNull(val) ? "" : isArray(val) || isPlainObject(val) && val.toString === Object.prototype.toString ? JSON.stringify(val, null, spaces) : String(val);
  };
  var trimLeft = function trimLeft2(str) {
    return toString(str).replace(RX_TRIM_LEFT, "");
  };
  var trim = function trim2(str) {
    return toString(str).trim();
  };
  var lowerCase = function lowerCase2(str) {
    return toString(str).toLowerCase();
  };
  var ELEMENT_PROTO = Element.prototype;
  var TABABLE_SELECTOR = ["button", "[href]:not(.disabled)", "input", "select", "textarea", "[tabindex]", "[contenteditable]"].map(function(s2) {
    return "".concat(s2, ":not(:disabled):not([disabled])");
  }).join(", ");
  var matchesEl = ELEMENT_PROTO.matches || ELEMENT_PROTO.msMatchesSelector || ELEMENT_PROTO.webkitMatchesSelector;
  var closestEl = ELEMENT_PROTO.closest || function(sel) {
    var el = this;
    do {
      if (matches(el, sel)) {
        return el;
      }
      el = el.parentElement || el.parentNode;
    } while (!isNull(el) && el.nodeType === Node.ELEMENT_NODE);
    return null;
  };
  var requestAF = (WINDOW.requestAnimationFrame || WINDOW.webkitRequestAnimationFrame || WINDOW.mozRequestAnimationFrame || WINDOW.msRequestAnimationFrame || WINDOW.oRequestAnimationFrame || // Fallback, but not a true polyfill
  // Only needed for Opera Mini
  /* istanbul ignore next */
  function(cb) {
    return setTimeout(cb, 16);
  }).bind(WINDOW);
  var MutationObs = WINDOW.MutationObserver || WINDOW.WebKitMutationObserver || WINDOW.MozMutationObserver || null;
  var removeNode = function removeNode2(el) {
    return el && el.parentNode && el.parentNode.removeChild(el);
  };
  var isElement = function isElement2(el) {
    return !!(el && el.nodeType === Node.ELEMENT_NODE);
  };
  var getActiveElement = function getActiveElement2() {
    var excludes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var activeElement = DOCUMENT.activeElement;
    return activeElement && !excludes.some(function(el) {
      return el === activeElement;
    }) ? activeElement : null;
  };
  var isTag = function isTag2(tag, name) {
    return toString(tag).toLowerCase() === toString(name).toLowerCase();
  };
  var isActiveElement = function isActiveElement2(el) {
    return isElement(el) && el === getActiveElement();
  };
  var isVisible = function isVisible2(el) {
    if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {
      return false;
    }
    if (getStyle(el, "display") === "none") {
      return false;
    }
    var bcr = getBCR(el);
    return !!(bcr && bcr.height > 0 && bcr.width > 0);
  };
  var isDisabled = function isDisabled2(el) {
    return !isElement(el) || el.disabled || hasAttr(el, "disabled") || hasClass(el, "disabled");
  };
  var reflow = function reflow2(el) {
    return isElement(el) && el.offsetHeight;
  };
  var selectAll = function selectAll2(selector, root) {
    return from((isElement(root) ? root : DOCUMENT).querySelectorAll(selector));
  };
  var select = function select2(selector, root) {
    return (isElement(root) ? root : DOCUMENT).querySelector(selector) || null;
  };
  var matches = function matches2(el, selector) {
    return isElement(el) ? matchesEl.call(el, selector) : false;
  };
  var closest = function closest2(selector, root) {
    var includeRoot = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    if (!isElement(root)) {
      return null;
    }
    var el = closestEl.call(root, selector);
    return includeRoot ? el : el === root ? null : el;
  };
  var contains = function contains2(parent, child) {
    return parent && isFunction$1(parent.contains) ? parent.contains(child) : false;
  };
  var getById = function getById2(id) {
    return DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null;
  };
  var addClass = function addClass2(el, className) {
    if (className && isElement(el) && el.classList) {
      el.classList.add(className);
    }
  };
  var removeClass = function removeClass2(el, className) {
    if (className && isElement(el) && el.classList) {
      el.classList.remove(className);
    }
  };
  var hasClass = function hasClass2(el, className) {
    if (className && isElement(el) && el.classList) {
      return el.classList.contains(className);
    }
    return false;
  };
  var setAttr = function setAttr2(el, attr, value) {
    if (attr && isElement(el)) {
      el.setAttribute(attr, value);
    }
  };
  var removeAttr = function removeAttr2(el, attr) {
    if (attr && isElement(el)) {
      el.removeAttribute(attr);
    }
  };
  var getAttr = function getAttr2(el, attr) {
    return attr && isElement(el) ? el.getAttribute(attr) : null;
  };
  var hasAttr = function hasAttr2(el, attr) {
    return attr && isElement(el) ? el.hasAttribute(attr) : null;
  };
  var setStyle = function setStyle2(el, prop2, value) {
    if (prop2 && isElement(el)) {
      el.style[prop2] = value;
    }
  };
  var removeStyle = function removeStyle2(el, prop2) {
    if (prop2 && isElement(el)) {
      el.style[prop2] = "";
    }
  };
  var getStyle = function getStyle2(el, prop2) {
    return prop2 && isElement(el) ? el.style[prop2] || null : null;
  };
  var getBCR = function getBCR2(el) {
    return isElement(el) ? el.getBoundingClientRect() : null;
  };
  var getCS = function getCS2(el) {
    var getComputedStyle2 = WINDOW.getComputedStyle;
    return getComputedStyle2 && isElement(el) ? getComputedStyle2(el) : {};
  };
  var getSel = function getSel2() {
    var getSelection = WINDOW.getSelection;
    return getSelection ? WINDOW.getSelection() : null;
  };
  var offset$1 = function offset2(el) {
    var _offset = {
      top: 0,
      left: 0
    };
    if (!isElement(el) || el.getClientRects().length === 0) {
      return _offset;
    }
    var bcr = getBCR(el);
    if (bcr) {
      var win = el.ownerDocument.defaultView;
      _offset.top = bcr.top + win.pageYOffset;
      _offset.left = bcr.left + win.pageXOffset;
    }
    return _offset;
  };
  var position = function position2(el) {
    var _offset = {
      top: 0,
      left: 0
    };
    if (!isElement(el)) {
      return _offset;
    }
    var parentOffset = {
      top: 0,
      left: 0
    };
    var elStyles = getCS(el);
    if (elStyles.position === "fixed") {
      _offset = getBCR(el) || _offset;
    } else {
      _offset = offset$1(el);
      var doc = el.ownerDocument;
      var offsetParent = el.offsetParent || doc.documentElement;
      while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && getCS(offsetParent).position === "static") {
        offsetParent = offsetParent.parentNode;
      }
      if (offsetParent && offsetParent !== el && offsetParent.nodeType === Node.ELEMENT_NODE) {
        parentOffset = offset$1(offsetParent);
        var offsetParentStyles = getCS(offsetParent);
        parentOffset.top += toFloat(offsetParentStyles.borderTopWidth, 0);
        parentOffset.left += toFloat(offsetParentStyles.borderLeftWidth, 0);
      }
    }
    return {
      top: _offset.top - parentOffset.top - toFloat(elStyles.marginTop, 0),
      left: _offset.left - parentOffset.left - toFloat(elStyles.marginLeft, 0)
    };
  };
  var getTabables = function getTabables2() {
    var rootEl = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    return selectAll(TABABLE_SELECTOR, rootEl).filter(isVisible).filter(function(el) {
      return el.tabIndex > -1 && !el.disabled;
    });
  };
  var attemptFocus = function attemptFocus2(el) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    try {
      el.focus(options);
    } catch (_unused) {
    }
    return isActiveElement(el);
  };
  var attemptBlur = function attemptBlur2(el) {
    try {
      el.blur();
    } catch (_unused2) {
    }
    return !isActiveElement(el);
  };
  var memoize = function memoize2(fn) {
    var cache = create(null);
    return function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var argsKey = JSON.stringify(args);
      return cache[argsKey] = cache[argsKey] || fn.apply(null, args);
    };
  };
  var VueProto = Vue2.prototype;
  var getConfigValue = function getConfigValue2(key) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    var bvConfig = VueProto[PROP_NAME$2];
    return bvConfig ? bvConfig.getConfigValue(key, defaultValue) : cloneDeep(defaultValue);
  };
  var getComponentConfig = function getComponentConfig2(key) {
    var propKey = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    return propKey ? getConfigValue("".concat(key, ".").concat(propKey), defaultValue) : getConfigValue(key, {});
  };
  var getBreakpoints = function getBreakpoints2() {
    return getConfigValue("breakpoints", DEFAULT_BREAKPOINT);
  };
  var _getBreakpointsCached = memoize(function() {
    return getBreakpoints();
  });
  var getBreakpointsCached = function getBreakpointsCached2() {
    return cloneDeep(_getBreakpointsCached());
  };
  var getBreakpointsUpCached = memoize(function() {
    var breakpoints = getBreakpointsCached();
    breakpoints[0] = "";
    return breakpoints;
  });
  function ownKeys$1B(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1B(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1B(Object(source), true).forEach(function(key) {
        _defineProperty$1Y(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1B(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1Y(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var prefixPropName = function prefixPropName2(prefix, value) {
    return prefix + upperFirst(value);
  };
  var unprefixPropName = function unprefixPropName2(prefix, value) {
    return lowerFirst(value.replace(prefix, ""));
  };
  var suffixPropName = function suffixPropName2(suffix, value) {
    return value + (suffix ? upperFirst(suffix) : "");
  };
  var makeProp = function makeProp2() {
    var type = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : PROP_TYPE_ANY;
    var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    var requiredOrValidator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    var validator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : void 0;
    var required = requiredOrValidator === true;
    validator = required ? validator : requiredOrValidator;
    return _objectSpread$1B(_objectSpread$1B(_objectSpread$1B({}, type ? {
      type
    } : {}), required ? {
      required
    } : isUndefined(value) ? {} : {
      default: isObject(value) ? function() {
        return value;
      } : value
    }), isUndefined(validator) ? {} : {
      validator
    });
  };
  var copyProps = function copyProps2(props2) {
    var transformFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : identity;
    if (isArray(props2)) {
      return props2.map(transformFn);
    }
    var copied = {};
    for (var prop2 in props2) {
      if (hasOwnProperty(props2, prop2)) {
        copied[transformFn(prop2)] = isObject(props2[prop2]) ? clone(props2[prop2]) : props2[prop2];
      }
    }
    return copied;
  };
  var pluckProps = function pluckProps2(keysToPluck, objToPluck) {
    var transformFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : identity;
    return (isArray(keysToPluck) ? keysToPluck.slice() : keys(keysToPluck)).reduce(function(memo, prop2) {
      memo[transformFn(prop2)] = objToPluck[prop2];
      return memo;
    }, {});
  };
  var makePropConfigurable = function makePropConfigurable2(prop2, key, componentKey) {
    return _objectSpread$1B(_objectSpread$1B({}, cloneDeep(prop2)), {}, {
      default: function bvConfigurablePropDefault() {
        var value = getComponentConfig(componentKey, key, prop2.default);
        return isFunction$1(value) ? value() : value;
      }
    });
  };
  var makePropsConfigurable = function makePropsConfigurable2(props2, componentKey) {
    return keys(props2).reduce(function(result, key) {
      return _objectSpread$1B(_objectSpread$1B({}, result), {}, _defineProperty$1Y({}, key, makePropConfigurable(props2[key], key, componentKey)));
    }, {});
  };
  var configurablePropDefaultFnName = makePropConfigurable({}, "", "").default.name;
  var hasPropFunction = function hasPropFunction2(fn) {
    return isFunction$1(fn) && fn.name && fn.name !== configurablePropDefaultFnName;
  };
  function _defineProperty$1X(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var makeModelMixin = function makeModelMixin2(prop2) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$type = _ref.type, type = _ref$type === void 0 ? PROP_TYPE_ANY : _ref$type, _ref$defaultValue = _ref.defaultValue, defaultValue = _ref$defaultValue === void 0 ? void 0 : _ref$defaultValue, _ref$validator = _ref.validator, validator = _ref$validator === void 0 ? void 0 : _ref$validator, _ref$event = _ref.event, event2 = _ref$event === void 0 ? EVENT_NAME_INPUT : _ref$event;
    var props2 = _defineProperty$1X({}, prop2, makeProp(type, defaultValue, validator));
    var mixin2 = extend({
      model: {
        prop: prop2,
        event: event2
      },
      props: props2
    });
    return {
      mixin: mixin2,
      props: props2,
      prop: prop2,
      event: event2
    };
  };
  var parseEventOptions = function parseEventOptions2(options) {
    if (HAS_PASSIVE_EVENT_SUPPORT) {
      return isObject(options) ? options : {
        capture: !!options || false
      };
    } else {
      return !!(isObject(options) ? options.capture : options);
    }
  };
  var eventOn = function eventOn2(el, eventName, handler, options) {
    if (el && el.addEventListener) {
      el.addEventListener(eventName, handler, parseEventOptions(options));
    }
  };
  var eventOff = function eventOff2(el, eventName, handler, options) {
    if (el && el.removeEventListener) {
      el.removeEventListener(eventName, handler, parseEventOptions(options));
    }
  };
  var eventOnOff = function eventOnOff2(on) {
    var method = on ? eventOn : eventOff;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    method.apply(void 0, args);
  };
  var stopEvent = function stopEvent2(event2) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preventDefault = _ref.preventDefault, preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault, _ref$propagation = _ref.propagation, propagation = _ref$propagation === void 0 ? true : _ref$propagation, _ref$immediatePropaga = _ref.immediatePropagation, immediatePropagation = _ref$immediatePropaga === void 0 ? false : _ref$immediatePropaga;
    if (preventDefault) {
      event2.preventDefault();
    }
    if (propagation) {
      event2.stopPropagation();
    }
    if (immediatePropagation) {
      event2.stopImmediatePropagation();
    }
  };
  var getBaseEventName = function getBaseEventName2(value) {
    return kebabCase(value.replace(RX_BV_PREFIX, ""));
  };
  var getRootEventName = function getRootEventName2(name, eventName) {
    return [ROOT_EVENT_NAME_PREFIX, getBaseEventName(name), eventName].join(ROOT_EVENT_NAME_SEPARATOR);
  };
  var getRootActionEventName = function getRootActionEventName2(name, actionName) {
    return [ROOT_EVENT_NAME_PREFIX, actionName, getBaseEventName(name)].join(ROOT_EVENT_NAME_SEPARATOR);
  };
  function _defineProperty$1W(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$2l = makePropsConfigurable({
    ariaLabel: makeProp(PROP_TYPE_STRING, "Close"),
    content: makeProp(PROP_TYPE_STRING, "&times;"),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    textVariant: makeProp(PROP_TYPE_STRING)
  }, NAME_BUTTON_CLOSE);
  var BButtonClose = /* @__PURE__ */ extend({
    name: NAME_BUTTON_CLOSE,
    functional: true,
    props: props$2l,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var $slots = slots();
      var $scopedSlots = scopedSlots || {};
      var componentData = {
        staticClass: "close",
        class: _defineProperty$1W({}, "text-".concat(props2.textVariant), props2.textVariant),
        attrs: {
          type: "button",
          disabled: props2.disabled,
          "aria-label": props2.ariaLabel ? String(props2.ariaLabel) : null
        },
        on: {
          click: function click(event2) {
            if (props2.disabled && isEvent(event2)) {
              stopEvent(event2);
            }
          }
        }
      };
      if (!hasNormalizedSlot(SLOT_NAME_DEFAULT, $scopedSlots, $slots)) {
        componentData.domProps = {
          innerHTML: props2.content
        };
      }
      return h("button", a(data, componentData), normalizeSlot(SLOT_NAME_DEFAULT, {}, $scopedSlots, $slots));
    }
  });
  function ownKeys$1A(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1A(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1A(Object(source), true).forEach(function(key) {
        _defineProperty$1V(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1A(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1V(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var NO_FADE_PROPS = {
    name: "",
    enterClass: "",
    enterActiveClass: "",
    enterToClass: "show",
    leaveClass: "show",
    leaveActiveClass: "",
    leaveToClass: ""
  };
  var FADE_PROPS = _objectSpread$1A(_objectSpread$1A({}, NO_FADE_PROPS), {}, {
    enterActiveClass: "fade",
    leaveActiveClass: "fade"
  });
  var props$2k = {
    // Has no effect if `trans-props` provided
    appear: makeProp(PROP_TYPE_BOOLEAN, false),
    // Can be overridden by user supplied `trans-props`
    mode: makeProp(PROP_TYPE_STRING),
    // Only applicable to the built in transition
    // Has no effect if `trans-props` provided
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    // For user supplied transitions (if needed)
    transProps: makeProp(PROP_TYPE_OBJECT)
  };
  var BVTransition = /* @__PURE__ */ extend({
    name: NAME_TRANSITION,
    functional: true,
    props: props$2k,
    render: function render(h, _ref) {
      var children = _ref.children, data = _ref.data, props2 = _ref.props;
      var transProps = props2.transProps;
      if (!isPlainObject(transProps)) {
        transProps = props2.noFade ? NO_FADE_PROPS : FADE_PROPS;
        if (props2.appear) {
          transProps = _objectSpread$1A(_objectSpread$1A({}, transProps), {}, {
            appear: true,
            appearClass: transProps.enterClass,
            appearActiveClass: transProps.enterActiveClass,
            appearToClass: transProps.enterToClass
          });
        }
      }
      transProps = _objectSpread$1A(_objectSpread$1A({
        mode: props2.mode
      }, transProps), {}, {
        // We always need `css` true
        css: true
      });
      var dataCopy = _objectSpread$1A({}, data);
      delete dataCopy.props;
      return h(
        "transition",
        // Any transition event listeners will get merged here
        a(dataCopy, {
          props: transProps
        }),
        children
      );
    }
  });
  var _watch$k;
  function ownKeys$1z(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1z(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1z(Object(source), true).forEach(function(key) {
        _defineProperty$1U(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1z(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1U(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$k = makeModelMixin("show", {
    type: PROP_TYPE_BOOLEAN_NUMBER_STRING,
    defaultValue: false
  }), modelMixin$j = _makeModelMixin$k.mixin, modelProps$j = _makeModelMixin$k.props, MODEL_PROP_NAME$j = _makeModelMixin$k.prop, MODEL_EVENT_NAME$j = _makeModelMixin$k.event;
  var parseCountDown = function parseCountDown2(show) {
    if (show === "" || isBoolean(show)) {
      return 0;
    }
    show = toInteger(show, 0);
    return show > 0 ? show : 0;
  };
  var parseShow = function parseShow2(show) {
    if (show === "" || show === true) {
      return true;
    }
    if (toInteger(show, 0) < 1) {
      return false;
    }
    return !!show;
  };
  var props$2j = makePropsConfigurable(sortKeys(_objectSpread$1z(_objectSpread$1z({}, modelProps$j), {}, {
    dismissLabel: makeProp(PROP_TYPE_STRING, "Close"),
    dismissible: makeProp(PROP_TYPE_BOOLEAN, false),
    fade: makeProp(PROP_TYPE_BOOLEAN, false),
    variant: makeProp(PROP_TYPE_STRING, "info")
  })), NAME_ALERT);
  var BAlert = /* @__PURE__ */ extend({
    name: NAME_ALERT,
    mixins: [modelMixin$j, normalizeSlotMixin],
    props: props$2j,
    data: function data() {
      return {
        countDown: 0,
        // If initially shown, we need to set these for SSR
        localShow: parseShow(this[MODEL_PROP_NAME$j])
      };
    },
    watch: (_watch$k = {}, _defineProperty$1U(_watch$k, MODEL_PROP_NAME$j, function(newValue) {
      this.countDown = parseCountDown(newValue);
      this.localShow = parseShow(newValue);
    }), _defineProperty$1U(_watch$k, "countDown", function countDown(newValue) {
      var _this = this;
      this.clearCountDownInterval();
      var show = this[MODEL_PROP_NAME$j];
      if (isNumeric$1(show)) {
        this.$emit(EVENT_NAME_DISMISS_COUNT_DOWN, newValue);
        if (show !== newValue) {
          this.$emit(MODEL_EVENT_NAME$j, newValue);
        }
        if (newValue > 0) {
          this.localShow = true;
          this.$_countDownTimeout = setTimeout(function() {
            _this.countDown--;
          }, 1e3);
        } else {
          this.$nextTick(function() {
            requestAF(function() {
              _this.localShow = false;
            });
          });
        }
      }
    }), _defineProperty$1U(_watch$k, "localShow", function localShow(newValue) {
      var show = this[MODEL_PROP_NAME$j];
      if (!newValue && (this.dismissible || isNumeric$1(show))) {
        this.$emit(EVENT_NAME_DISMISSED);
      }
      if (!isNumeric$1(show) && show !== newValue) {
        this.$emit(MODEL_EVENT_NAME$j, newValue);
      }
    }), _watch$k),
    created: function created() {
      this.$_filterTimer = null;
      var show = this[MODEL_PROP_NAME$j];
      this.countDown = parseCountDown(show);
      this.localShow = parseShow(show);
    },
    beforeDestroy: function beforeDestroy() {
      this.clearCountDownInterval();
    },
    methods: {
      dismiss: function dismiss() {
        this.clearCountDownInterval();
        this.countDown = 0;
        this.localShow = false;
      },
      clearCountDownInterval: function clearCountDownInterval() {
        clearTimeout(this.$_countDownTimeout);
        this.$_countDownTimeout = null;
      }
    },
    render: function render(h) {
      var $alert = h();
      if (this.localShow) {
        var dismissible = this.dismissible, variant = this.variant;
        var $dismissButton = h();
        if (dismissible) {
          $dismissButton = h(BButtonClose, {
            attrs: {
              "aria-label": this.dismissLabel
            },
            on: {
              click: this.dismiss
            }
          }, [this.normalizeSlot(SLOT_NAME_DISMISS)]);
        }
        $alert = h("div", {
          staticClass: "alert",
          class: _defineProperty$1U({
            "alert-dismissible": dismissible
          }, "alert-".concat(variant), variant),
          attrs: {
            role: "alert",
            "aria-live": "polite",
            "aria-atomic": true
          },
          key: this[COMPONENT_UID_KEY]
        }, [$dismissButton, this.normalizeSlot()]);
      }
      return h(BVTransition, {
        props: {
          noFade: !this.fade
        }
      }, [$alert]);
    }
  });
  var AlertPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BAlert
    }
  });
  var mathMin = Math.min;
  var mathMax = Math.max;
  var mathAbs = Math.abs;
  var mathCeil = Math.ceil;
  var mathFloor = Math.floor;
  var mathPow = Math.pow;
  var mathRound = Math.round;
  function _slicedToArray$2(arr, i) {
    return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$2();
  }
  function _nonIterableRest$2() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$a(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$a(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$a(o, minLen);
  }
  function _arrayLikeToArray$a(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit$2(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$2(arr) {
    if (Array.isArray(arr)) return arr;
  }
  var CLASS_NAME$3 = "b-aspect";
  var props$2i = makePropsConfigurable({
    // Accepts a number (i.e. `16 / 9`, `1`, `4 / 3`)
    // Or a string (i.e. '16/9', '16:9', '4:3' '1:1')
    aspect: makeProp(PROP_TYPE_NUMBER_STRING, "1:1"),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_ASPECT);
  var BAspect = /* @__PURE__ */ extend({
    name: NAME_ASPECT,
    mixins: [normalizeSlotMixin],
    props: props$2i,
    computed: {
      padding: function padding() {
        var aspect = this.aspect;
        var ratio = 1;
        if (RX_ASPECT.test(aspect)) {
          var _aspect$split$map = aspect.split(RX_ASPECT_SEPARATOR).map(function(v) {
            return toFloat(v) || 1;
          }), _aspect$split$map2 = _slicedToArray$2(_aspect$split$map, 2), width = _aspect$split$map2[0], height = _aspect$split$map2[1];
          ratio = width / height;
        } else {
          ratio = toFloat(aspect) || 1;
        }
        return "".concat(100 / mathAbs(ratio), "%");
      }
    },
    render: function render(h) {
      var $sizer = h("div", {
        staticClass: "".concat(CLASS_NAME$3, "-sizer flex-grow-1"),
        style: {
          paddingBottom: this.padding,
          height: 0
        }
      });
      var $content = h("div", {
        staticClass: "".concat(CLASS_NAME$3, "-content flex-grow-1 w-100 mw-100"),
        style: {
          marginLeft: "-100%"
        }
      }, this.normalizeSlot());
      return h(this.tag, {
        staticClass: "".concat(CLASS_NAME$3, " d-flex")
      }, [$sizer, $content]);
    }
  });
  var AspectPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BAspect
    }
  });
  function safeVueInstance(target) {
    if (!isVue3) {
      return target;
    }
    return new Proxy(target, {
      get: function get2(target2, prop2) {
        return prop2 in target2 ? target2[prop2] : void 0;
      }
    });
  }
  var ANCHOR_TAG = "a";
  var encodeReserveReplacer = function encodeReserveReplacer2(c) {
    return "%" + c.charCodeAt(0).toString(16);
  };
  var encode = function encode2(str) {
    return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ",");
  };
  var decode = decodeURIComponent;
  var stringifyQueryObj = function stringifyQueryObj2(obj) {
    if (!isPlainObject(obj)) {
      return "";
    }
    var query = keys(obj).map(function(key) {
      var value = obj[key];
      if (isUndefined(value)) {
        return "";
      } else if (isNull(value)) {
        return encode(key);
      } else if (isArray(value)) {
        return value.reduce(function(results, value2) {
          if (isNull(value2)) {
            results.push(encode(key));
          } else if (!isUndefined(value2)) {
            results.push(encode(key) + "=" + encode(value2));
          }
          return results;
        }, []).join("&");
      }
      return encode(key) + "=" + encode(value);
    }).filter(function(x) {
      return x.length > 0;
    }).join("&");
    return query ? "?".concat(query) : "";
  };
  var parseQuery = function parseQuery2(query) {
    var parsed = {};
    query = toString(query).trim().replace(RX_QUERY_START, "");
    if (!query) {
      return parsed;
    }
    query.split("&").forEach(function(param) {
      var parts = param.replace(RX_PLUS, " ").split("=");
      var key = decode(parts.shift());
      var value = parts.length > 0 ? decode(parts.join("=")) : null;
      if (isUndefined(parsed[key])) {
        parsed[key] = value;
      } else if (isArray(parsed[key])) {
        parsed[key].push(value);
      } else {
        parsed[key] = [parsed[key], value];
      }
    });
    return parsed;
  };
  var isLink$1 = function isLink2(props2) {
    return !!(props2.href || props2.to);
  };
  var isRouterLink = function isRouterLink2(tag) {
    return !!(tag && !isTag(tag, "a"));
  };
  var computeTag = function computeTag2(_ref, thisOrParent) {
    var to = _ref.to, disabled = _ref.disabled, routerComponentName = _ref.routerComponentName;
    var hasRouter = !!safeVueInstance(thisOrParent).$router;
    var hasNuxt = !!safeVueInstance(thisOrParent).$nuxt;
    if (!hasRouter || hasRouter && (disabled || !to)) {
      return ANCHOR_TAG;
    }
    return routerComponentName || (hasNuxt ? "nuxt-link" : "router-link");
  };
  var computeRel = function computeRel2() {
    var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, target = _ref2.target, rel = _ref2.rel;
    return target === "_blank" && isNull(rel) ? "noopener" : rel || null;
  };
  var computeHref = function computeHref2() {
    var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, href = _ref3.href, to = _ref3.to;
    var tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ANCHOR_TAG;
    var fallback = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "#";
    var toFallback = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "/";
    if (href) {
      return href;
    }
    if (isRouterLink(tag)) {
      return null;
    }
    if (isString(to)) {
      return to || toFallback;
    }
    if (isPlainObject(to) && (to.path || to.query || to.hash)) {
      var path = toString(to.path);
      var query = stringifyQueryObj(to.query);
      var hash = toString(to.hash);
      hash = !hash || hash.charAt(0) === "#" ? hash : "#".concat(hash);
      return "".concat(path).concat(query).concat(hash) || toFallback;
    }
    return fallback;
  };
  function _defineProperty$1T(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BASE_ATTRS = {
    viewBox: "0 0 16 16",
    width: "1em",
    height: "1em",
    focusable: "false",
    role: "img",
    "aria-label": "icon"
  };
  var STACKED_ATTRS = {
    width: null,
    height: null,
    focusable: null,
    role: null,
    "aria-label": null
  };
  var props$2h = {
    animation: makeProp(PROP_TYPE_STRING),
    content: makeProp(PROP_TYPE_STRING),
    flipH: makeProp(PROP_TYPE_BOOLEAN, false),
    flipV: makeProp(PROP_TYPE_BOOLEAN, false),
    fontScale: makeProp(PROP_TYPE_NUMBER_STRING, 1),
    rotate: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    scale: makeProp(PROP_TYPE_NUMBER_STRING, 1),
    shiftH: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    shiftV: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    stacked: makeProp(PROP_TYPE_BOOLEAN, false),
    title: makeProp(PROP_TYPE_STRING),
    variant: makeProp(PROP_TYPE_STRING)
  };
  var BVIconBase = /* @__PURE__ */ extend({
    name: NAME_ICON_BASE,
    functional: true,
    props: props$2h,
    render: function render(h, _ref) {
      var _class;
      var data = _ref.data, props2 = _ref.props, children = _ref.children;
      var animation = props2.animation, content = props2.content, flipH = props2.flipH, flipV = props2.flipV, stacked = props2.stacked, title = props2.title, variant = props2.variant;
      var fontScale = mathMax(toFloat(props2.fontScale, 1), 0) || 1;
      var scale = mathMax(toFloat(props2.scale, 1), 0) || 1;
      var rotate = toFloat(props2.rotate, 0);
      var shiftH = toFloat(props2.shiftH, 0);
      var shiftV = toFloat(props2.shiftV, 0);
      var hasScale = flipH || flipV || scale !== 1;
      var hasTransforms = hasScale || rotate;
      var hasShift = shiftH || shiftV;
      var hasContent = !isUndefinedOrNull(content);
      var transforms = [hasTransforms ? "translate(8 8)" : null, hasScale ? "scale(".concat((flipH ? -1 : 1) * scale, " ").concat((flipV ? -1 : 1) * scale, ")") : null, rotate ? "rotate(".concat(rotate, ")") : null, hasTransforms ? "translate(-8 -8)" : null].filter(identity);
      var $inner = h("g", {
        attrs: {
          transform: transforms.join(" ") || null
        },
        domProps: hasContent ? {
          innerHTML: content || ""
        } : {}
      }, children);
      if (hasShift) {
        $inner = h("g", {
          attrs: {
            transform: "translate(".concat(16 * shiftH / 16, " ").concat(-16 * shiftV / 16, ")")
          }
        }, [$inner]);
      }
      if (stacked) {
        $inner = h("g", [$inner]);
      }
      var $title = title ? h("title", title) : null;
      var $content = [$title, $inner].filter(identity);
      return h("svg", a(
        {
          staticClass: "b-icon bi",
          class: (_class = {}, _defineProperty$1T(_class, "text-".concat(variant), variant), _defineProperty$1T(_class, "b-icon-animation-".concat(animation), animation), _class),
          attrs: BASE_ATTRS,
          style: stacked ? {} : {
            fontSize: fontScale === 1 ? null : "".concat(fontScale * 100, "%")
          }
        },
        // Merge in user supplied data
        data,
        // If icon is stacked, null-out some attrs
        stacked ? {
          attrs: STACKED_ATTRS
        } : {},
        // These cannot be overridden by users
        {
          attrs: {
            xmlns: stacked ? null : "http://www.w3.org/2000/svg",
            fill: "currentColor"
          }
        }
      ), $content);
    }
  });
  function ownKeys$1y(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1y(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1y(Object(source), true).forEach(function(key) {
        _defineProperty$1S(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1y(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1S(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var iconProps$1 = omit(props$2h, ["content"]);
  var makeIcon = function makeIcon2(name, content) {
    var kebabName = kebabCase(name);
    var iconName = "BIcon".concat(pascalCase(name));
    var iconNameClass = "bi-".concat(kebabName);
    var iconTitle = kebabName.replace(/-/g, " ");
    var svgContent = trim(content || "");
    return /* @__PURE__ */ extend({
      name: iconName,
      functional: true,
      props: iconProps$1,
      render: function render(h, _ref) {
        var data = _ref.data, props2 = _ref.props;
        return h(BVIconBase, a(
          // Defaults
          {
            props: {
              title: iconTitle
            },
            attrs: {
              "aria-label": iconTitle
            }
          },
          // User data
          data,
          // Required data
          {
            staticClass: iconNameClass,
            props: _objectSpread$1y(_objectSpread$1y({}, props2), {}, {
              content: svgContent
            })
          }
        ));
      }
    });
  };
  var BIconBlank = /* @__PURE__ */ makeIcon("Blank", "");
  var BIconCalendar = /* @__PURE__ */ makeIcon("Calendar", '<path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5zM1 4v10a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V4H1z"/>');
  var BIconCalendarFill = /* @__PURE__ */ makeIcon("CalendarFill", '<path d="M3.5 0a.5.5 0 0 1 .5.5V1h8V.5a.5.5 0 0 1 1 0V1h1a2 2 0 0 1 2 2v11a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V5h16V4H0V3a2 2 0 0 1 2-2h1V.5a.5.5 0 0 1 .5-.5z"/>');
  var BIconChevronBarLeft = /* @__PURE__ */ makeIcon("ChevronBarLeft", '<path fill-rule="evenodd" d="M11.854 3.646a.5.5 0 0 1 0 .708L8.207 8l3.647 3.646a.5.5 0 0 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 0 1 .708 0zM4.5 1a.5.5 0 0 0-.5.5v13a.5.5 0 0 0 1 0v-13a.5.5 0 0 0-.5-.5z"/>');
  var BIconChevronDoubleLeft = /* @__PURE__ */ makeIcon("ChevronDoubleLeft", '<path fill-rule="evenodd" d="M8.354 1.646a.5.5 0 0 1 0 .708L2.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/><path fill-rule="evenodd" d="M12.354 1.646a.5.5 0 0 1 0 .708L6.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>');
  var BIconChevronDown = /* @__PURE__ */ makeIcon("ChevronDown", '<path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/>');
  var BIconChevronLeft = /* @__PURE__ */ makeIcon("ChevronLeft", '<path fill-rule="evenodd" d="M11.354 1.646a.5.5 0 0 1 0 .708L5.707 8l5.647 5.646a.5.5 0 0 1-.708.708l-6-6a.5.5 0 0 1 0-.708l6-6a.5.5 0 0 1 .708 0z"/>');
  var BIconChevronUp = /* @__PURE__ */ makeIcon("ChevronUp", '<path fill-rule="evenodd" d="M7.646 4.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1-.708.708L8 5.707l-5.646 5.647a.5.5 0 0 1-.708-.708l6-6z"/>');
  var BIconCircleFill = /* @__PURE__ */ makeIcon("CircleFill", '<circle cx="8" cy="8" r="8"/>');
  var BIconClock = /* @__PURE__ */ makeIcon("Clock", '<path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>');
  var BIconClockFill = /* @__PURE__ */ makeIcon("ClockFill", '<path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zM8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>');
  var BIconDash = /* @__PURE__ */ makeIcon("Dash", '<path d="M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z"/>');
  var BIconPersonFill = /* @__PURE__ */ makeIcon("PersonFill", '<path d="M3 14s-1 0-1-1 1-4 6-4 6 3 6 4-1 1-1 1H3zm5-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>');
  var BIconPlus = /* @__PURE__ */ makeIcon("Plus", '<path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"/>');
  var BIconStar = /* @__PURE__ */ makeIcon("Star", '<path d="M2.866 14.85c-.078.444.36.791.746.593l4.39-2.256 4.389 2.256c.386.198.824-.149.746-.592l-.83-4.73 3.522-3.356c.33-.314.16-.888-.282-.95l-4.898-.696L8.465.792a.513.513 0 0 0-.927 0L5.354 5.12l-4.898.696c-.441.062-.612.636-.283.95l3.523 3.356-.83 4.73zm4.905-2.767-3.686 1.894.694-3.957a.565.565 0 0 0-.163-.505L1.71 6.745l4.052-.576a.525.525 0 0 0 .393-.288L8 2.223l1.847 3.658a.525.525 0 0 0 .393.288l4.052.575-2.906 2.77a.565.565 0 0 0-.163.506l.694 3.957-3.686-1.894a.503.503 0 0 0-.461 0z"/>');
  var BIconStarFill = /* @__PURE__ */ makeIcon("StarFill", '<path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/>');
  var BIconStarHalf = /* @__PURE__ */ makeIcon("StarHalf", '<path d="M5.354 5.119 7.538.792A.516.516 0 0 1 8 .5c.183 0 .366.097.465.292l2.184 4.327 4.898.696A.537.537 0 0 1 16 6.32a.548.548 0 0 1-.17.445l-3.523 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256a.52.52 0 0 1-.146.05c-.342.06-.668-.254-.6-.642l.83-4.73L.173 6.765a.55.55 0 0 1-.172-.403.58.58 0 0 1 .085-.302.513.513 0 0 1 .37-.245l4.898-.696zM8 12.027a.5.5 0 0 1 .232.056l3.686 1.894-.694-3.957a.565.565 0 0 1 .162-.505l2.907-2.77-4.052-.576a.525.525 0 0 1-.393-.288L8.001 2.223 8 2.226v9.8z"/>');
  var BIconX = /* @__PURE__ */ makeIcon("X", '<path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>');
  function ownKeys$1x(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1x(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1x(Object(source), true).forEach(function(key) {
        _defineProperty$1R(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1x(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1R(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var findIconComponent = function findIconComponent2(ctx, iconName) {
    if (!ctx) {
      return Vue2.component(iconName);
    }
    var components = (ctx.$options || {}).components;
    var iconComponent = components && components[iconName];
    return iconComponent || findIconComponent2(ctx.$parent, iconName);
  };
  var iconProps = omit(props$2h, ["content"]);
  var props$2g = makePropsConfigurable(sortKeys(_objectSpread$1x(_objectSpread$1x({}, iconProps), {}, {
    icon: makeProp(PROP_TYPE_STRING)
  })), NAME_ICON);
  var BIcon = /* @__PURE__ */ extend({
    name: NAME_ICON,
    functional: true,
    props: props$2g,
    render: function render(h, _ref) {
      var data = _ref.data, props2 = _ref.props, parent = _ref.parent;
      var icon = pascalCase(trim(props2.icon || "")).replace(RX_ICON_PREFIX, "");
      return h(icon ? findIconComponent(parent, "BIcon".concat(icon)) || BIconBlank : BIconBlank, a(data, {
        props: pluckProps(iconProps, props2)
      }));
    }
  });
  var CODE_BACKSPACE = 8;
  var CODE_DELETE = 46;
  var CODE_DOWN = 40;
  var CODE_END = 35;
  var CODE_ENTER = 13;
  var CODE_ESC = 27;
  var CODE_HOME = 36;
  var CODE_LEFT = 37;
  var CODE_PAGEDOWN = 34;
  var CODE_PAGEUP = 33;
  var CODE_RIGHT = 39;
  var CODE_SPACE = 32;
  var CODE_UP = 38;
  var compareArrays = function compareArrays2(a2, b) {
    if (a2.length !== b.length) {
      return false;
    }
    var equal = true;
    for (var i = 0; equal && i < a2.length; i++) {
      equal = looseEqual(a2[i], b[i]);
    }
    return equal;
  };
  var looseEqual = function looseEqual2(a2, b) {
    if (a2 === b) {
      return true;
    }
    var aValidType = isDate(a2);
    var bValidType = isDate(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? a2.getTime() === b.getTime() : false;
    }
    aValidType = isArray(a2);
    bValidType = isArray(b);
    if (aValidType || bValidType) {
      return aValidType && bValidType ? compareArrays(a2, b) : false;
    }
    aValidType = isObject(a2);
    bValidType = isObject(b);
    if (aValidType || bValidType) {
      if (!aValidType || !bValidType) {
        return false;
      }
      var aKeysCount = keys(a2).length;
      var bKeysCount = keys(b).length;
      if (aKeysCount !== bKeysCount) {
        return false;
      }
      for (var key in a2) {
        var aHasKey = hasOwnProperty(a2, key);
        var bHasKey = hasOwnProperty(b, key);
        if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual2(a2[key], b[key])) {
          return false;
        }
      }
    }
    return String(a2) === String(b);
  };
  function _defineProperty$1Q(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var isEmpty = function isEmpty2(value) {
    return !value || keys(value).length === 0;
  };
  var makePropWatcher = function makePropWatcher2(propName) {
    return {
      handler: function handler(newValue, oldValue) {
        if (looseEqual(newValue, oldValue)) {
          return;
        }
        if (isEmpty(newValue) || isEmpty(oldValue)) {
          this[propName] = cloneDeep(newValue);
          return;
        }
        for (var key in oldValue) {
          if (!hasOwnProperty(newValue, key)) {
            this.$delete(this.$data[propName], key);
          }
        }
        for (var _key in newValue) {
          this.$set(this.$data[propName], _key, newValue[_key]);
        }
      }
    };
  };
  var makePropCacheMixin = function makePropCacheMixin2(propName, proxyPropName) {
    return extend({
      data: function data() {
        return _defineProperty$1Q({}, proxyPropName, cloneDeep(this[propName]));
      },
      watch: _defineProperty$1Q({}, propName, makePropWatcher(proxyPropName))
    });
  };
  function ownKeys$1w(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1w(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1w(Object(source), true).forEach(function(key) {
        _defineProperty$1P(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1w(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1P(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var attrsMixinVue2 = makePropCacheMixin("$attrs", "bvAttrs");
  var attrsMixinVue3 = extend({
    computed: {
      bvAttrs: function bvAttrs() {
        var bvAttrs2 = _objectSpread$1w({}, this.$attrs);
        Object.keys(bvAttrs2).forEach(function(key) {
          if (bvAttrs2[key] === void 0) {
            delete bvAttrs2[key];
          }
        });
        return bvAttrs2;
      }
    }
  });
  var attrsMixin = isVue3 ? attrsMixinVue3 : attrsMixinVue2;
  var getEventRoot = function getEventRoot2(vm) {
    return vm.$root.$options.bvEventRoot || vm.$root;
  };
  var PROP$3 = "$_rootListeners";
  var listenOnRootMixin = extend({
    computed: {
      bvEventRoot: function bvEventRoot() {
        return getEventRoot(this);
      }
    },
    created: function created() {
      this[PROP$3] = {};
    },
    beforeDestroy: function beforeDestroy() {
      var _this = this;
      keys(this[PROP$3] || {}).forEach(function(event2) {
        _this[PROP$3][event2].forEach(function(callback) {
          _this.listenOffRoot(event2, callback);
        });
      });
      this[PROP$3] = null;
    },
    methods: {
      registerRootListener: function registerRootListener(event2, callback) {
        if (this[PROP$3]) {
          this[PROP$3][event2] = this[PROP$3][event2] || [];
          if (!arrayIncludes(this[PROP$3][event2], callback)) {
            this[PROP$3][event2].push(callback);
          }
        }
      },
      unregisterRootListener: function unregisterRootListener(event2, callback) {
        if (this[PROP$3] && this[PROP$3][event2]) {
          this[PROP$3][event2] = this[PROP$3][event2].filter(function(cb) {
            return cb !== callback;
          });
        }
      },
      /**
       * Safely register event listeners on the root Vue node
       * While Vue automatically removes listeners for individual components,
       * when a component registers a listener on `$root` and is destroyed,
       * this orphans a callback because the node is gone, but the `$root`
       * does not clear the callback
       *
       * When registering a `$root` listener, it also registers the listener
       * to be removed in the component's `beforeDestroy()` hook
       *
       * @param {string} event
       * @param {function} callback
       */
      listenOnRoot: function listenOnRoot(event2, callback) {
        if (this.bvEventRoot) {
          this.bvEventRoot.$on(event2, callback);
          this.registerRootListener(event2, callback);
        }
      },
      /**
       * Safely register a `$once()` event listener on the root Vue node
       * While Vue automatically removes listeners for individual components,
       * when a component registers a listener on `$root` and is destroyed,
       * this orphans a callback because the node is gone, but the `$root`
       * does not clear the callback
       *
       * When registering a `$root` listener, it also registers the listener
       * to be removed in the component's `beforeDestroy()` hook
       *
       * @param {string} event
       * @param {function} callback
       */
      listenOnRootOnce: function listenOnRootOnce(event2, callback) {
        var _this2 = this;
        if (this.bvEventRoot) {
          var _callback = function _callback2() {
            _this2.unregisterRootListener(_callback2);
            callback.apply(void 0, arguments);
          };
          this.bvEventRoot.$once(event2, _callback);
          this.registerRootListener(event2, _callback);
        }
      },
      /**
       * Safely unregister event listeners from the root Vue node
       *
       * @param {string} event
       * @param {function} callback
       */
      listenOffRoot: function listenOffRoot(event2, callback) {
        this.unregisterRootListener(event2, callback);
        if (this.bvEventRoot) {
          this.bvEventRoot.$off(event2, callback);
        }
      },
      /**
       * Convenience method for calling `vm.$emit()` on `$root`
       *
       * @param {string} event
       * @param {*} args
       */
      emitOnRoot: function emitOnRoot(event2) {
        if (this.bvEventRoot) {
          var _this$bvEventRoot;
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          (_this$bvEventRoot = this.bvEventRoot).$emit.apply(_this$bvEventRoot, [event2].concat(args));
        }
      }
    }
  });
  function ownKeys$1v(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1v(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1v(Object(source), true).forEach(function(key) {
        _defineProperty$1O(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1v(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1O(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var listenersMixinVue2 = makePropCacheMixin("$listeners", "bvListeners");
  var listenersMixinVue3 = extend({
    data: function data() {
      return {
        bvListeners: {}
      };
    },
    created: function created() {
      this.bvListeners = _objectSpread$1v({}, this.$listeners);
    },
    beforeUpdate: function beforeUpdate() {
      this.bvListeners = _objectSpread$1v({}, this.$listeners);
    }
  });
  var listenersMixin = isVue3 ? listenersMixinVue3 : listenersMixinVue2;
  function _toConsumableArray$8(arr) {
    return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$8();
  }
  function _nonIterableSpread$8() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$9(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$9(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen);
  }
  function _iterableToArray$8(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$8(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$9(arr);
  }
  function _arrayLikeToArray$9(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys$1u(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1u(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1u(Object(source), true).forEach(function(key) {
        _defineProperty$1N(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1u(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1N(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ROOT_EVENT_NAME_CLICKED = getRootEventName(NAME_LINK, "clicked");
  var routerLinkProps = {
    activeClass: makeProp(PROP_TYPE_STRING),
    append: makeProp(PROP_TYPE_BOOLEAN, false),
    event: makeProp(PROP_TYPE_ARRAY_STRING),
    exact: makeProp(PROP_TYPE_BOOLEAN, false),
    exactActiveClass: makeProp(PROP_TYPE_STRING),
    exactPath: makeProp(PROP_TYPE_BOOLEAN, false),
    exactPathActiveClass: makeProp(PROP_TYPE_STRING),
    replace: makeProp(PROP_TYPE_BOOLEAN, false),
    routerTag: makeProp(PROP_TYPE_STRING),
    to: makeProp(PROP_TYPE_OBJECT_STRING)
  };
  var nuxtLinkProps = {
    noPrefetch: makeProp(PROP_TYPE_BOOLEAN, false),
    // Must be `null` to fall back to the value defined in the
    // `nuxt.config.js` configuration file for `router.prefetchLinks`
    // We convert `null` to `undefined`, so that Nuxt.js will use the
    // compiled default
    // Vue treats `undefined` as default of `false` for Boolean props,
    // so we must set it as `null` here to be a true tri-state prop
    prefetch: makeProp(PROP_TYPE_BOOLEAN, null)
  };
  var props$2f = makePropsConfigurable(sortKeys(_objectSpread$1u(_objectSpread$1u(_objectSpread$1u({}, nuxtLinkProps), routerLinkProps), {}, {
    active: makeProp(PROP_TYPE_BOOLEAN, false),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    href: makeProp(PROP_TYPE_STRING),
    // Must be `null` if no value provided
    rel: makeProp(PROP_TYPE_STRING, null),
    // To support 3rd party router links based on `<router-link>` (i.e. `g-link` for Gridsome)
    // Default is to auto choose between `<router-link>` and `<nuxt-link>`
    // Gridsome doesn't provide a mechanism to auto detect and has caveats
    // such as not supporting FQDN URLs or hash only URLs
    routerComponentName: makeProp(PROP_TYPE_STRING),
    target: makeProp(PROP_TYPE_STRING, "_self")
  })), NAME_LINK);
  var BLink = /* @__PURE__ */ extend({
    name: NAME_LINK,
    // Mixin order is important!
    mixins: [attrsMixin, listenersMixin, listenOnRootMixin, normalizeSlotMixin],
    inheritAttrs: false,
    props: props$2f,
    computed: {
      computedTag: function computedTag() {
        var to = this.to, disabled = this.disabled, routerComponentName = this.routerComponentName;
        return computeTag({
          to,
          disabled,
          routerComponentName
        }, this);
      },
      isRouterLink: function isRouterLink$1() {
        return isRouterLink(this.computedTag);
      },
      computedRel: function computedRel() {
        var target = this.target, rel = this.rel;
        return computeRel({
          target,
          rel
        });
      },
      computedHref: function computedHref() {
        var to = this.to, href = this.href;
        return computeHref({
          to,
          href
        }, this.computedTag);
      },
      computedProps: function computedProps() {
        var event2 = this.event, prefetch = this.prefetch, routerTag = this.routerTag;
        return this.isRouterLink ? _objectSpread$1u(_objectSpread$1u(_objectSpread$1u(_objectSpread$1u({}, pluckProps(omit(_objectSpread$1u(_objectSpread$1u({}, routerLinkProps), this.computedTag === "nuxt-link" ? nuxtLinkProps : {}), ["event", "prefetch", "routerTag"]), this)), event2 ? {
          event: event2
        } : {}), isBoolean(prefetch) ? {
          prefetch
        } : {}), routerTag ? {
          tag: routerTag
        } : {}) : {};
      },
      computedAttrs: function computedAttrs() {
        var bvAttrs = this.bvAttrs, href = this.computedHref, rel = this.computedRel, disabled = this.disabled, target = this.target, routerTag = this.routerTag, isRouterLink2 = this.isRouterLink;
        return _objectSpread$1u(_objectSpread$1u(_objectSpread$1u(_objectSpread$1u({}, bvAttrs), href ? {
          href
        } : {}), isRouterLink2 && routerTag && !isTag(routerTag, "a") ? {} : {
          rel,
          target
        }), {}, {
          tabindex: disabled ? "-1" : isUndefined(bvAttrs.tabindex) ? null : bvAttrs.tabindex,
          "aria-disabled": disabled ? "true" : null
        });
      },
      computedListeners: function computedListeners() {
        return _objectSpread$1u(_objectSpread$1u({}, this.bvListeners), {}, {
          // We want to overwrite any click handler since our callback
          // will invoke the user supplied handler(s) if `!this.disabled`
          click: this.onClick
        });
      }
    },
    methods: {
      onClick: function onClick(event2) {
        var _arguments = arguments;
        var eventIsEvent = isEvent(event2);
        var isRouterLink2 = this.isRouterLink;
        var suppliedHandler = this.bvListeners.click;
        if (eventIsEvent && this.disabled) {
          stopEvent(event2, {
            immediatePropagation: true
          });
        } else {
          if (isRouterLink2) {
            var _event$currentTarget$;
            (_event$currentTarget$ = event2.currentTarget.__vue__) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.$emit(EVENT_NAME_CLICK, event2);
          }
          concat(suppliedHandler).filter(function(h) {
            return isFunction$1(h);
          }).forEach(function(handler) {
            handler.apply(void 0, _toConsumableArray$8(_arguments));
          });
          this.emitOnRoot(ROOT_EVENT_NAME_CLICKED, event2);
          this.emitOnRoot("clicked::link", event2);
        }
        if (eventIsEvent && !isRouterLink2 && this.computedHref === "#") {
          stopEvent(event2, {
            propagation: false
          });
        }
      },
      focus: function focus() {
        attemptFocus(this.$el);
      },
      blur: function blur() {
        attemptBlur(this.$el);
      }
    },
    render: function render(h) {
      var active = this.active, disabled = this.disabled;
      return h(this.computedTag, _defineProperty$1N({
        class: {
          active,
          disabled
        },
        attrs: this.computedAttrs,
        props: this.computedProps
      }, this.isRouterLink ? "nativeOn" : "on", this.computedListeners), this.normalizeSlot());
    }
  });
  function ownKeys$1t(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1t(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1t(Object(source), true).forEach(function(key) {
        _defineProperty$1M(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1t(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1M(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var linkProps$7 = omit(props$2f, ["event", "routerTag"]);
  delete linkProps$7.href.default;
  delete linkProps$7.to.default;
  var props$2e = makePropsConfigurable(sortKeys(_objectSpread$1t(_objectSpread$1t({}, linkProps$7), {}, {
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    pill: makeProp(PROP_TYPE_BOOLEAN, false),
    // Tri-state: `true`, `false` or `null`
    // => On, off, not a toggle
    pressed: makeProp(PROP_TYPE_BOOLEAN, null),
    size: makeProp(PROP_TYPE_STRING),
    squared: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "button"),
    type: makeProp(PROP_TYPE_STRING, "button"),
    variant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_BUTTON);
  var handleFocus = function handleFocus2(event2) {
    if (event2.type === "focusin") {
      addClass(event2.target, "focus");
    } else if (event2.type === "focusout") {
      removeClass(event2.target, "focus");
    }
  };
  var isLink = function isLink2(props2) {
    return isLink$1(props2) || isTag(props2.tag, "a");
  };
  var isToggle = function isToggle2(props2) {
    return isBoolean(props2.pressed);
  };
  var isButton = function isButton2(props2) {
    return !(isLink(props2) || props2.tag && !isTag(props2.tag, "button"));
  };
  var isNonStandardTag$1 = function isNonStandardTag2(props2) {
    return !isLink(props2) && !isButton(props2);
  };
  var computeClass = function computeClass2(props2) {
    var _ref;
    return ["btn-".concat(props2.variant || "secondary"), (_ref = {}, _defineProperty$1M(_ref, "btn-".concat(props2.size), props2.size), _defineProperty$1M(_ref, "btn-block", props2.block), _defineProperty$1M(_ref, "rounded-pill", props2.pill), _defineProperty$1M(_ref, "rounded-0", props2.squared && !props2.pill), _defineProperty$1M(_ref, "disabled", props2.disabled), _defineProperty$1M(_ref, "active", props2.pressed), _ref)];
  };
  var computeLinkProps = function computeLinkProps2(props2) {
    return isLink(props2) ? pluckProps(linkProps$7, props2) : {};
  };
  var computeAttrs = function computeAttrs2(props2, data) {
    var button = isButton(props2);
    var link = isLink(props2);
    var toggle = isToggle(props2);
    var nonStandardTag = isNonStandardTag$1(props2);
    var hashLink = link && props2.href === "#";
    var role = data.attrs && data.attrs.role ? data.attrs.role : null;
    var tabindex = data.attrs ? data.attrs.tabindex : null;
    if (nonStandardTag || hashLink) {
      tabindex = "0";
    }
    return {
      // Type only used for "real" buttons
      type: button && !link ? props2.type : null,
      // Disabled only set on "real" buttons
      disabled: button ? props2.disabled : null,
      // We add a role of button when the tag is not a link or button for ARIA
      // Don't bork any role provided in `data.attrs` when `isLink` or `isButton`
      // Except when link has `href` of `#`
      role: nonStandardTag || hashLink ? "button" : role,
      // We set the `aria-disabled` state for non-standard tags
      "aria-disabled": nonStandardTag ? String(props2.disabled) : null,
      // For toggles, we need to set the pressed state for ARIA
      "aria-pressed": toggle ? String(props2.pressed) : null,
      // `autocomplete="off"` is needed in toggle mode to prevent some browsers
      // from remembering the previous setting when using the back button
      autocomplete: toggle ? "off" : null,
      // `tabindex` is used when the component is not a button
      // Links are tabbable, but don't allow disabled, while non buttons or links
      // are not tabbable, so we mimic that functionality by disabling tabbing
      // when disabled, and adding a `tabindex="0"` to non buttons or non links
      tabindex: props2.disabled && !button ? "-1" : tabindex
    };
  };
  var BButton = /* @__PURE__ */ extend({
    name: NAME_BUTTON,
    functional: true,
    props: props$2e,
    render: function render(h, _ref2) {
      var props2 = _ref2.props, data = _ref2.data, listeners = _ref2.listeners, children = _ref2.children;
      var toggle = isToggle(props2);
      var link = isLink(props2);
      var nonStandardTag = isNonStandardTag$1(props2);
      var hashLink = link && props2.href === "#";
      var on = {
        keydown: function keydown(event2) {
          if (props2.disabled || !(nonStandardTag || hashLink)) {
            return;
          }
          var keyCode = event2.keyCode;
          if (keyCode === CODE_SPACE || keyCode === CODE_ENTER && nonStandardTag) {
            var target = event2.currentTarget || event2.target;
            stopEvent(event2, {
              propagation: false
            });
            target.click();
          }
        },
        click: function click(event2) {
          if (props2.disabled && isEvent(event2)) {
            stopEvent(event2);
          } else if (toggle && listeners && listeners["update:pressed"]) {
            concat(listeners["update:pressed"]).forEach(function(fn) {
              if (isFunction$1(fn)) {
                fn(!props2.pressed);
              }
            });
          }
        }
      };
      if (toggle) {
        on.focusin = handleFocus;
        on.focusout = handleFocus;
      }
      var componentData = {
        staticClass: "btn",
        class: computeClass(props2),
        props: computeLinkProps(props2),
        attrs: computeAttrs(props2, data),
        on
      };
      return h(link ? BLink : props2.tag, a(_objectSpread$1t(_objectSpread$1t({}, data), {}, {
        props: void 0
      }), componentData), children);
    }
  });
  function ownKeys$1s(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1s(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1s(Object(source), true).forEach(function(key) {
        _defineProperty$1L(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1s(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1L(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var CLASS_NAME$2 = "b-avatar";
  var SIZES = ["sm", null, "lg"];
  var FONT_SIZE_SCALE = 0.4;
  var BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7;
  var computeSize = function computeSize2(value) {
    value = isString(value) && isNumeric$1(value) ? toFloat(value, 0) : value;
    return isNumber(value) ? "".concat(value, "px") : value || null;
  };
  var linkProps$6 = omit(props$2f, ["active", "event", "routerTag"]);
  var props$2d = makePropsConfigurable(sortKeys(_objectSpread$1s(_objectSpread$1s({}, linkProps$6), {}, {
    alt: makeProp(PROP_TYPE_STRING, "avatar"),
    ariaLabel: makeProp(PROP_TYPE_STRING),
    badge: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    badgeLeft: makeProp(PROP_TYPE_BOOLEAN, false),
    badgeOffset: makeProp(PROP_TYPE_STRING),
    badgeTop: makeProp(PROP_TYPE_BOOLEAN, false),
    badgeVariant: makeProp(PROP_TYPE_STRING, "primary"),
    button: makeProp(PROP_TYPE_BOOLEAN, false),
    buttonType: makeProp(PROP_TYPE_STRING, "button"),
    icon: makeProp(PROP_TYPE_STRING),
    rounded: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    size: makeProp(PROP_TYPE_NUMBER_STRING),
    square: makeProp(PROP_TYPE_BOOLEAN, false),
    src: makeProp(PROP_TYPE_STRING),
    text: makeProp(PROP_TYPE_STRING),
    variant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_AVATAR);
  var BAvatar = /* @__PURE__ */ extend({
    name: NAME_AVATAR,
    mixins: [normalizeSlotMixin],
    inject: {
      getBvAvatarGroup: {
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    props: props$2d,
    data: function data() {
      return {
        localSrc: this.src || null
      };
    },
    computed: {
      bvAvatarGroup: function bvAvatarGroup() {
        return this.getBvAvatarGroup();
      },
      computedSize: function computedSize() {
        var bvAvatarGroup = this.bvAvatarGroup;
        return computeSize(bvAvatarGroup ? bvAvatarGroup.size : this.size);
      },
      computedVariant: function computedVariant() {
        var bvAvatarGroup = this.bvAvatarGroup;
        return bvAvatarGroup && bvAvatarGroup.variant ? bvAvatarGroup.variant : this.variant;
      },
      computedRounded: function computedRounded() {
        var bvAvatarGroup = this.bvAvatarGroup;
        var square = bvAvatarGroup && bvAvatarGroup.square ? true : this.square;
        var rounded = bvAvatarGroup && bvAvatarGroup.rounded ? bvAvatarGroup.rounded : this.rounded;
        return square ? "0" : rounded === "" ? true : rounded || "circle";
      },
      fontStyle: function fontStyle() {
        var size = this.computedSize;
        var fontSize = SIZES.indexOf(size) === -1 ? "calc(".concat(size, " * ").concat(FONT_SIZE_SCALE, ")") : null;
        return fontSize ? {
          fontSize
        } : {};
      },
      marginStyle: function marginStyle() {
        var size = this.computedSize, bvAvatarGroup = this.bvAvatarGroup;
        var overlapScale = bvAvatarGroup ? bvAvatarGroup.overlapScale : 0;
        var value = size && overlapScale ? "calc(".concat(size, " * -").concat(overlapScale, ")") : null;
        return value ? {
          marginLeft: value,
          marginRight: value
        } : {};
      },
      badgeStyle: function badgeStyle() {
        var size = this.computedSize, badgeTop = this.badgeTop, badgeLeft = this.badgeLeft, badgeOffset = this.badgeOffset;
        var offset2 = badgeOffset || "0px";
        return {
          fontSize: SIZES.indexOf(size) === -1 ? "calc(".concat(size, " * ").concat(BADGE_FONT_SIZE_SCALE, " )") : null,
          top: badgeTop ? offset2 : null,
          bottom: badgeTop ? null : offset2,
          left: badgeLeft ? offset2 : null,
          right: badgeLeft ? null : offset2
        };
      }
    },
    watch: {
      src: function src(newValue, oldValue) {
        if (newValue !== oldValue) {
          this.localSrc = newValue || null;
        }
      }
    },
    methods: {
      onImgError: function onImgError(event2) {
        this.localSrc = null;
        this.$emit(EVENT_NAME_IMG_ERROR, event2);
      },
      onClick: function onClick(event2) {
        this.$emit(EVENT_NAME_CLICK, event2);
      }
    },
    render: function render(h) {
      var _class2;
      var variant = this.computedVariant, disabled = this.disabled, rounded = this.computedRounded, icon = this.icon, src = this.localSrc, text = this.text, fontStyle = this.fontStyle, marginStyle = this.marginStyle, size = this.computedSize, button = this.button, type = this.buttonType, badge = this.badge, badgeVariant = this.badgeVariant, badgeStyle = this.badgeStyle;
      var link = !button && isLink$1(this);
      var tag = button ? BButton : link ? BLink : "span";
      var alt = this.alt;
      var ariaLabel = this.ariaLabel || null;
      var $content = null;
      if (this.hasNormalizedSlot()) {
        $content = h("span", {
          staticClass: "b-avatar-custom"
        }, [this.normalizeSlot()]);
      } else if (src) {
        $content = h("img", {
          style: variant ? {} : {
            width: "100%",
            height: "100%"
          },
          attrs: {
            src,
            alt
          },
          on: {
            error: this.onImgError
          }
        });
        $content = h("span", {
          staticClass: "b-avatar-img"
        }, [$content]);
      } else if (icon) {
        $content = h(BIcon, {
          props: {
            icon
          },
          attrs: {
            "aria-hidden": "true",
            alt
          }
        });
      } else if (text) {
        $content = h("span", {
          staticClass: "b-avatar-text",
          style: fontStyle
        }, [h("span", text)]);
      } else {
        $content = h(BIconPersonFill, {
          attrs: {
            "aria-hidden": "true",
            alt
          }
        });
      }
      var $badge = h();
      var hasBadgeSlot = this.hasNormalizedSlot(SLOT_NAME_BADGE);
      if (badge || badge === "" || hasBadgeSlot) {
        var badgeText = badge === true ? "" : badge;
        $badge = h("span", {
          staticClass: "b-avatar-badge",
          class: _defineProperty$1L({}, "badge-".concat(badgeVariant), badgeVariant),
          style: badgeStyle
        }, [hasBadgeSlot ? this.normalizeSlot(SLOT_NAME_BADGE) : badgeText]);
      }
      var componentData = {
        staticClass: CLASS_NAME$2,
        class: (_class2 = {}, _defineProperty$1L(_class2, "".concat(CLASS_NAME$2, "-").concat(size), size && SIZES.indexOf(size) !== -1), _defineProperty$1L(_class2, "badge-".concat(variant), !button && variant), _defineProperty$1L(_class2, "rounded", rounded === true), _defineProperty$1L(_class2, "rounded-".concat(rounded), rounded && rounded !== true), _defineProperty$1L(_class2, "disabled", disabled), _class2),
        style: _objectSpread$1s(_objectSpread$1s({}, marginStyle), {}, {
          width: size,
          height: size
        }),
        attrs: {
          "aria-label": ariaLabel || null
        },
        props: button ? {
          variant,
          disabled,
          type
        } : link ? pluckProps(linkProps$6, this) : {},
        on: button || link ? {
          click: this.onClick
        } : {}
      };
      return h(tag, componentData, [$content, $badge]);
    }
  });
  var props$2c = makePropsConfigurable({
    overlap: makeProp(PROP_TYPE_NUMBER_STRING, 0.3),
    // Child avatars will prefer this prop (if set) over their own
    rounded: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    // Child avatars will always use this over their own size
    size: makeProp(PROP_TYPE_STRING),
    // Child avatars will prefer this prop (if set) over their own
    square: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    // Child avatars will prefer this variant over their own
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_AVATAR_GROUP);
  var BAvatarGroup = /* @__PURE__ */ extend({
    name: NAME_AVATAR_GROUP,
    mixins: [normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvAvatarGroup: function getBvAvatarGroup() {
          return _this;
        }
      };
    },
    props: props$2c,
    computed: {
      computedSize: function computedSize() {
        return computeSize(this.size);
      },
      overlapScale: function overlapScale() {
        return mathMin(mathMax(toFloat(this.overlap, 0), 0), 1) / 2;
      },
      paddingStyle: function paddingStyle() {
        var value = this.computedSize;
        value = value ? "calc(".concat(value, " * ").concat(this.overlapScale, ")") : null;
        return value ? {
          paddingLeft: value,
          paddingRight: value
        } : {};
      }
    },
    render: function render(h) {
      var $inner = h("div", {
        staticClass: "b-avatar-group-inner",
        style: this.paddingStyle
      }, this.normalizeSlot());
      return h(this.tag, {
        staticClass: "b-avatar-group",
        attrs: {
          role: "group"
        }
      }, [$inner]);
    }
  });
  var AvatarPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BAvatar,
      BAvatarGroup
    }
  });
  function ownKeys$1r(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1r(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1r(Object(source), true).forEach(function(key) {
        _defineProperty$1K(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1r(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1K(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var linkProps$5 = omit(props$2f, ["event", "routerTag"]);
  delete linkProps$5.href.default;
  delete linkProps$5.to.default;
  var props$2b = makePropsConfigurable(sortKeys(_objectSpread$1r(_objectSpread$1r({}, linkProps$5), {}, {
    pill: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "span"),
    variant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_BADGE);
  var BBadge = /* @__PURE__ */ extend({
    name: NAME_BADGE,
    functional: true,
    props: props$2b,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var active = props2.active, disabled = props2.disabled;
      var link = isLink$1(props2);
      var tag = link ? BLink : props2.tag;
      var variant = props2.variant || "secondary";
      return h(tag, a(data, {
        staticClass: "badge",
        class: ["badge-".concat(variant), {
          "badge-pill": props2.pill,
          active,
          disabled
        }],
        props: link ? pluckProps(linkProps$5, props2) : {}
      }), children);
    }
  });
  var BadgePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BBadge
    }
  });
  var stripTags = function stripTags2() {
    var text = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return String(text).replace(RX_HTML_TAGS, "");
  };
  var htmlOrText = function htmlOrText2(innerHTML, textContent) {
    return innerHTML ? {
      innerHTML
    } : textContent ? {
      textContent
    } : {};
  };
  function ownKeys$1q(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1q(Object(source), true).forEach(function(key) {
        _defineProperty$1J(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1q(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1J(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$2a = makePropsConfigurable(sortKeys(_objectSpread$1q(_objectSpread$1q({}, omit(props$2f, ["event", "routerTag"])), {}, {
    ariaCurrent: makeProp(PROP_TYPE_STRING, "location"),
    html: makeProp(PROP_TYPE_STRING),
    text: makeProp(PROP_TYPE_STRING)
  })), NAME_BREADCRUMB_LINK);
  var BBreadcrumbLink = /* @__PURE__ */ extend({
    name: NAME_BREADCRUMB_LINK,
    functional: true,
    props: props$2a,
    render: function render(h, _ref) {
      var suppliedProps = _ref.props, data = _ref.data, children = _ref.children;
      var active = suppliedProps.active;
      var tag = active ? "span" : BLink;
      var componentData = {
        attrs: {
          "aria-current": active ? suppliedProps.ariaCurrent : null
        },
        props: pluckProps(props$2a, suppliedProps)
      };
      if (!children) {
        componentData.domProps = htmlOrText(suppliedProps.html, suppliedProps.text);
      }
      return h(tag, a(data, componentData), children);
    }
  });
  var props$29 = makePropsConfigurable(props$2a, NAME_BREADCRUMB_ITEM);
  var BBreadcrumbItem = /* @__PURE__ */ extend({
    name: NAME_BREADCRUMB_ITEM,
    functional: true,
    props: props$29,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h("li", a(data, {
        staticClass: "breadcrumb-item",
        class: {
          active: props2.active
        }
      }), [h(BBreadcrumbLink, {
        props: props2
      }, children)]);
    }
  });
  function ownKeys$1p(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1p(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1p(Object(source), true).forEach(function(key) {
        _defineProperty$1I(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1p(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1I(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$28 = makePropsConfigurable({
    items: makeProp(PROP_TYPE_ARRAY)
  }, NAME_BREADCRUMB);
  var BBreadcrumb = /* @__PURE__ */ extend({
    name: NAME_BREADCRUMB,
    functional: true,
    props: props$28,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var items = props2.items;
      var childNodes = children;
      if (isArray(items)) {
        var activeDefined = false;
        childNodes = items.map(function(item, idx) {
          if (!isObject(item)) {
            item = {
              text: toString(item)
            };
          }
          var _item = item, active = _item.active;
          if (active) {
            activeDefined = true;
          }
          if (!active && !activeDefined) {
            active = idx + 1 === items.length;
          }
          return h(BBreadcrumbItem, {
            props: _objectSpread$1p(_objectSpread$1p({}, item), {}, {
              active
            })
          });
        });
      }
      return h("ol", a(data, {
        staticClass: "breadcrumb"
      }), childNodes);
    }
  });
  var BreadcrumbPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BBreadcrumb,
      BBreadcrumbItem,
      BBreadcrumbLink
    }
  });
  var ButtonPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BButton,
      BBtn: BButton,
      BButtonClose,
      BBtnClose: BButtonClose
    }
  });
  function ownKeys$1o(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1o(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1o(Object(source), true).forEach(function(key) {
        _defineProperty$1H(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1o(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1H(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$27 = makePropsConfigurable(sortKeys(_objectSpread$1o(_objectSpread$1o({}, pick$1(props$2e, ["size"])), {}, {
    ariaRole: makeProp(PROP_TYPE_STRING, "group"),
    size: makeProp(PROP_TYPE_STRING),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    vertical: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_BUTTON_GROUP);
  var BButtonGroup = /* @__PURE__ */ extend({
    name: NAME_BUTTON_GROUP,
    functional: true,
    props: props$27,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        class: _defineProperty$1H({
          "btn-group": !props2.vertical,
          "btn-group-vertical": props2.vertical
        }, "btn-group-".concat(props2.size), props2.size),
        attrs: {
          role: props2.ariaRole
        }
      }), children);
    }
  });
  var ButtonGroupPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BButtonGroup,
      BBtnGroup: BButtonGroup
    }
  });
  var ITEM_SELECTOR = [".btn:not(.disabled):not([disabled]):not(.dropdown-item)", ".form-control:not(.disabled):not([disabled])", "select:not(.disabled):not([disabled])", 'input[type="checkbox"]:not(.disabled)', 'input[type="radio"]:not(.disabled)'].join(",");
  var props$26 = makePropsConfigurable({
    justify: makeProp(PROP_TYPE_BOOLEAN, false),
    keyNav: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_BUTTON_TOOLBAR);
  var BButtonToolbar = /* @__PURE__ */ extend({
    name: NAME_BUTTON_TOOLBAR,
    mixins: [normalizeSlotMixin],
    props: props$26,
    mounted: function mounted() {
      if (this.keyNav) {
        this.getItems();
      }
    },
    methods: {
      getItems: function getItems() {
        var items = selectAll(ITEM_SELECTOR, this.$el);
        items.forEach(function(item) {
          item.tabIndex = -1;
        });
        return items.filter(function(el) {
          return isVisible(el);
        });
      },
      focusFirst: function focusFirst() {
        var items = this.getItems();
        attemptFocus(items[0]);
      },
      focusPrev: function focusPrev(event2) {
        var items = this.getItems();
        var index = items.indexOf(event2.target);
        if (index > -1) {
          items = items.slice(0, index).reverse();
          attemptFocus(items[0]);
        }
      },
      focusNext: function focusNext(event2) {
        var items = this.getItems();
        var index = items.indexOf(event2.target);
        if (index > -1) {
          items = items.slice(index + 1);
          attemptFocus(items[0]);
        }
      },
      focusLast: function focusLast() {
        var items = this.getItems().reverse();
        attemptFocus(items[0]);
      },
      onFocusin: function onFocusin(event2) {
        var $el = this.$el;
        if (event2.target === $el && !contains($el, event2.relatedTarget)) {
          stopEvent(event2);
          this.focusFirst(event2);
        }
      },
      onKeydown: function onKeydown(event2) {
        var keyCode = event2.keyCode, shiftKey = event2.shiftKey;
        if (keyCode === CODE_UP || keyCode === CODE_LEFT) {
          stopEvent(event2);
          shiftKey ? this.focusFirst(event2) : this.focusPrev(event2);
        } else if (keyCode === CODE_DOWN || keyCode === CODE_RIGHT) {
          stopEvent(event2);
          shiftKey ? this.focusLast(event2) : this.focusNext(event2);
        }
      }
    },
    render: function render(h) {
      var keyNav = this.keyNav;
      return h("div", {
        staticClass: "btn-toolbar",
        class: {
          "justify-content-between": this.justify
        },
        attrs: {
          role: "toolbar",
          tabindex: keyNav ? "0" : null
        },
        on: keyNav ? {
          focusin: this.onFocusin,
          keydown: this.onKeydown
        } : {}
      }, [this.normalizeSlot()]);
    }
  });
  var ButtonToolbarPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BButtonToolbar,
      BBtnToolbar: BButtonToolbar
    }
  });
  var CALENDAR_GREGORY = "gregory";
  var CALENDAR_LONG = "long";
  var CALENDAR_NARROW = "narrow";
  var CALENDAR_SHORT = "short";
  var DATE_FORMAT_2_DIGIT = "2-digit";
  var DATE_FORMAT_NUMERIC = "numeric";
  function _slicedToArray$1(arr, i) {
    return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$1();
  }
  function _nonIterableRest$1() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$8(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$8(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen);
  }
  function _arrayLikeToArray$8(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit$1(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles$1(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$1()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a2 = [null];
        a2.push.apply(a2, args2);
        var Constructor = Function.bind.apply(Parent2, a2);
        var instance = new Constructor();
        if (Class2) _setPrototypeOf$1(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf$1(o, p);
  }
  var createDate = function createDate2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _construct(Date, args);
  };
  var parseYMD = function parseYMD2(date) {
    if (isString(date) && RX_DATE.test(date.trim())) {
      var _date$split$map = date.split(RX_DATE_SPLIT).map(function(v) {
        return toInteger(v, 1);
      }), _date$split$map2 = _slicedToArray$1(_date$split$map, 3), year = _date$split$map2[0], month = _date$split$map2[1], day = _date$split$map2[2];
      return createDate(year, month - 1, day);
    } else if (isDate(date)) {
      return createDate(date.getFullYear(), date.getMonth(), date.getDate());
    }
    return null;
  };
  var formatYMD = function formatYMD2(date) {
    date = parseYMD(date);
    if (!date) {
      return null;
    }
    var year = date.getFullYear();
    var month = "0".concat(date.getMonth() + 1).slice(-2);
    var day = "0".concat(date.getDate()).slice(-2);
    return "".concat(year, "-").concat(month, "-").concat(day);
  };
  var resolveLocale = function resolveLocale2(locales) {
    var calendar = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CALENDAR_GREGORY;
    locales = concat(locales).filter(identity);
    var fmt = new Intl.DateTimeFormat(locales, {
      calendar
    });
    return fmt.resolvedOptions().locale;
  };
  var createDateFormatter = function createDateFormatter2(locale, options) {
    var dtf = new Intl.DateTimeFormat(locale, options);
    return dtf.format;
  };
  var datesEqual = function datesEqual2(date1, date2) {
    return formatYMD(date1) === formatYMD(date2);
  };
  var firstDateOfMonth = function firstDateOfMonth2(date) {
    date = createDate(date);
    date.setDate(1);
    return date;
  };
  var lastDateOfMonth = function lastDateOfMonth2(date) {
    date = createDate(date);
    date.setMonth(date.getMonth() + 1);
    date.setDate(0);
    return date;
  };
  var addYears = function addYears2(date, numberOfYears) {
    date = createDate(date);
    var month = date.getMonth();
    date.setFullYear(date.getFullYear() + numberOfYears);
    if (date.getMonth() !== month) {
      date.setDate(0);
    }
    return date;
  };
  var oneMonthAgo = function oneMonthAgo2(date) {
    date = createDate(date);
    var month = date.getMonth();
    date.setMonth(month - 1);
    if (date.getMonth() === month) {
      date.setDate(0);
    }
    return date;
  };
  var oneMonthAhead = function oneMonthAhead2(date) {
    date = createDate(date);
    var month = date.getMonth();
    date.setMonth(month + 1);
    if (date.getMonth() === (month + 2) % 12) {
      date.setDate(0);
    }
    return date;
  };
  var oneYearAgo = function oneYearAgo2(date) {
    return addYears(date, -1);
  };
  var oneYearAhead = function oneYearAhead2(date) {
    return addYears(date, 1);
  };
  var oneDecadeAgo = function oneDecadeAgo2(date) {
    return addYears(date, -10);
  };
  var oneDecadeAhead = function oneDecadeAhead2(date) {
    return addYears(date, 10);
  };
  var constrainDate = function constrainDate2(date) {
    var min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    date = parseYMD(date);
    min = parseYMD(min) || date;
    max = parseYMD(max) || date;
    return date ? date < min ? min : date > max ? max : date : null;
  };
  var RTL_LANGS = ["ar", "az", "ckb", "fa", "he", "ks", "lrc", "mzn", "ps", "sd", "te", "ug", "ur", "yi"].map(function(locale) {
    return locale.toLowerCase();
  });
  var isLocaleRTL = function isLocaleRTL2(locale) {
    var parts = toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS, "").split("-");
    var locale1 = parts.slice(0, 2).join("-");
    var locale2 = parts[0];
    return arrayIncludes(RTL_LANGS, locale1) || arrayIncludes(RTL_LANGS, locale2);
  };
  var props$25 = {
    id: makeProp(PROP_TYPE_STRING)
  };
  var idMixin = extend({
    props: props$25,
    data: function data() {
      return {
        localId_: null
      };
    },
    computed: {
      safeId: function safeId() {
        var id = this.id || this.localId_;
        var fn = function fn2(suffix) {
          if (!id) {
            return null;
          }
          suffix = String(suffix || "").replace(/\s+/g, "_");
          return suffix ? id + "_" + suffix : id;
        };
        return fn;
      }
    },
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function() {
        _this.localId_ = "__BVID__".concat(_this[COMPONENT_UID_KEY]);
      });
    }
  });
  var _watch$j;
  function ownKeys$1n(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1n(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1n(Object(source), true).forEach(function(key) {
        _defineProperty$1G(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1n(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1G(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$j = makeModelMixin("value", {
    type: PROP_TYPE_DATE_STRING
  }), modelMixin$i = _makeModelMixin$j.mixin, modelProps$i = _makeModelMixin$j.props, MODEL_PROP_NAME$i = _makeModelMixin$j.prop, MODEL_EVENT_NAME$i = _makeModelMixin$j.event;
  var props$24 = makePropsConfigurable(sortKeys(_objectSpread$1n(_objectSpread$1n(_objectSpread$1n({}, props$25), modelProps$i), {}, {
    ariaControls: makeProp(PROP_TYPE_STRING),
    // Makes calendar the full width of its parent container
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    dateDisabledFn: makeProp(PROP_TYPE_FUNCTION),
    // `Intl.DateTimeFormat` object
    dateFormatOptions: makeProp(PROP_TYPE_OBJECT, {
      year: DATE_FORMAT_NUMERIC,
      month: CALENDAR_LONG,
      day: DATE_FORMAT_NUMERIC,
      weekday: CALENDAR_LONG
    }),
    // Function to set a class of (classes) on the date cell
    // if passed a string or an array
    // TODO:
    //   If the function returns an object, look for class prop for classes,
    //   and other props for handling events/details/descriptions
    dateInfoFn: makeProp(PROP_TYPE_FUNCTION),
    // 'ltr', 'rtl', or `null` (for auto detect)
    direction: makeProp(PROP_TYPE_STRING),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    // When `true`, renders a comment node, but keeps the component instance active
    // Mainly for <b-form-date>, so that we can get the component's value and locale
    // But we might just use separate date formatters, using the resolved locale
    // (adjusted for the gregorian calendar)
    hidden: makeProp(PROP_TYPE_BOOLEAN, false),
    // When `true` makes the selected date header `sr-only`
    hideHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    // This specifies the calendar year/month/day that will be shown when
    // first opening the datepicker if no v-model value is provided
    // Default is the current date (or `min`/`max`)
    initialDate: makeProp(PROP_TYPE_DATE_STRING),
    // Labels for buttons and keyboard shortcuts
    labelCalendar: makeProp(PROP_TYPE_STRING, "Calendar"),
    labelCurrentMonth: makeProp(PROP_TYPE_STRING, "Current month"),
    labelHelp: makeProp(PROP_TYPE_STRING, "Use cursor keys to navigate calendar dates"),
    labelNav: makeProp(PROP_TYPE_STRING, "Calendar navigation"),
    labelNextDecade: makeProp(PROP_TYPE_STRING, "Next decade"),
    labelNextMonth: makeProp(PROP_TYPE_STRING, "Next month"),
    labelNextYear: makeProp(PROP_TYPE_STRING, "Next year"),
    labelNoDateSelected: makeProp(PROP_TYPE_STRING, "No date selected"),
    labelPrevDecade: makeProp(PROP_TYPE_STRING, "Previous decade"),
    labelPrevMonth: makeProp(PROP_TYPE_STRING, "Previous month"),
    labelPrevYear: makeProp(PROP_TYPE_STRING, "Previous year"),
    labelSelected: makeProp(PROP_TYPE_STRING, "Selected date"),
    labelToday: makeProp(PROP_TYPE_STRING, "Today"),
    // Locale(s) to use
    // Default is to use page/browser default setting
    locale: makeProp(PROP_TYPE_ARRAY_STRING),
    max: makeProp(PROP_TYPE_DATE_STRING),
    min: makeProp(PROP_TYPE_DATE_STRING),
    // Variant color to use for the navigation buttons
    navButtonVariant: makeProp(PROP_TYPE_STRING, "secondary"),
    // Disable highlighting today's date
    noHighlightToday: makeProp(PROP_TYPE_BOOLEAN, false),
    noKeyNav: makeProp(PROP_TYPE_BOOLEAN, false),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    roleDescription: makeProp(PROP_TYPE_STRING),
    // Variant color to use for the selected date
    selectedVariant: makeProp(PROP_TYPE_STRING, "primary"),
    // When `true` enables the decade navigation buttons
    showDecadeNav: makeProp(PROP_TYPE_BOOLEAN, false),
    // Day of week to start calendar on
    // `0` (Sunday), `1` (Monday), ... `6` (Saturday)
    startWeekday: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    // Variant color to use for today's date (defaults to `selectedVariant`)
    todayVariant: makeProp(PROP_TYPE_STRING),
    // Always return the `v-model` value as a date object
    valueAsDate: makeProp(PROP_TYPE_BOOLEAN, false),
    // Format of the weekday names at the top of the calendar
    // `short` is typically a 3 letter abbreviation,
    // `narrow` is typically a single letter
    // `long` is the full week day name
    // Although some locales may override this (i.e `ar`, etc.)
    weekdayHeaderFormat: makeProp(PROP_TYPE_STRING, CALENDAR_SHORT, function(value) {
      return arrayIncludes([CALENDAR_LONG, CALENDAR_SHORT, CALENDAR_NARROW], value);
    }),
    // Has no effect if prop `block` is set
    width: makeProp(PROP_TYPE_STRING, "270px")
  })), NAME_CALENDAR);
  var BCalendar = extend({
    name: NAME_CALENDAR,
    // Mixin order is important!
    mixins: [attrsMixin, idMixin, modelMixin$i, normalizeSlotMixin],
    props: props$24,
    data: function data() {
      var selected = formatYMD(this[MODEL_PROP_NAME$i]) || "";
      return {
        // Selected date
        selectedYMD: selected,
        // Date in calendar grid that has `tabindex` of `0`
        activeYMD: selected || formatYMD(constrainDate(this.initialDate || this.getToday()), this.min, this.max),
        // Will be true if the calendar grid has/contains focus
        gridHasFocus: false,
        // Flag to enable the `aria-live` region(s) after mount
        // to prevent screen reader "outbursts" when mounting
        isLive: false
      };
    },
    computed: {
      valueId: function valueId() {
        return this.safeId();
      },
      widgetId: function widgetId() {
        return this.safeId("_calendar-wrapper_");
      },
      navId: function navId() {
        return this.safeId("_calendar-nav_");
      },
      gridId: function gridId() {
        return this.safeId("_calendar-grid_");
      },
      gridCaptionId: function gridCaptionId() {
        return this.safeId("_calendar-grid-caption_");
      },
      gridHelpId: function gridHelpId() {
        return this.safeId("_calendar-grid-help_");
      },
      activeId: function activeId() {
        return this.activeYMD ? this.safeId("_cell-".concat(this.activeYMD, "_")) : null;
      },
      // TODO: Use computed props to convert `YYYY-MM-DD` to `Date` object
      selectedDate: function selectedDate() {
        return parseYMD(this.selectedYMD);
      },
      activeDate: function activeDate() {
        return parseYMD(this.activeYMD);
      },
      computedMin: function computedMin() {
        return parseYMD(this.min);
      },
      computedMax: function computedMax() {
        return parseYMD(this.max);
      },
      computedWeekStarts: function computedWeekStarts() {
        return mathMax(toInteger(this.startWeekday, 0), 0) % 7;
      },
      computedLocale: function computedLocale() {
        return resolveLocale(concat(this.locale).filter(identity), CALENDAR_GREGORY);
      },
      computedDateDisabledFn: function computedDateDisabledFn() {
        var dateDisabledFn = this.dateDisabledFn;
        return hasPropFunction(dateDisabledFn) ? dateDisabledFn : function() {
          return false;
        };
      },
      // TODO: Change `dateInfoFn` to handle events and notes as well as classes
      computedDateInfoFn: function computedDateInfoFn() {
        var dateInfoFn = this.dateInfoFn;
        return hasPropFunction(dateInfoFn) ? dateInfoFn : function() {
          return {};
        };
      },
      calendarLocale: function calendarLocale() {
        var fmt = new Intl.DateTimeFormat(this.computedLocale, {
          calendar: CALENDAR_GREGORY
        });
        var calendar = fmt.resolvedOptions().calendar;
        var locale = fmt.resolvedOptions().locale;
        if (calendar !== CALENDAR_GREGORY) {
          locale = locale.replace(/-u-.+$/i, "").concat("-u-ca-gregory");
        }
        return locale;
      },
      calendarYear: function calendarYear() {
        return this.activeDate.getFullYear();
      },
      calendarMonth: function calendarMonth() {
        return this.activeDate.getMonth();
      },
      calendarFirstDay: function calendarFirstDay() {
        return createDate(this.calendarYear, this.calendarMonth, 1, 12);
      },
      calendarDaysInMonth: function calendarDaysInMonth() {
        var date = createDate(this.calendarFirstDay);
        date.setMonth(date.getMonth() + 1, 0);
        return date.getDate();
      },
      computedVariant: function computedVariant() {
        return "btn-".concat(this.selectedVariant || "primary");
      },
      computedTodayVariant: function computedTodayVariant() {
        return "btn-outline-".concat(this.todayVariant || this.selectedVariant || "primary");
      },
      computedNavButtonVariant: function computedNavButtonVariant() {
        return "btn-outline-".concat(this.navButtonVariant || "primary");
      },
      isRTL: function isRTL() {
        var dir = toString(this.direction).toLowerCase();
        if (dir === "rtl") {
          return true;
        } else if (dir === "ltr") {
          return false;
        }
        return isLocaleRTL(this.computedLocale);
      },
      context: function context() {
        var selectedYMD = this.selectedYMD, activeYMD = this.activeYMD;
        var selectedDate = parseYMD(selectedYMD);
        var activeDate = parseYMD(activeYMD);
        return {
          // The current value of the `v-model`
          selectedYMD,
          selectedDate,
          selectedFormatted: selectedDate ? this.formatDateString(selectedDate) : this.labelNoDateSelected,
          // Which date cell is considered active due to navigation
          activeYMD,
          activeDate,
          activeFormatted: activeDate ? this.formatDateString(activeDate) : "",
          // `true` if the date is disabled (when using keyboard navigation)
          disabled: this.dateDisabled(activeDate),
          // Locales used in formatting dates
          locale: this.computedLocale,
          calendarLocale: this.calendarLocale,
          rtl: this.isRTL
        };
      },
      // Computed props that return a function reference
      dateOutOfRange: function dateOutOfRange() {
        var min = this.computedMin, max = this.computedMax;
        return function(date) {
          date = parseYMD(date);
          return min && date < min || max && date > max;
        };
      },
      dateDisabled: function dateDisabled() {
        var _this = this;
        var rangeFn = this.dateOutOfRange;
        return function(date) {
          date = parseYMD(date);
          var ymd = formatYMD(date);
          return !!(rangeFn(date) || _this.computedDateDisabledFn(ymd, date));
        };
      },
      // Computed props that return date formatter functions
      formatDateString: function formatDateString() {
        return createDateFormatter(this.calendarLocale, _objectSpread$1n(_objectSpread$1n({
          // Ensure we have year, month, day shown for screen readers/ARIA
          // If users really want to leave one of these out, they can
          // pass `undefined` for the property value
          year: DATE_FORMAT_NUMERIC,
          month: DATE_FORMAT_2_DIGIT,
          day: DATE_FORMAT_2_DIGIT
        }, this.dateFormatOptions), {}, {
          // Ensure hours/minutes/seconds are not shown
          // As we do not support the time portion (yet)
          hour: void 0,
          minute: void 0,
          second: void 0,
          // Ensure calendar is gregorian
          calendar: CALENDAR_GREGORY
        }));
      },
      formatYearMonth: function formatYearMonth() {
        return createDateFormatter(this.calendarLocale, {
          year: DATE_FORMAT_NUMERIC,
          month: CALENDAR_LONG,
          calendar: CALENDAR_GREGORY
        });
      },
      formatWeekdayName: function formatWeekdayName() {
        return createDateFormatter(this.calendarLocale, {
          weekday: CALENDAR_LONG,
          calendar: CALENDAR_GREGORY
        });
      },
      formatWeekdayNameShort: function formatWeekdayNameShort() {
        return createDateFormatter(this.calendarLocale, {
          weekday: this.weekdayHeaderFormat || CALENDAR_SHORT,
          calendar: CALENDAR_GREGORY
        });
      },
      formatDay: function formatDay() {
        var nf = new Intl.NumberFormat([this.computedLocale], {
          style: "decimal",
          minimumIntegerDigits: 1,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          notation: "standard"
        });
        return function(date) {
          return nf.format(date.getDate());
        };
      },
      // Disabled states for the nav buttons
      prevDecadeDisabled: function prevDecadeDisabled() {
        var min = this.computedMin;
        return this.disabled || min && lastDateOfMonth(oneDecadeAgo(this.activeDate)) < min;
      },
      prevYearDisabled: function prevYearDisabled() {
        var min = this.computedMin;
        return this.disabled || min && lastDateOfMonth(oneYearAgo(this.activeDate)) < min;
      },
      prevMonthDisabled: function prevMonthDisabled() {
        var min = this.computedMin;
        return this.disabled || min && lastDateOfMonth(oneMonthAgo(this.activeDate)) < min;
      },
      thisMonthDisabled: function thisMonthDisabled() {
        return this.disabled;
      },
      nextMonthDisabled: function nextMonthDisabled() {
        var max = this.computedMax;
        return this.disabled || max && firstDateOfMonth(oneMonthAhead(this.activeDate)) > max;
      },
      nextYearDisabled: function nextYearDisabled() {
        var max = this.computedMax;
        return this.disabled || max && firstDateOfMonth(oneYearAhead(this.activeDate)) > max;
      },
      nextDecadeDisabled: function nextDecadeDisabled() {
        var max = this.computedMax;
        return this.disabled || max && firstDateOfMonth(oneDecadeAhead(this.activeDate)) > max;
      },
      // Calendar dates generation
      calendar: function calendar() {
        var matrix = [];
        var firstDay = this.calendarFirstDay;
        var calendarYear = firstDay.getFullYear();
        var calendarMonth = firstDay.getMonth();
        var daysInMonth = this.calendarDaysInMonth;
        var startIndex = firstDay.getDay();
        var weekOffset = (this.computedWeekStarts > startIndex ? 7 : 0) - this.computedWeekStarts;
        var currentDay = 0 - weekOffset - startIndex;
        for (var week = 0; week < 6 && currentDay < daysInMonth; week++) {
          matrix[week] = [];
          for (var j = 0; j < 7; j++) {
            currentDay++;
            var date = createDate(calendarYear, calendarMonth, currentDay);
            var month = date.getMonth();
            var dayYMD = formatYMD(date);
            var dayDisabled = this.dateDisabled(date);
            var dateInfo = this.computedDateInfoFn(dayYMD, parseYMD(dayYMD));
            dateInfo = isString(dateInfo) || isArray(dateInfo) ? (
              /* istanbul ignore next */
              {
                class: dateInfo
              }
            ) : isPlainObject(dateInfo) ? _objectSpread$1n({
              class: ""
            }, dateInfo) : (
              /* istanbul ignore next */
              {
                class: ""
              }
            );
            matrix[week].push({
              ymd: dayYMD,
              // Cell content
              day: this.formatDay(date),
              label: this.formatDateString(date),
              // Flags for styling
              isThisMonth: month === calendarMonth,
              isDisabled: dayDisabled,
              // TODO: Handle other dateInfo properties such as notes/events
              info: dateInfo
            });
          }
        }
        return matrix;
      },
      calendarHeadings: function calendarHeadings() {
        var _this2 = this;
        return this.calendar[0].map(function(d) {
          return {
            text: _this2.formatWeekdayNameShort(parseYMD(d.ymd)),
            label: _this2.formatWeekdayName(parseYMD(d.ymd))
          };
        });
      }
    },
    watch: (_watch$j = {}, _defineProperty$1G(_watch$j, MODEL_PROP_NAME$i, function(newValue, oldValue) {
      var selected = formatYMD(newValue) || "";
      var old = formatYMD(oldValue) || "";
      if (!datesEqual(selected, old)) {
        this.activeYMD = selected || this.activeYMD;
        this.selectedYMD = selected;
      }
    }), _defineProperty$1G(_watch$j, "selectedYMD", function selectedYMD(newYMD, oldYMD) {
      if (newYMD !== oldYMD) {
        this.$emit(MODEL_EVENT_NAME$i, this.valueAsDate ? parseYMD(newYMD) || null : newYMD || "");
      }
    }), _defineProperty$1G(_watch$j, "context", function context(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.$emit(EVENT_NAME_CONTEXT, newValue);
      }
    }), _defineProperty$1G(_watch$j, "hidden", function hidden(newValue) {
      this.activeYMD = this.selectedYMD || formatYMD(this[MODEL_PROP_NAME$i] || this.constrainDate(this.initialDate || this.getToday()));
      this.setLive(!newValue);
    }), _watch$j),
    created: function created() {
      var _this3 = this;
      this.$nextTick(function() {
        _this3.$emit(EVENT_NAME_CONTEXT, _this3.context);
      });
    },
    mounted: function mounted() {
      this.setLive(true);
    },
    /* istanbul ignore next */
    activated: function activated() {
      this.setLive(true);
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.setLive(false);
    },
    beforeDestroy: function beforeDestroy() {
      this.setLive(false);
    },
    methods: {
      // Public method(s)
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.grid);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$refs.grid);
        }
      },
      // Private methods
      setLive: function setLive(on) {
        var _this4 = this;
        if (on) {
          this.$nextTick(function() {
            requestAF(function() {
              _this4.isLive = true;
            });
          });
        } else {
          this.isLive = false;
        }
      },
      getToday: function getToday() {
        return parseYMD(createDate());
      },
      constrainDate: function constrainDate$1(date) {
        return constrainDate(date, this.computedMin, this.computedMax);
      },
      emitSelected: function emitSelected(date) {
        var _this5 = this;
        this.$nextTick(function() {
          _this5.$emit(EVENT_NAME_SELECTED, formatYMD(date) || "", parseYMD(date) || null);
        });
      },
      // Event handlers
      setGridFocusFlag: function setGridFocusFlag(event2) {
        this.gridHasFocus = !this.disabled && event2.type === "focus";
      },
      onKeydownWrapper: function onKeydownWrapper(event2) {
        if (this.noKeyNav) {
          return;
        }
        var altKey = event2.altKey, ctrlKey = event2.ctrlKey, keyCode = event2.keyCode;
        if (!arrayIncludes([CODE_PAGEUP, CODE_PAGEDOWN, CODE_END, CODE_HOME, CODE_LEFT, CODE_UP, CODE_RIGHT, CODE_DOWN], keyCode)) {
          return;
        }
        stopEvent(event2);
        var activeDate = createDate(this.activeDate);
        var checkDate = createDate(this.activeDate);
        var day = activeDate.getDate();
        var constrainedToday = this.constrainDate(this.getToday());
        var isRTL = this.isRTL;
        if (keyCode === CODE_PAGEUP) {
          activeDate = (altKey ? ctrlKey ? oneDecadeAgo : oneYearAgo : oneMonthAgo)(activeDate);
          checkDate = createDate(activeDate);
          checkDate.setDate(1);
        } else if (keyCode === CODE_PAGEDOWN) {
          activeDate = (altKey ? ctrlKey ? oneDecadeAhead : oneYearAhead : oneMonthAhead)(activeDate);
          checkDate = createDate(activeDate);
          checkDate.setMonth(checkDate.getMonth() + 1);
          checkDate.setDate(0);
        } else if (keyCode === CODE_LEFT) {
          activeDate.setDate(day + (isRTL ? 1 : -1));
          activeDate = this.constrainDate(activeDate);
          checkDate = activeDate;
        } else if (keyCode === CODE_RIGHT) {
          activeDate.setDate(day + (isRTL ? -1 : 1));
          activeDate = this.constrainDate(activeDate);
          checkDate = activeDate;
        } else if (keyCode === CODE_UP) {
          activeDate.setDate(day - 7);
          activeDate = this.constrainDate(activeDate);
          checkDate = activeDate;
        } else if (keyCode === CODE_DOWN) {
          activeDate.setDate(day + 7);
          activeDate = this.constrainDate(activeDate);
          checkDate = activeDate;
        } else if (keyCode === CODE_HOME) {
          activeDate = constrainedToday;
          checkDate = activeDate;
        } else if (keyCode === CODE_END) {
          activeDate = parseYMD(this.selectedDate) || constrainedToday;
          checkDate = activeDate;
        }
        if (!this.dateOutOfRange(checkDate) && !datesEqual(activeDate, this.activeDate)) {
          this.activeYMD = formatYMD(activeDate);
        }
        this.focus();
      },
      onKeydownGrid: function onKeydownGrid(event2) {
        var keyCode = event2.keyCode;
        var activeDate = this.activeDate;
        if (keyCode === CODE_ENTER || keyCode === CODE_SPACE) {
          stopEvent(event2);
          if (!this.disabled && !this.readonly && !this.dateDisabled(activeDate)) {
            this.selectedYMD = formatYMD(activeDate);
            this.emitSelected(activeDate);
          }
          this.focus();
        }
      },
      onClickDay: function onClickDay(day) {
        var selectedDate = this.selectedDate, activeDate = this.activeDate;
        var clickedDate = parseYMD(day.ymd);
        if (!this.disabled && !day.isDisabled && !this.dateDisabled(clickedDate)) {
          if (!this.readonly) {
            this.selectedYMD = formatYMD(datesEqual(clickedDate, selectedDate) ? selectedDate : clickedDate);
            this.emitSelected(clickedDate);
          }
          this.activeYMD = formatYMD(datesEqual(clickedDate, activeDate) ? activeDate : createDate(clickedDate));
          this.focus();
        }
      },
      gotoPrevDecade: function gotoPrevDecade() {
        this.activeYMD = formatYMD(this.constrainDate(oneDecadeAgo(this.activeDate)));
      },
      gotoPrevYear: function gotoPrevYear() {
        this.activeYMD = formatYMD(this.constrainDate(oneYearAgo(this.activeDate)));
      },
      gotoPrevMonth: function gotoPrevMonth() {
        this.activeYMD = formatYMD(this.constrainDate(oneMonthAgo(this.activeDate)));
      },
      gotoCurrentMonth: function gotoCurrentMonth() {
        this.activeYMD = formatYMD(this.constrainDate(this.getToday()));
      },
      gotoNextMonth: function gotoNextMonth() {
        this.activeYMD = formatYMD(this.constrainDate(oneMonthAhead(this.activeDate)));
      },
      gotoNextYear: function gotoNextYear() {
        this.activeYMD = formatYMD(this.constrainDate(oneYearAhead(this.activeDate)));
      },
      gotoNextDecade: function gotoNextDecade() {
        this.activeYMD = formatYMD(this.constrainDate(oneDecadeAhead(this.activeDate)));
      },
      onHeaderClick: function onHeaderClick() {
        if (!this.disabled) {
          this.activeYMD = this.selectedYMD || formatYMD(this.getToday());
          this.focus();
        }
      }
    },
    render: function render(h) {
      var _this6 = this;
      if (this.hidden) {
        return h();
      }
      var valueId = this.valueId, widgetId = this.widgetId, navId = this.navId, gridId = this.gridId, gridCaptionId = this.gridCaptionId, gridHelpId = this.gridHelpId, activeId = this.activeId, disabled = this.disabled, noKeyNav = this.noKeyNav, isLive = this.isLive, isRTL = this.isRTL, activeYMD = this.activeYMD, selectedYMD = this.selectedYMD, safeId = this.safeId;
      var hideDecadeNav = !this.showDecadeNav;
      var todayYMD = formatYMD(this.getToday());
      var highlightToday = !this.noHighlightToday;
      var $header = h(
        "output",
        {
          staticClass: "form-control form-control-sm text-center",
          class: {
            "text-muted": disabled,
            readonly: this.readonly || disabled
          },
          attrs: {
            id: valueId,
            for: gridId,
            role: "status",
            tabindex: disabled ? null : "-1",
            // Mainly for testing purposes, as we do not know
            // the exact format `Intl` will format the date string
            "data-selected": toString(selectedYMD),
            // We wait until after mount to enable `aria-live`
            // to prevent initial announcement on page render
            "aria-live": isLive ? "polite" : "off",
            "aria-atomic": isLive ? "true" : null
          },
          on: {
            // Transfer focus/click to focus grid
            // and focus active date (or today if no selection)
            click: this.onHeaderClick,
            focus: this.onHeaderClick
          }
        },
        this.selectedDate ? [
          // We use `bdi` elements here in case the label doesn't match the locale
          // Although IE 11 does not deal with <BDI> at all (equivalent to a span)
          h("bdi", {
            staticClass: "sr-only"
          }, " (".concat(toString(this.labelSelected), ") ")),
          h("bdi", this.formatDateString(this.selectedDate))
        ] : this.labelNoDateSelected || " "
        // '&nbsp;'
      );
      $header = h(this.headerTag, {
        staticClass: "b-calendar-header",
        class: {
          "sr-only": this.hideHeader
        },
        attrs: {
          title: this.selectedDate ? this.labelSelected || null : null
        }
      }, [$header]);
      var navScope = {
        isRTL
      };
      var navProps2 = {
        shiftV: 0.5
      };
      var navPrevProps = _objectSpread$1n(_objectSpread$1n({}, navProps2), {}, {
        flipH: isRTL
      });
      var navNextProps = _objectSpread$1n(_objectSpread$1n({}, navProps2), {}, {
        flipH: !isRTL
      });
      var $prevDecadeIcon = this.normalizeSlot(SLOT_NAME_NAV_PEV_DECADE, navScope) || h(BIconChevronBarLeft, {
        props: navPrevProps
      });
      var $prevYearIcon = this.normalizeSlot(SLOT_NAME_NAV_PEV_YEAR, navScope) || h(BIconChevronDoubleLeft, {
        props: navPrevProps
      });
      var $prevMonthIcon = this.normalizeSlot(SLOT_NAME_NAV_PEV_MONTH, navScope) || h(BIconChevronLeft, {
        props: navPrevProps
      });
      var $thisMonthIcon = this.normalizeSlot(SLOT_NAME_NAV_THIS_MONTH, navScope) || h(BIconCircleFill, {
        props: navProps2
      });
      var $nextMonthIcon = this.normalizeSlot(SLOT_NAME_NAV_NEXT_MONTH, navScope) || h(BIconChevronLeft, {
        props: navNextProps
      });
      var $nextYearIcon = this.normalizeSlot(SLOT_NAME_NAV_NEXT_YEAR, navScope) || h(BIconChevronDoubleLeft, {
        props: navNextProps
      });
      var $nextDecadeIcon = this.normalizeSlot(SLOT_NAME_NAV_NEXT_DECADE, navScope) || h(BIconChevronBarLeft, {
        props: navNextProps
      });
      var makeNavBtn = function makeNavBtn2(content, label, handler, btnDisabled, shortcut) {
        return h("button", {
          staticClass: "btn btn-sm border-0 flex-fill",
          class: [_this6.computedNavButtonVariant, {
            disabled: btnDisabled
          }],
          attrs: {
            title: label || null,
            type: "button",
            tabindex: noKeyNav ? "-1" : null,
            "aria-label": label || null,
            "aria-disabled": btnDisabled ? "true" : null,
            "aria-keyshortcuts": shortcut || null
          },
          on: btnDisabled ? {} : {
            click: handler
          }
        }, [h("div", {
          attrs: {
            "aria-hidden": "true"
          }
        }, [content])]);
      };
      var $nav = h("div", {
        staticClass: "b-calendar-nav d-flex",
        attrs: {
          id: navId,
          role: "group",
          tabindex: noKeyNav ? "-1" : null,
          "aria-hidden": disabled ? "true" : null,
          "aria-label": this.labelNav || null,
          "aria-controls": gridId
        }
      }, [hideDecadeNav ? h() : makeNavBtn($prevDecadeIcon, this.labelPrevDecade, this.gotoPrevDecade, this.prevDecadeDisabled, "Ctrl+Alt+PageDown"), makeNavBtn($prevYearIcon, this.labelPrevYear, this.gotoPrevYear, this.prevYearDisabled, "Alt+PageDown"), makeNavBtn($prevMonthIcon, this.labelPrevMonth, this.gotoPrevMonth, this.prevMonthDisabled, "PageDown"), makeNavBtn($thisMonthIcon, this.labelCurrentMonth, this.gotoCurrentMonth, this.thisMonthDisabled, "Home"), makeNavBtn($nextMonthIcon, this.labelNextMonth, this.gotoNextMonth, this.nextMonthDisabled, "PageUp"), makeNavBtn($nextYearIcon, this.labelNextYear, this.gotoNextYear, this.nextYearDisabled, "Alt+PageUp"), hideDecadeNav ? h() : makeNavBtn($nextDecadeIcon, this.labelNextDecade, this.gotoNextDecade, this.nextDecadeDisabled, "Ctrl+Alt+PageUp")]);
      var $gridCaption = h("div", {
        staticClass: "b-calendar-grid-caption text-center font-weight-bold",
        class: {
          "text-muted": disabled
        },
        attrs: {
          id: gridCaptionId,
          "aria-live": isLive ? "polite" : null,
          "aria-atomic": isLive ? "true" : null
        },
        key: "grid-caption"
      }, this.formatYearMonth(this.calendarFirstDay));
      var $gridWeekDays = h("div", {
        staticClass: "b-calendar-grid-weekdays row no-gutters border-bottom",
        attrs: {
          "aria-hidden": "true"
        }
      }, this.calendarHeadings.map(function(d, idx) {
        return h("small", {
          staticClass: "col text-truncate",
          class: {
            "text-muted": disabled
          },
          attrs: {
            title: d.label === d.text ? null : d.label,
            "aria-label": d.label
          },
          key: idx
        }, d.text);
      }));
      var $gridBody = this.calendar.map(function(week) {
        var $cells = week.map(function(day, dIndex) {
          var _class;
          var isSelected = day.ymd === selectedYMD;
          var isActive = day.ymd === activeYMD;
          var isToday = day.ymd === todayYMD;
          var idCell = safeId("_cell-".concat(day.ymd, "_"));
          var $btn = h("span", {
            staticClass: "btn border-0 rounded-circle text-nowrap",
            // Should we add some classes to signify if today/selected/etc?
            class: (_class = {
              // Give the fake button a focus ring
              focus: isActive && _this6.gridHasFocus,
              // Styling
              disabled: day.isDisabled || disabled,
              active: isSelected
            }, _defineProperty$1G(_class, _this6.computedVariant, isSelected), _defineProperty$1G(_class, _this6.computedTodayVariant, isToday && highlightToday && !isSelected && day.isThisMonth), _defineProperty$1G(_class, "btn-outline-light", !(isToday && highlightToday) && !isSelected && !isActive), _defineProperty$1G(_class, "btn-light", !(isToday && highlightToday) && !isSelected && isActive), _defineProperty$1G(_class, "text-muted", !day.isThisMonth && !isSelected), _defineProperty$1G(_class, "text-dark", !(isToday && highlightToday) && !isSelected && !isActive && day.isThisMonth), _defineProperty$1G(_class, "font-weight-bold", (isSelected || day.isThisMonth) && !day.isDisabled), _class),
            on: {
              click: function click() {
                return _this6.onClickDay(day);
              }
            }
          }, day.day);
          return h(
            "div",
            // Cell with button
            {
              staticClass: "col p-0",
              class: day.isDisabled ? "bg-light" : day.info.class || "",
              attrs: {
                id: idCell,
                role: "button",
                "data-date": day.ymd,
                // Primarily for testing purposes
                // Only days in the month are presented as buttons to screen readers
                "aria-hidden": day.isThisMonth ? null : "true",
                "aria-disabled": day.isDisabled || disabled ? "true" : null,
                "aria-label": [day.label, isSelected ? "(".concat(_this6.labelSelected, ")") : null, isToday ? "(".concat(_this6.labelToday, ")") : null].filter(identity).join(" "),
                // NVDA doesn't convey `aria-selected`, but does `aria-current`,
                // ChromeVox doesn't convey `aria-current`, but does `aria-selected`,
                // so we set both attributes for robustness
                "aria-selected": isSelected ? "true" : null,
                "aria-current": isSelected ? "date" : null
              },
              key: dIndex
            },
            [$btn]
          );
        });
        return h("div", {
          staticClass: "row no-gutters",
          key: week[0].ymd
        }, $cells);
      });
      $gridBody = h("div", {
        // A key is only required on the body if we add in transition support
        staticClass: "b-calendar-grid-body",
        style: disabled ? {
          pointerEvents: "none"
        } : {}
        // key: this.activeYMD.slice(0, -3)
      }, $gridBody);
      var $gridHelp = h("div", {
        staticClass: "b-calendar-grid-help border-top small text-muted text-center bg-light",
        attrs: {
          id: gridHelpId
        }
      }, [h("div", {
        staticClass: "small"
      }, this.labelHelp)]);
      var $grid = h("div", {
        staticClass: "b-calendar-grid form-control h-auto text-center",
        attrs: {
          id: gridId,
          role: "application",
          tabindex: noKeyNav ? "-1" : disabled ? null : "0",
          "data-month": activeYMD.slice(0, -3),
          // `YYYY-MM`, mainly for testing
          "aria-roledescription": this.labelCalendar || null,
          "aria-labelledby": gridCaptionId,
          "aria-describedby": gridHelpId,
          // `aria-readonly` is not considered valid on `role="application"`
          // https://www.w3.org/TR/wai-aria-1.1/#aria-readonly
          // 'aria-readonly': this.readonly && !disabled ? 'true' : null,
          "aria-disabled": disabled ? "true" : null,
          "aria-activedescendant": activeId
        },
        on: {
          keydown: this.onKeydownGrid,
          focus: this.setGridFocusFlag,
          blur: this.setGridFocusFlag
        },
        ref: "grid"
      }, [$gridCaption, $gridWeekDays, $gridBody, $gridHelp]);
      var $slot = this.normalizeSlot();
      $slot = $slot ? h("footer", {
        staticClass: "b-calendar-footer"
      }, $slot) : h();
      var $widget = h("div", {
        staticClass: "b-calendar-inner",
        style: this.block ? {} : {
          width: this.width
        },
        attrs: {
          id: widgetId,
          dir: isRTL ? "rtl" : "ltr",
          lang: this.computedLocale || null,
          role: "group",
          "aria-disabled": disabled ? "true" : null,
          // If datepicker controls an input, this will specify the ID of the input
          "aria-controls": this.ariaControls || null,
          // This should be a prop (so it can be changed to Date picker, etc, localized
          "aria-roledescription": this.roleDescription || null,
          "aria-describedby": [
            // Should the attr (if present) go last?
            // Or should this attr be a prop?
            this.bvAttrs["aria-describedby"],
            valueId,
            gridHelpId
          ].filter(identity).join(" ")
        },
        on: {
          keydown: this.onKeydownWrapper
        }
      }, [$header, $nav, $grid, $slot]);
      return h("div", {
        staticClass: "b-calendar",
        class: {
          "d-block": this.block
        }
      }, [$widget]);
    }
  });
  var CalendarPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BCalendar
    }
  });
  var props$23 = makePropsConfigurable({
    bgVariant: makeProp(PROP_TYPE_STRING),
    borderVariant: makeProp(PROP_TYPE_STRING),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    textVariant: makeProp(PROP_TYPE_STRING)
  }, NAME_CARD);
  extend({
    props: props$23
  });
  var props$22 = makePropsConfigurable({
    title: makeProp(PROP_TYPE_STRING),
    titleTag: makeProp(PROP_TYPE_STRING, "h4")
  }, NAME_CARD_TITLE);
  var BCardTitle = /* @__PURE__ */ extend({
    name: NAME_CARD_TITLE,
    functional: true,
    props: props$22,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.titleTag, a(data, {
        staticClass: "card-title"
      }), children || toString(props2.title));
    }
  });
  var props$21 = makePropsConfigurable({
    subTitle: makeProp(PROP_TYPE_STRING),
    subTitleTag: makeProp(PROP_TYPE_STRING, "h6"),
    subTitleTextVariant: makeProp(PROP_TYPE_STRING, "muted")
  }, NAME_CARD_SUB_TITLE);
  var BCardSubTitle = /* @__PURE__ */ extend({
    name: NAME_CARD_SUB_TITLE,
    functional: true,
    props: props$21,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.subTitleTag, a(data, {
        staticClass: "card-subtitle",
        class: [props2.subTitleTextVariant ? "text-".concat(props2.subTitleTextVariant) : null]
      }), children || toString(props2.subTitle));
    }
  });
  function ownKeys$1m(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1m(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1m(Object(source), true).forEach(function(key) {
        _defineProperty$1F(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1m(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1F(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$20 = makePropsConfigurable(sortKeys(_objectSpread$1m(_objectSpread$1m(_objectSpread$1m(_objectSpread$1m({}, props$22), props$21), copyProps(props$23, prefixPropName.bind(null, "body"))), {}, {
    bodyClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    overlay: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_CARD_BODY);
  var BCardBody = /* @__PURE__ */ extend({
    name: NAME_CARD_BODY,
    functional: true,
    props: props$20,
    render: function render(h, _ref) {
      var _ref2;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var bodyBgVariant = props2.bodyBgVariant, bodyBorderVariant = props2.bodyBorderVariant, bodyTextVariant = props2.bodyTextVariant;
      var $title = h();
      if (props2.title) {
        $title = h(BCardTitle, {
          props: pluckProps(props$22, props2)
        });
      }
      var $subTitle = h();
      if (props2.subTitle) {
        $subTitle = h(BCardSubTitle, {
          props: pluckProps(props$21, props2),
          class: ["mb-2"]
        });
      }
      return h(props2.bodyTag, a(data, {
        staticClass: "card-body",
        class: [(_ref2 = {
          "card-img-overlay": props2.overlay
        }, _defineProperty$1F(_ref2, "bg-".concat(bodyBgVariant), bodyBgVariant), _defineProperty$1F(_ref2, "border-".concat(bodyBorderVariant), bodyBorderVariant), _defineProperty$1F(_ref2, "text-".concat(bodyTextVariant), bodyTextVariant), _ref2), props2.bodyClass]
      }), [$title, $subTitle, children]);
    }
  });
  function ownKeys$1l(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1l(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1l(Object(source), true).forEach(function(key) {
        _defineProperty$1E(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1l(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1E(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1$ = makePropsConfigurable(sortKeys(_objectSpread$1l(_objectSpread$1l({}, copyProps(props$23, prefixPropName.bind(null, "header"))), {}, {
    header: makeProp(PROP_TYPE_STRING),
    headerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerHtml: makeProp(PROP_TYPE_STRING)
  })), NAME_CARD_HEADER);
  var BCardHeader = /* @__PURE__ */ extend({
    name: NAME_CARD_HEADER,
    functional: true,
    props: props$1$,
    render: function render(h, _ref) {
      var _ref2;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var headerBgVariant = props2.headerBgVariant, headerBorderVariant = props2.headerBorderVariant, headerTextVariant = props2.headerTextVariant;
      return h(props2.headerTag, a(data, {
        staticClass: "card-header",
        class: [props2.headerClass, (_ref2 = {}, _defineProperty$1E(_ref2, "bg-".concat(headerBgVariant), headerBgVariant), _defineProperty$1E(_ref2, "border-".concat(headerBorderVariant), headerBorderVariant), _defineProperty$1E(_ref2, "text-".concat(headerTextVariant), headerTextVariant), _ref2)],
        domProps: children ? {} : htmlOrText(props2.headerHtml, props2.header)
      }), children);
    }
  });
  function ownKeys$1k(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1k(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1k(Object(source), true).forEach(function(key) {
        _defineProperty$1D(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1k(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1D(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1_ = makePropsConfigurable(sortKeys(_objectSpread$1k(_objectSpread$1k({}, copyProps(props$23, prefixPropName.bind(null, "footer"))), {}, {
    footer: makeProp(PROP_TYPE_STRING),
    footerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    footerHtml: makeProp(PROP_TYPE_STRING)
  })), NAME_CARD_FOOTER);
  var BCardFooter = /* @__PURE__ */ extend({
    name: NAME_CARD_FOOTER,
    functional: true,
    props: props$1_,
    render: function render(h, _ref) {
      var _ref2;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var footerBgVariant = props2.footerBgVariant, footerBorderVariant = props2.footerBorderVariant, footerTextVariant = props2.footerTextVariant;
      return h(props2.footerTag, a(data, {
        staticClass: "card-footer",
        class: [props2.footerClass, (_ref2 = {}, _defineProperty$1D(_ref2, "bg-".concat(footerBgVariant), footerBgVariant), _defineProperty$1D(_ref2, "border-".concat(footerBorderVariant), footerBorderVariant), _defineProperty$1D(_ref2, "text-".concat(footerTextVariant), footerTextVariant), _ref2)],
        domProps: children ? {} : htmlOrText(props2.footerHtml, props2.footer)
      }), children);
    }
  });
  function _defineProperty$1C(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BLANK_TEMPLATE = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>';
  var makeBlankImgSrc = function makeBlankImgSrc2(width, height, color) {
    var src = encodeURIComponent(BLANK_TEMPLATE.replace("%{w}", toString(width)).replace("%{h}", toString(height)).replace("%{f}", color));
    return "data:image/svg+xml;charset=UTF-8,".concat(src);
  };
  var props$1Z = makePropsConfigurable({
    alt: makeProp(PROP_TYPE_STRING),
    blank: makeProp(PROP_TYPE_BOOLEAN, false),
    blankColor: makeProp(PROP_TYPE_STRING, "transparent"),
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    center: makeProp(PROP_TYPE_BOOLEAN, false),
    fluid: makeProp(PROP_TYPE_BOOLEAN, false),
    // Gives fluid images class `w-100` to make them grow to fit container
    fluidGrow: makeProp(PROP_TYPE_BOOLEAN, false),
    height: makeProp(PROP_TYPE_NUMBER_STRING),
    left: makeProp(PROP_TYPE_BOOLEAN, false),
    right: makeProp(PROP_TYPE_BOOLEAN, false),
    // Possible values:
    //   `false`: no rounding of corners
    //   `true`: slightly rounded corners
    //   'top': top corners rounded
    //   'right': right corners rounded
    //   'bottom': bottom corners rounded
    //   'left': left corners rounded
    //   'circle': circle/oval
    //   '0': force rounding off
    rounded: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    sizes: makeProp(PROP_TYPE_ARRAY_STRING),
    src: makeProp(PROP_TYPE_STRING),
    srcset: makeProp(PROP_TYPE_ARRAY_STRING),
    thumbnail: makeProp(PROP_TYPE_BOOLEAN, false),
    width: makeProp(PROP_TYPE_NUMBER_STRING)
  }, NAME_IMG);
  var BImg = /* @__PURE__ */ extend({
    name: NAME_IMG,
    functional: true,
    props: props$1Z,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data;
      var alt = props2.alt, src = props2.src, block = props2.block, fluidGrow = props2.fluidGrow, rounded = props2.rounded;
      var width = toInteger(props2.width) || null;
      var height = toInteger(props2.height) || null;
      var align = null;
      var srcset = concat(props2.srcset).filter(identity).join(",");
      var sizes = concat(props2.sizes).filter(identity).join(",");
      if (props2.blank) {
        if (!height && width) {
          height = width;
        } else if (!width && height) {
          width = height;
        }
        if (!width && !height) {
          width = 1;
          height = 1;
        }
        src = makeBlankImgSrc(width, height, props2.blankColor || "transparent");
        srcset = null;
        sizes = null;
      }
      if (props2.left) {
        align = "float-left";
      } else if (props2.right) {
        align = "float-right";
      } else if (props2.center) {
        align = "mx-auto";
        block = true;
      }
      return h("img", a(data, {
        attrs: {
          src,
          alt,
          width: width ? toString(width) : null,
          height: height ? toString(height) : null,
          srcset: srcset || null,
          sizes: sizes || null
        },
        class: (_class = {
          "img-thumbnail": props2.thumbnail,
          "img-fluid": props2.fluid || fluidGrow,
          "w-100": fluidGrow,
          rounded: rounded === "" || rounded === true
        }, _defineProperty$1C(_class, "rounded-".concat(rounded), isString(rounded) && rounded !== ""), _defineProperty$1C(_class, align, align), _defineProperty$1C(_class, "d-block", block), _class)
      }));
    }
  });
  function ownKeys$1j(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1j(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1j(Object(source), true).forEach(function(key) {
        _defineProperty$1B(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1j(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1B(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1Y = makePropsConfigurable(sortKeys(_objectSpread$1j(_objectSpread$1j({}, pick$1(props$1Z, ["src", "alt", "width", "height", "left", "right"])), {}, {
    bottom: makeProp(PROP_TYPE_BOOLEAN, false),
    end: makeProp(PROP_TYPE_BOOLEAN, false),
    start: makeProp(PROP_TYPE_BOOLEAN, false),
    top: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_CARD_IMG);
  var BCardImg = /* @__PURE__ */ extend({
    name: NAME_CARD_IMG,
    functional: true,
    props: props$1Y,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data;
      var src = props2.src, alt = props2.alt, width = props2.width, height = props2.height;
      var baseClass = "card-img";
      if (props2.top) {
        baseClass += "-top";
      } else if (props2.right || props2.end) {
        baseClass += "-right";
      } else if (props2.bottom) {
        baseClass += "-bottom";
      } else if (props2.left || props2.start) {
        baseClass += "-left";
      }
      return h("img", a(data, {
        class: baseClass,
        attrs: {
          src,
          alt,
          width,
          height
        }
      }));
    }
  });
  function ownKeys$1i(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1i(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1i(Object(source), true).forEach(function(key) {
        _defineProperty$1A(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1i(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1A(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var cardImgProps = copyProps(props$1Y, prefixPropName.bind(null, "img"));
  cardImgProps.imgSrc.required = false;
  var props$1X = makePropsConfigurable(sortKeys(_objectSpread$1i(_objectSpread$1i(_objectSpread$1i(_objectSpread$1i(_objectSpread$1i(_objectSpread$1i({}, props$20), props$1$), props$1_), cardImgProps), props$23), {}, {
    align: makeProp(PROP_TYPE_STRING),
    noBody: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_CARD);
  var BCard = /* @__PURE__ */ extend({
    name: NAME_CARD,
    functional: true,
    props: props$1X,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var imgSrc = props2.imgSrc, imgLeft = props2.imgLeft, imgRight = props2.imgRight, imgStart = props2.imgStart, imgEnd = props2.imgEnd, imgBottom = props2.imgBottom, header = props2.header, headerHtml = props2.headerHtml, footer = props2.footer, footerHtml = props2.footerHtml, align = props2.align, textVariant = props2.textVariant, bgVariant = props2.bgVariant, borderVariant = props2.borderVariant;
      var $scopedSlots = scopedSlots || {};
      var $slots = slots();
      var slotScope = {};
      var $imgFirst = h();
      var $imgLast = h();
      if (imgSrc) {
        var $img = h(BCardImg, {
          props: pluckProps(cardImgProps, props2, unprefixPropName.bind(null, "img"))
        });
        if (imgBottom) {
          $imgLast = $img;
        } else {
          $imgFirst = $img;
        }
      }
      var $header = h();
      var hasHeaderSlot = hasNormalizedSlot(SLOT_NAME_HEADER, $scopedSlots, $slots);
      if (hasHeaderSlot || header || headerHtml) {
        $header = h(BCardHeader, {
          props: pluckProps(props$1$, props2),
          domProps: hasHeaderSlot ? {} : htmlOrText(headerHtml, header)
        }, normalizeSlot(SLOT_NAME_HEADER, slotScope, $scopedSlots, $slots));
      }
      var $content = normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots);
      if (!props2.noBody) {
        $content = h(BCardBody, {
          props: pluckProps(props$20, props2)
        }, $content);
        if (props2.overlay && imgSrc) {
          $content = h("div", {
            staticClass: "position-relative"
          }, [$imgFirst, $content, $imgLast]);
          $imgFirst = h();
          $imgLast = h();
        }
      }
      var $footer = h();
      var hasFooterSlot = hasNormalizedSlot(SLOT_NAME_FOOTER, $scopedSlots, $slots);
      if (hasFooterSlot || footer || footerHtml) {
        $footer = h(BCardFooter, {
          props: pluckProps(props$1_, props2),
          domProps: hasHeaderSlot ? {} : htmlOrText(footerHtml, footer)
        }, normalizeSlot(SLOT_NAME_FOOTER, slotScope, $scopedSlots, $slots));
      }
      return h(props2.tag, a(data, {
        staticClass: "card",
        class: (_class = {
          "flex-row": imgLeft || imgStart,
          "flex-row-reverse": (imgRight || imgEnd) && !(imgLeft || imgStart)
        }, _defineProperty$1A(_class, "text-".concat(align), align), _defineProperty$1A(_class, "bg-".concat(bgVariant), bgVariant), _defineProperty$1A(_class, "border-".concat(borderVariant), borderVariant), _defineProperty$1A(_class, "text-".concat(textVariant), textVariant), _class)
      }), [$imgFirst, $header, $content, $footer, $imgLast]);
    }
  });
  function _classCallCheck$5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$5(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$5(Constructor, protoProps, staticProps) {
    _defineProperties$5(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var OBSERVER_PROP_NAME = "__bv__visibility_observer";
  var VisibilityObserver = /* @__PURE__ */ function() {
    function VisibilityObserver2(el, options) {
      _classCallCheck$5(this, VisibilityObserver2);
      this.el = el;
      this.callback = options.callback;
      this.margin = options.margin || 0;
      this.once = options.once || false;
      this.observer = null;
      this.visible = void 0;
      this.doneOnce = false;
      this.createObserver();
    }
    _createClass$5(VisibilityObserver2, [{
      key: "createObserver",
      value: function createObserver() {
        var _this = this;
        if (this.observer) {
          this.stop();
        }
        if (this.doneOnce || !isFunction$1(this.callback)) {
          return;
        }
        try {
          this.observer = new IntersectionObserver(this.handler.bind(this), {
            // `null` = 'viewport'
            root: null,
            // Pixels away from view port to consider "visible"
            rootMargin: this.margin,
            // Intersection ratio of el and root (as a value from 0 to 1)
            threshold: 0
          });
        } catch (_unused) {
          this.doneOnce = true;
          this.observer = void 0;
          this.callback(null);
          return;
        }
        nextTick(function() {
          requestAF(function() {
            if (_this.observer) {
              _this.observer.observe(_this.el);
            }
          });
        });
      }
      /* istanbul ignore next */
    }, {
      key: "handler",
      value: function handler(entries) {
        var entry = entries ? entries[0] : {};
        var isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0);
        if (isIntersecting !== this.visible) {
          this.visible = isIntersecting;
          this.callback(isIntersecting);
          if (this.once && this.visible) {
            this.doneOnce = true;
            this.stop();
          }
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        this.observer && this.observer.disconnect();
        this.observer = null;
      }
    }]);
    return VisibilityObserver2;
  }();
  var destroy$1 = function destroy2(el) {
    var observer = el[OBSERVER_PROP_NAME];
    if (observer && observer.stop) {
      observer.stop();
    }
    delete el[OBSERVER_PROP_NAME];
  };
  var bind$1 = function bind2(el, _ref) {
    var value = _ref.value, modifiers2 = _ref.modifiers;
    var options = {
      margin: "0px",
      once: false,
      callback: value
    };
    keys(modifiers2).forEach(function(mod) {
      if (RX_DIGITS.test(mod)) {
        options.margin = "".concat(mod, "px");
      } else if (mod.toLowerCase() === "once") {
        options.once = true;
      }
    });
    destroy$1(el);
    el[OBSERVER_PROP_NAME] = new VisibilityObserver(el, options);
    el[OBSERVER_PROP_NAME]._prevModifiers = clone(modifiers2);
  };
  var componentUpdated$1 = function componentUpdated2(el, _ref2, vnode) {
    var value = _ref2.value, oldValue = _ref2.oldValue, modifiers2 = _ref2.modifiers;
    modifiers2 = clone(modifiers2);
    if (el && (value !== oldValue || !el[OBSERVER_PROP_NAME] || !looseEqual(modifiers2, el[OBSERVER_PROP_NAME]._prevModifiers))) {
      bind$1(el, {
        value,
        modifiers: modifiers2
      });
    }
  };
  var unbind$1 = function unbind2(el) {
    destroy$1(el);
  };
  var VBVisible = {
    bind: bind$1,
    componentUpdated: componentUpdated$1,
    unbind: unbind$1
  };
  var _watch$i;
  function ownKeys$1h(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1h(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1h(Object(source), true).forEach(function(key) {
        _defineProperty$1z(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1h(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1z(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_SHOW$1 = "show";
  var MODEL_EVENT_NAME_SHOW$1 = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_SHOW$1;
  var imgProps$1 = omit(props$1Z, ["blank"]);
  var props$1W = makePropsConfigurable(_objectSpread$1h(_objectSpread$1h({}, imgProps$1), {}, _defineProperty$1z({
    blankHeight: makeProp(PROP_TYPE_NUMBER_STRING),
    // If `null`, a blank image is generated
    blankSrc: makeProp(PROP_TYPE_STRING, null),
    blankWidth: makeProp(PROP_TYPE_NUMBER_STRING),
    // Distance away from viewport (in pixels)
    // before being considered "visible"
    offset: makeProp(PROP_TYPE_NUMBER_STRING, 360)
  }, MODEL_PROP_NAME_SHOW$1, makeProp(PROP_TYPE_BOOLEAN, false))), NAME_IMG_LAZY);
  var BImgLazy = /* @__PURE__ */ extend({
    name: NAME_IMG_LAZY,
    directives: {
      "b-visible": VBVisible
    },
    props: props$1W,
    data: function data() {
      return {
        isShown: this[MODEL_PROP_NAME_SHOW$1]
      };
    },
    computed: {
      computedSrc: function computedSrc() {
        var blankSrc = this.blankSrc;
        return !blankSrc || this.isShown ? this.src : blankSrc;
      },
      computedBlank: function computedBlank() {
        return !(this.isShown || this.blankSrc);
      },
      computedWidth: function computedWidth() {
        var width = this.width;
        return this.isShown ? width : this.blankWidth || width;
      },
      computedHeight: function computedHeight() {
        var height = this.height;
        return this.isShown ? height : this.blankHeight || height;
      },
      computedSrcset: function computedSrcset() {
        var srcset = concat(this.srcset).filter(identity).join(",");
        return srcset && (!this.blankSrc || this.isShown) ? srcset : null;
      },
      computedSizes: function computedSizes() {
        var sizes = concat(this.sizes).filter(identity).join(",");
        return sizes && (!this.blankSrc || this.isShown) ? sizes : null;
      }
    },
    watch: (_watch$i = {}, _defineProperty$1z(_watch$i, MODEL_PROP_NAME_SHOW$1, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        var visible = HAS_INTERACTION_OBSERVER_SUPPORT ? newValue : true;
        this.isShown = visible;
        if (newValue !== visible) {
          this.$nextTick(this.updateShowProp);
        }
      }
    }), _defineProperty$1z(_watch$i, "isShown", function isShown(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.updateShowProp();
      }
    }), _watch$i),
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function() {
        _this.isShown = HAS_INTERACTION_OBSERVER_SUPPORT ? _this[MODEL_PROP_NAME_SHOW$1] : true;
      });
    },
    methods: {
      updateShowProp: function updateShowProp() {
        this.$emit(MODEL_EVENT_NAME_SHOW$1, this.isShown);
      },
      doShow: function doShow(visible) {
        var _this2 = this;
        if ((visible || visible === null) && !this.isShown) {
          requestAF(function() {
            _this2.isShown = true;
          });
        }
      }
    },
    render: function render(h) {
      var directives = [];
      if (!this.isShown) {
        var _modifiers;
        directives.push({
          // Visible directive will silently do nothing if
          // `IntersectionObserver` is not supported
          name: "b-visible",
          // Value expects a callback (passed one arg of `visible` = `true` or `false`)
          value: this.doShow,
          modifiers: (_modifiers = {}, _defineProperty$1z(_modifiers, "".concat(toInteger(this.offset, 0)), true), _defineProperty$1z(_modifiers, "once", true), _modifiers)
        });
      }
      return h(BImg, {
        directives,
        props: _objectSpread$1h(_objectSpread$1h({}, pluckProps(imgProps$1, this.$props)), {}, {
          // Computed value props
          src: this.computedSrc,
          blank: this.computedBlank,
          width: this.computedWidth,
          height: this.computedHeight,
          srcset: this.computedSrcset,
          sizes: this.computedSizes
        })
      });
    }
  });
  function ownKeys$1g(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1g(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1g(Object(source), true).forEach(function(key) {
        _defineProperty$1y(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1g(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1y(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1V = makePropsConfigurable(sortKeys(_objectSpread$1g(_objectSpread$1g({}, omit(props$1W, keys(props$1Z))), omit(props$1Y, ["src", "alt", "width", "height"]))), NAME_CARD_IMG_LAZY);
  var BCardImgLazy = /* @__PURE__ */ extend({
    name: NAME_CARD_IMG_LAZY,
    functional: true,
    props: props$1V,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data;
      var baseClass = "card-img";
      if (props2.top) {
        baseClass += "-top";
      } else if (props2.right || props2.end) {
        baseClass += "-right";
      } else if (props2.bottom) {
        baseClass += "-bottom";
      } else if (props2.left || props2.start) {
        baseClass += "-left";
      }
      return h(BImgLazy, a(data, {
        class: [baseClass],
        // Exclude `left` and `right` props before passing to `<b-img-lazy>`
        props: omit(props2, ["left", "right"])
      }));
    }
  });
  var props$1U = makePropsConfigurable({
    textTag: makeProp(PROP_TYPE_STRING, "p")
  }, NAME_CARD_TEXT);
  var BCardText = /* @__PURE__ */ extend({
    name: NAME_CARD_TEXT,
    functional: true,
    props: props$1U,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.textTag, a(data, {
        staticClass: "card-text"
      }), children);
    }
  });
  var props$1T = makePropsConfigurable({
    columns: makeProp(PROP_TYPE_BOOLEAN, false),
    deck: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_CARD_GROUP);
  var BCardGroup = /* @__PURE__ */ extend({
    name: NAME_CARD_GROUP,
    functional: true,
    props: props$1T,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        class: props2.deck ? "card-deck" : props2.columns ? "card-columns" : "card-group"
      }), children);
    }
  });
  var CardPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BCard,
      BCardHeader,
      BCardBody,
      BCardTitle,
      BCardSubTitle,
      BCardFooter,
      BCardImg,
      BCardImgLazy,
      BCardText,
      BCardGroup
    }
  });
  var noop = function noop2() {
  };
  function ownKeys$1f(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1f(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1f(Object(source), true).forEach(function(key) {
        _defineProperty$1x(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1f(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1x(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var observeDom = function observeDom2(el, callback, options) {
    el = el ? el.$el || el : null;
    if (!isElement(el)) {
      return null;
    }
    if (warnNoMutationObserverSupport("observeDom")) {
      return null;
    }
    var obs = new MutationObs(function(mutations) {
      var changed = false;
      for (var i = 0; i < mutations.length && !changed; i++) {
        var mutation = mutations[i];
        var type = mutation.type;
        var target = mutation.target;
        if (type === "characterData" && target.nodeType === Node.TEXT_NODE) {
          changed = true;
        } else if (type === "attributes") {
          changed = true;
        } else if (type === "childList" && (mutation.addedNodes.length > 0 || mutation.removedNodes.length > 0)) {
          changed = true;
        }
      }
      if (changed) {
        callback();
      }
    });
    obs.observe(el, _objectSpread$1f({
      childList: true,
      subtree: true
    }, options));
    return obs;
  };
  var _watch$h;
  function ownKeys$1e(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1e(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1e(Object(source), true).forEach(function(key) {
        _defineProperty$1w(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1e(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1w(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$i = makeModelMixin("value", {
    type: PROP_TYPE_NUMBER,
    defaultValue: 0
  }), modelMixin$h = _makeModelMixin$i.mixin, modelProps$h = _makeModelMixin$i.props, MODEL_PROP_NAME$h = _makeModelMixin$i.prop, MODEL_EVENT_NAME$h = _makeModelMixin$i.event;
  var DIRECTION = {
    next: {
      dirClass: "carousel-item-left",
      overlayClass: "carousel-item-next"
    },
    prev: {
      dirClass: "carousel-item-right",
      overlayClass: "carousel-item-prev"
    }
  };
  var TRANS_DURATION = 600 + 50;
  var TOUCH_EVENT_COMPAT_WAIT = 500;
  var SWIPE_THRESHOLD = 40;
  var PointerType = {
    TOUCH: "touch",
    PEN: "pen"
  };
  var TransitionEndEvents$1 = {
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "transitionend",
    OTransition: "otransitionend oTransitionEnd",
    transition: "transitionend"
  };
  var getTransitionEndEvent = function getTransitionEndEvent2(el) {
    for (var name in TransitionEndEvents$1) {
      if (!isUndefined(el.style[name])) {
        return TransitionEndEvents$1[name];
      }
    }
    return null;
  };
  var props$1S = makePropsConfigurable(sortKeys(_objectSpread$1e(_objectSpread$1e(_objectSpread$1e({}, props$25), modelProps$h), {}, {
    background: makeProp(PROP_TYPE_STRING),
    controls: makeProp(PROP_TYPE_BOOLEAN, false),
    // Enable cross-fade animation instead of slide animation
    fade: makeProp(PROP_TYPE_BOOLEAN, false),
    // Sniffed by carousel-slide
    imgHeight: makeProp(PROP_TYPE_NUMBER_STRING),
    // Sniffed by carousel-slide
    imgWidth: makeProp(PROP_TYPE_NUMBER_STRING),
    indicators: makeProp(PROP_TYPE_BOOLEAN, false),
    interval: makeProp(PROP_TYPE_NUMBER, 5e3),
    labelGotoSlide: makeProp(PROP_TYPE_STRING, "Goto slide"),
    labelIndicators: makeProp(PROP_TYPE_STRING, "Select a slide to display"),
    labelNext: makeProp(PROP_TYPE_STRING, "Next slide"),
    labelPrev: makeProp(PROP_TYPE_STRING, "Previous slide"),
    // Disable slide/fade animation
    noAnimation: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable pause on hover
    noHoverPause: makeProp(PROP_TYPE_BOOLEAN, false),
    // Sniffed by carousel-slide
    noTouch: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable wrapping/looping when start/end is reached
    noWrap: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_CAROUSEL);
  var BCarousel = /* @__PURE__ */ extend({
    name: NAME_CAROUSEL,
    mixins: [idMixin, modelMixin$h, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvCarousel: function getBvCarousel() {
          return _this;
        }
      };
    },
    props: props$1S,
    data: function data() {
      return {
        index: this[MODEL_PROP_NAME$h] || 0,
        isSliding: false,
        transitionEndEvent: null,
        slides: [],
        direction: null,
        isPaused: !(toInteger(this.interval, 0) > 0),
        // Touch event handling values
        touchStartX: 0,
        touchDeltaX: 0
      };
    },
    computed: {
      numSlides: function numSlides() {
        return this.slides.length;
      }
    },
    watch: (_watch$h = {}, _defineProperty$1w(_watch$h, MODEL_PROP_NAME$h, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.setSlide(toInteger(newValue, 0));
      }
    }), _defineProperty$1w(_watch$h, "interval", function interval(newValue, oldValue) {
      if (newValue === oldValue) {
        return;
      }
      if (!newValue) {
        this.pause(false);
      } else {
        this.pause(true);
        this.start(false);
      }
    }), _defineProperty$1w(_watch$h, "isPaused", function isPaused(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit(newValue ? EVENT_NAME_PAUSED : EVENT_NAME_UNPAUSED);
      }
    }), _defineProperty$1w(_watch$h, "index", function index(to, from2) {
      if (to === from2 || this.isSliding) {
        return;
      }
      this.doSlide(to, from2);
    }), _watch$h),
    created: function created() {
      this.$_interval = null;
      this.$_animationTimeout = null;
      this.$_touchTimeout = null;
      this.$_observer = null;
      this.isPaused = !(toInteger(this.interval, 0) > 0);
    },
    mounted: function mounted() {
      this.transitionEndEvent = getTransitionEndEvent(this.$el) || null;
      this.updateSlides();
      this.setObserver(true);
    },
    beforeDestroy: function beforeDestroy() {
      this.clearInterval();
      this.clearAnimationTimeout();
      this.clearTouchTimeout();
      this.setObserver(false);
    },
    methods: {
      clearInterval: function(_clearInterval) {
        function clearInterval2() {
          return _clearInterval.apply(this, arguments);
        }
        clearInterval2.toString = function() {
          return _clearInterval.toString();
        };
        return clearInterval2;
      }(function() {
        clearInterval(this.$_interval);
        this.$_interval = null;
      }),
      clearAnimationTimeout: function clearAnimationTimeout() {
        clearTimeout(this.$_animationTimeout);
        this.$_animationTimeout = null;
      },
      clearTouchTimeout: function clearTouchTimeout() {
        clearTimeout(this.$_touchTimeout);
        this.$_touchTimeout = null;
      },
      setObserver: function setObserver() {
        var on = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        this.$_observer && this.$_observer.disconnect();
        this.$_observer = null;
        if (on) {
          this.$_observer = observeDom(this.$refs.inner, this.updateSlides.bind(this), {
            subtree: false,
            childList: true,
            attributes: true,
            attributeFilter: ["id"]
          });
        }
      },
      // Set slide
      setSlide: function setSlide(slide) {
        var _this2 = this;
        var direction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        if (IS_BROWSER && document.visibilityState && document.hidden) {
          return;
        }
        var noWrap = this.noWrap;
        var numSlides = this.numSlides;
        slide = mathFloor(slide);
        if (numSlides === 0) {
          return;
        }
        if (this.isSliding) {
          this.$once(EVENT_NAME_SLIDING_END, function() {
            requestAF(function() {
              return _this2.setSlide(slide, direction);
            });
          });
          return;
        }
        this.direction = direction;
        this.index = slide >= numSlides ? noWrap ? numSlides - 1 : 0 : slide < 0 ? noWrap ? 0 : numSlides - 1 : slide;
        if (noWrap && this.index !== slide && this.index !== this[MODEL_PROP_NAME$h]) {
          this.$emit(MODEL_EVENT_NAME$h, this.index);
        }
      },
      // Previous slide
      prev: function prev() {
        this.setSlide(this.index - 1, "prev");
      },
      // Next slide
      next: function next() {
        this.setSlide(this.index + 1, "next");
      },
      // Pause auto rotation
      pause: function pause(event2) {
        if (!event2) {
          this.isPaused = true;
        }
        this.clearInterval();
      },
      // Start auto rotate slides
      start: function start(event2) {
        if (!event2) {
          this.isPaused = false;
        }
        this.clearInterval();
        if (this.interval && this.numSlides > 1) {
          this.$_interval = setInterval(this.next, mathMax(1e3, this.interval));
        }
      },
      // Restart auto rotate slides when focus/hover leaves the carousel
      /* istanbul ignore next */
      restart: function restart() {
        if (!this.$el.contains(getActiveElement())) {
          this.start();
        }
      },
      doSlide: function doSlide(to, from2) {
        var _this3 = this;
        var isCycling = Boolean(this.interval);
        var direction = this.calcDirection(this.direction, from2, to);
        var overlayClass = direction.overlayClass;
        var dirClass = direction.dirClass;
        var currentSlide = this.slides[from2];
        var nextSlide = this.slides[to];
        if (!currentSlide || !nextSlide) {
          return;
        }
        this.isSliding = true;
        if (isCycling) {
          this.pause(false);
        }
        this.$emit(EVENT_NAME_SLIDING_START, to);
        this.$emit(MODEL_EVENT_NAME$h, this.index);
        if (this.noAnimation) {
          addClass(nextSlide, "active");
          removeClass(currentSlide, "active");
          this.isSliding = false;
          this.$nextTick(function() {
            return _this3.$emit(EVENT_NAME_SLIDING_END, to);
          });
        } else {
          addClass(nextSlide, overlayClass);
          reflow(nextSlide);
          addClass(currentSlide, dirClass);
          addClass(nextSlide, dirClass);
          var called = false;
          var onceTransEnd = function onceTransEnd2() {
            if (called) {
              return;
            }
            called = true;
            if (_this3.transitionEndEvent) {
              var events2 = _this3.transitionEndEvent.split(/\s+/);
              events2.forEach(function(event2) {
                return eventOff(nextSlide, event2, onceTransEnd2, EVENT_OPTIONS_NO_CAPTURE);
              });
            }
            _this3.clearAnimationTimeout();
            removeClass(nextSlide, dirClass);
            removeClass(nextSlide, overlayClass);
            addClass(nextSlide, "active");
            removeClass(currentSlide, "active");
            removeClass(currentSlide, dirClass);
            removeClass(currentSlide, overlayClass);
            setAttr(currentSlide, "aria-current", "false");
            setAttr(nextSlide, "aria-current", "true");
            setAttr(currentSlide, "aria-hidden", "true");
            setAttr(nextSlide, "aria-hidden", "false");
            _this3.isSliding = false;
            _this3.direction = null;
            _this3.$nextTick(function() {
              return _this3.$emit(EVENT_NAME_SLIDING_END, to);
            });
          };
          if (this.transitionEndEvent) {
            var events = this.transitionEndEvent.split(/\s+/);
            events.forEach(function(event2) {
              return eventOn(nextSlide, event2, onceTransEnd, EVENT_OPTIONS_NO_CAPTURE);
            });
          }
          this.$_animationTimeout = setTimeout(onceTransEnd, TRANS_DURATION);
        }
        if (isCycling) {
          this.start(false);
        }
      },
      // Update slide list
      updateSlides: function updateSlides() {
        this.pause(true);
        this.slides = selectAll(".carousel-item", this.$refs.inner);
        var numSlides = this.slides.length;
        var index = mathMax(0, mathMin(mathFloor(this.index), numSlides - 1));
        this.slides.forEach(function(slide, idx) {
          var n = idx + 1;
          if (idx === index) {
            addClass(slide, "active");
            setAttr(slide, "aria-current", "true");
          } else {
            removeClass(slide, "active");
            setAttr(slide, "aria-current", "false");
          }
          setAttr(slide, "aria-posinset", String(n));
          setAttr(slide, "aria-setsize", String(numSlides));
        });
        this.setSlide(index);
        this.start(this.isPaused);
      },
      calcDirection: function calcDirection() {
        var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        var curIndex = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var nextIndex = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        if (!direction) {
          return nextIndex > curIndex ? DIRECTION.next : DIRECTION.prev;
        }
        return DIRECTION[direction];
      },
      handleClick: function handleClick(event2, fn) {
        var keyCode = event2.keyCode;
        if (event2.type === "click" || keyCode === CODE_SPACE || keyCode === CODE_ENTER) {
          stopEvent(event2);
          fn();
        }
      },
      /* istanbul ignore next: JSDOM doesn't support touch events */
      handleSwipe: function handleSwipe() {
        var absDeltaX = mathAbs(this.touchDeltaX);
        if (absDeltaX <= SWIPE_THRESHOLD) {
          return;
        }
        var direction = absDeltaX / this.touchDeltaX;
        this.touchDeltaX = 0;
        if (direction > 0) {
          this.prev();
        } else if (direction < 0) {
          this.next();
        }
      },
      /* istanbul ignore next: JSDOM doesn't support touch events */
      touchStart: function touchStart(event2) {
        if (HAS_POINTER_EVENT_SUPPORT && PointerType[event2.pointerType.toUpperCase()]) {
          this.touchStartX = event2.clientX;
        } else if (!HAS_POINTER_EVENT_SUPPORT) {
          this.touchStartX = event2.touches[0].clientX;
        }
      },
      /* istanbul ignore next: JSDOM doesn't support touch events */
      touchMove: function touchMove(event2) {
        if (event2.touches && event2.touches.length > 1) {
          this.touchDeltaX = 0;
        } else {
          this.touchDeltaX = event2.touches[0].clientX - this.touchStartX;
        }
      },
      /* istanbul ignore next: JSDOM doesn't support touch events */
      touchEnd: function touchEnd(event2) {
        if (HAS_POINTER_EVENT_SUPPORT && PointerType[event2.pointerType.toUpperCase()]) {
          this.touchDeltaX = event2.clientX - this.touchStartX;
        }
        this.handleSwipe();
        this.pause(false);
        this.clearTouchTimeout();
        this.$_touchTimeout = setTimeout(this.start, TOUCH_EVENT_COMPAT_WAIT + mathMax(1e3, this.interval));
      }
    },
    render: function render(h) {
      var _this4 = this;
      var indicators = this.indicators, background = this.background, noAnimation = this.noAnimation, noHoverPause = this.noHoverPause, noTouch = this.noTouch, index = this.index, isSliding = this.isSliding, pause = this.pause, restart = this.restart, touchStart = this.touchStart, touchEnd = this.touchEnd;
      var idInner = this.safeId("__BV_inner_");
      var $inner = h("div", {
        staticClass: "carousel-inner",
        attrs: {
          id: idInner,
          role: "list"
        },
        ref: "inner"
      }, [this.normalizeSlot()]);
      var $controls = h();
      if (this.controls) {
        var makeControl = function makeControl2(direction, label, handler) {
          var handlerWrapper = function handlerWrapper2(event2) {
            if (!isSliding) {
              _this4.handleClick(event2, handler);
            } else {
              stopEvent(event2, {
                propagation: false
              });
            }
          };
          return h("a", {
            staticClass: "carousel-control-".concat(direction),
            attrs: {
              href: "#",
              role: "button",
              "aria-controls": idInner,
              "aria-disabled": isSliding ? "true" : null
            },
            on: {
              click: handlerWrapper,
              keydown: handlerWrapper
            }
          }, [h("span", {
            staticClass: "carousel-control-".concat(direction, "-icon"),
            attrs: {
              "aria-hidden": "true"
            }
          }), h("span", {
            class: "sr-only"
          }, [label])]);
        };
        $controls = [makeControl("prev", this.labelPrev, this.prev), makeControl("next", this.labelNext, this.next)];
      }
      var $indicators = h("ol", {
        staticClass: "carousel-indicators",
        directives: [{
          name: "show",
          value: indicators
        }],
        attrs: {
          id: this.safeId("__BV_indicators_"),
          "aria-hidden": indicators ? "false" : "true",
          "aria-label": this.labelIndicators,
          "aria-owns": idInner
        }
      }, this.slides.map(function(slide, i) {
        var handler = function handler2(event2) {
          _this4.handleClick(event2, function() {
            _this4.setSlide(i);
          });
        };
        return h("li", {
          class: {
            active: i === index
          },
          attrs: {
            role: "button",
            id: _this4.safeId("__BV_indicator_".concat(i + 1, "_")),
            tabindex: indicators ? "0" : "-1",
            "aria-current": i === index ? "true" : "false",
            "aria-label": "".concat(_this4.labelGotoSlide, " ").concat(i + 1),
            "aria-describedby": slide.id || null,
            "aria-controls": idInner
          },
          on: {
            click: handler,
            keydown: handler
          },
          key: "slide_".concat(i)
        });
      }));
      var on = {
        mouseenter: noHoverPause ? noop : pause,
        mouseleave: noHoverPause ? noop : restart,
        focusin: pause,
        focusout: restart,
        keydown: function keydown(event2) {
          if (/input|textarea/i.test(event2.target.tagName)) {
            return;
          }
          var keyCode = event2.keyCode;
          if (keyCode === CODE_LEFT || keyCode === CODE_RIGHT) {
            stopEvent(event2);
            _this4[keyCode === CODE_LEFT ? "prev" : "next"]();
          }
        }
      };
      if (HAS_TOUCH_SUPPORT && !noTouch) {
        if (HAS_POINTER_EVENT_SUPPORT) {
          on["&pointerdown"] = touchStart;
          on["&pointerup"] = touchEnd;
        } else {
          on["&touchstart"] = touchStart;
          on["&touchmove"] = this.touchMove;
          on["&touchend"] = touchEnd;
        }
      }
      return h("div", {
        staticClass: "carousel",
        class: {
          slide: !noAnimation,
          "carousel-fade": !noAnimation && this.fade,
          "pointer-event": HAS_TOUCH_SUPPORT && HAS_POINTER_EVENT_SUPPORT && !noTouch
        },
        style: {
          background
        },
        attrs: {
          role: "region",
          id: this.safeId(),
          "aria-busy": isSliding ? "true" : "false"
        },
        on
      }, [$inner, $controls, $indicators]);
    }
  });
  function ownKeys$1d(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1d(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1d(Object(source), true).forEach(function(key) {
        _defineProperty$1v(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1d(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1v(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var imgProps = {
    imgAlt: makeProp(PROP_TYPE_STRING),
    imgBlank: makeProp(PROP_TYPE_BOOLEAN, false),
    imgBlankColor: makeProp(PROP_TYPE_STRING, "transparent"),
    imgHeight: makeProp(PROP_TYPE_NUMBER_STRING),
    imgSrc: makeProp(PROP_TYPE_STRING),
    imgWidth: makeProp(PROP_TYPE_NUMBER_STRING)
  };
  var props$1R = makePropsConfigurable(sortKeys(_objectSpread$1d(_objectSpread$1d(_objectSpread$1d({}, props$25), imgProps), {}, {
    background: makeProp(PROP_TYPE_STRING),
    caption: makeProp(PROP_TYPE_STRING),
    captionHtml: makeProp(PROP_TYPE_STRING),
    captionTag: makeProp(PROP_TYPE_STRING, "h3"),
    contentTag: makeProp(PROP_TYPE_STRING, "div"),
    contentVisibleUp: makeProp(PROP_TYPE_STRING),
    text: makeProp(PROP_TYPE_STRING),
    textHtml: makeProp(PROP_TYPE_STRING),
    textTag: makeProp(PROP_TYPE_STRING, "p")
  })), NAME_CAROUSEL_SLIDE);
  var BCarouselSlide = /* @__PURE__ */ extend({
    name: NAME_CAROUSEL_SLIDE,
    mixins: [idMixin, normalizeSlotMixin],
    inject: {
      getBvCarousel: {
        // Explicitly disable touch if not a child of carousel
        default: function _default() {
          return function() {
            return {
              noTouch: true
            };
          };
        }
      }
    },
    props: props$1R,
    computed: {
      bvCarousel: function bvCarousel() {
        return this.getBvCarousel();
      },
      contentClasses: function contentClasses() {
        return [this.contentVisibleUp ? "d-none" : "", this.contentVisibleUp ? "d-".concat(this.contentVisibleUp, "-block") : ""];
      },
      computedWidth: function computedWidth() {
        return this.imgWidth || this.bvCarousel.imgWidth || null;
      },
      computedHeight: function computedHeight() {
        return this.imgHeight || this.bvCarousel.imgHeight || null;
      }
    },
    render: function render(h) {
      var $img = this.normalizeSlot(SLOT_NAME_IMG);
      if (!$img && (this.imgSrc || this.imgBlank)) {
        var on = {};
        if (!this.bvCarousel.noTouch && HAS_TOUCH_SUPPORT) {
          on.dragstart = function(event2) {
            return stopEvent(event2, {
              propagation: false
            });
          };
        }
        $img = h(BImg, {
          props: _objectSpread$1d(_objectSpread$1d({}, pluckProps(imgProps, this.$props, unprefixPropName.bind(null, "img"))), {}, {
            width: this.computedWidth,
            height: this.computedHeight,
            fluidGrow: true,
            block: true
          }),
          on
        });
      }
      var $contentChildren = [
        // Caption
        this.caption || this.captionHtml ? h(this.captionTag, {
          domProps: htmlOrText(this.captionHtml, this.caption)
        }) : false,
        // Text
        this.text || this.textHtml ? h(this.textTag, {
          domProps: htmlOrText(this.textHtml, this.text)
        }) : false,
        // Children
        this.normalizeSlot() || false
      ];
      var $content = h();
      if ($contentChildren.some(identity)) {
        $content = h(this.contentTag, {
          staticClass: "carousel-caption",
          class: this.contentClasses
        }, $contentChildren.map(function($child) {
          return $child || h();
        }));
      }
      return h("div", {
        staticClass: "carousel-item",
        style: {
          background: this.background || this.bvCarousel.background || null
        },
        attrs: {
          id: this.safeId(),
          role: "listitem"
        }
      }, [$img, $content]);
    }
  });
  var CarouselPlugin = (
    /*#__PURE*/
    pluginFactory({
      components: {
        BCarousel,
        BCarouselSlide
      }
    })
  );
  var CLASS_NAME_SHOW = "show";
  var onEnter = function onEnter2(el) {
    setStyle(el, "height", 0);
    requestAF(function() {
      reflow(el);
      setStyle(el, "height", "".concat(el.scrollHeight, "px"));
    });
  };
  var onAfterEnter = function onAfterEnter2(el) {
    removeStyle(el, "height");
  };
  var onLeave = function onLeave2(el) {
    setStyle(el, "height", "auto");
    setStyle(el, "display", "block");
    setStyle(el, "height", "".concat(getBCR(el).height, "px"));
    reflow(el);
    setStyle(el, "height", 0);
  };
  var onAfterLeave = function onAfterLeave2(el) {
    removeStyle(el, "height");
  };
  var TRANSITION_PROPS = {
    css: true,
    enterClass: "",
    enterActiveClass: "collapsing",
    enterToClass: "collapse show",
    leaveClass: "collapse show",
    leaveActiveClass: "collapsing",
    leaveToClass: "collapse"
  };
  var TRANSITION_HANDLERS = {
    enter: onEnter,
    afterEnter: onAfterEnter,
    leave: onLeave,
    afterLeave: onAfterLeave
  };
  var props$1Q = {
    // // If `true` (and `visible` is `true` on mount), animate initially visible
    appear: makeProp(PROP_TYPE_BOOLEAN, false)
  };
  var BVCollapse = /* @__PURE__ */ extend({
    name: NAME_COLLAPSE_HELPER,
    functional: true,
    props: props$1Q,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(
        "transition",
        // We merge in the `appear` prop last
        a(data, {
          props: TRANSITION_PROPS,
          on: TRANSITION_HANDLERS
        }, {
          props: props2
        }),
        // Note: `<transition>` supports a single root element only
        children
      );
    }
  });
  var _watch$g;
  function ownKeys$1c(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1c(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1c(Object(source), true).forEach(function(key) {
        _defineProperty$1u(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1c(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1u(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ROOT_ACTION_EVENT_NAME_TOGGLE$2 = getRootActionEventName(NAME_COLLAPSE, "toggle");
  var ROOT_ACTION_EVENT_NAME_REQUEST_STATE$2 = getRootActionEventName(NAME_COLLAPSE, "request-state");
  var ROOT_EVENT_NAME_ACCORDION = getRootEventName(NAME_COLLAPSE, "accordion");
  var ROOT_EVENT_NAME_STATE$3 = getRootEventName(NAME_COLLAPSE, "state");
  var ROOT_EVENT_NAME_SYNC_STATE$3 = getRootEventName(NAME_COLLAPSE, "sync-state");
  var _makeModelMixin$h = makeModelMixin("visible", {
    type: PROP_TYPE_BOOLEAN,
    defaultValue: false
  }), modelMixin$g = _makeModelMixin$h.mixin, modelProps$g = _makeModelMixin$h.props, MODEL_PROP_NAME$g = _makeModelMixin$h.prop, MODEL_EVENT_NAME$g = _makeModelMixin$h.event;
  var props$1P = makePropsConfigurable(sortKeys(_objectSpread$1c(_objectSpread$1c(_objectSpread$1c({}, props$25), modelProps$g), {}, {
    // If `true` (and `visible` is `true` on mount), animate initially visible
    accordion: makeProp(PROP_TYPE_STRING),
    appear: makeProp(PROP_TYPE_BOOLEAN, false),
    isNav: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  })), NAME_COLLAPSE);
  var BCollapse = /* @__PURE__ */ extend({
    name: NAME_COLLAPSE,
    mixins: [idMixin, modelMixin$g, normalizeSlotMixin, listenOnRootMixin],
    props: props$1P,
    data: function data() {
      return {
        show: this[MODEL_PROP_NAME$g],
        transitioning: false
      };
    },
    computed: {
      classObject: function classObject() {
        var transitioning = this.transitioning;
        return {
          "navbar-collapse": this.isNav,
          collapse: !transitioning,
          show: this.show && !transitioning
        };
      },
      slotScope: function slotScope() {
        var _this = this;
        return {
          visible: this.show,
          close: function close() {
            _this.show = false;
          }
        };
      }
    },
    watch: (_watch$g = {}, _defineProperty$1u(_watch$g, MODEL_PROP_NAME$g, function(newValue) {
      if (newValue !== this.show) {
        this.show = newValue;
      }
    }), _defineProperty$1u(_watch$g, "show", function show(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.emitState();
      }
    }), _watch$g),
    created: function created() {
      this.show = this[MODEL_PROP_NAME$g];
    },
    mounted: function mounted() {
      var _this2 = this;
      this.show = this[MODEL_PROP_NAME$g];
      this.listenOnRoot(ROOT_ACTION_EVENT_NAME_TOGGLE$2, this.handleToggleEvent);
      this.listenOnRoot(ROOT_EVENT_NAME_ACCORDION, this.handleAccordionEvent);
      if (this.isNav) {
        this.setWindowEvents(true);
        this.handleResize();
      }
      this.$nextTick(function() {
        _this2.emitState();
      });
      this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REQUEST_STATE$2, function(id) {
        if (id === _this2.safeId()) {
          _this2.$nextTick(_this2.emitSync);
        }
      });
    },
    updated: function updated2() {
      this.emitSync();
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      if (this.isNav) {
        this.setWindowEvents(false);
      }
    },
    /* istanbul ignore next */
    activated: function activated() {
      if (this.isNav) {
        this.setWindowEvents(true);
      }
      this.emitSync();
    },
    beforeDestroy: function beforeDestroy() {
      this.show = false;
      if (this.isNav && IS_BROWSER) {
        this.setWindowEvents(false);
      }
    },
    methods: {
      setWindowEvents: function setWindowEvents(on) {
        eventOnOff(on, window, "resize", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
        eventOnOff(on, window, "orientationchange", this.handleResize, EVENT_OPTIONS_NO_CAPTURE);
      },
      toggle: function toggle() {
        this.show = !this.show;
      },
      onEnter: function onEnter2() {
        this.transitioning = true;
        this.$emit(EVENT_NAME_SHOW);
      },
      onAfterEnter: function onAfterEnter2() {
        this.transitioning = false;
        this.$emit(EVENT_NAME_SHOWN);
      },
      onLeave: function onLeave2() {
        this.transitioning = true;
        this.$emit(EVENT_NAME_HIDE);
      },
      onAfterLeave: function onAfterLeave2() {
        this.transitioning = false;
        this.$emit(EVENT_NAME_HIDDEN);
      },
      emitState: function emitState() {
        var show = this.show, accordion = this.accordion;
        var id = this.safeId();
        this.$emit(MODEL_EVENT_NAME$g, show);
        this.emitOnRoot(ROOT_EVENT_NAME_STATE$3, id, show);
        if (accordion && show) {
          this.emitOnRoot(ROOT_EVENT_NAME_ACCORDION, id, accordion);
        }
      },
      emitSync: function emitSync() {
        this.emitOnRoot(ROOT_EVENT_NAME_SYNC_STATE$3, this.safeId(), this.show);
      },
      checkDisplayBlock: function checkDisplayBlock() {
        var $el = this.$el;
        var restore = hasClass($el, CLASS_NAME_SHOW);
        removeClass($el, CLASS_NAME_SHOW);
        var isBlock = getCS($el).display === "block";
        if (restore) {
          addClass($el, CLASS_NAME_SHOW);
        }
        return isBlock;
      },
      clickHandler: function clickHandler(event2) {
        var el = event2.target;
        if (!this.isNav || !el || getCS(this.$el).display !== "block") {
          return;
        }
        if ((matches(el, ".nav-link,.dropdown-item") || closest(".nav-link,.dropdown-item", el)) && !this.checkDisplayBlock()) {
          this.show = false;
        }
      },
      handleToggleEvent: function handleToggleEvent(id) {
        if (id === this.safeId()) {
          this.toggle();
        }
      },
      handleAccordionEvent: function handleAccordionEvent(openedId, openAccordion) {
        var accordion = this.accordion, show = this.show;
        if (!accordion || accordion !== openAccordion) {
          return;
        }
        var isThis = openedId === this.safeId();
        if (isThis && !show || !isThis && show) {
          this.toggle();
        }
      },
      handleResize: function handleResize() {
        this.show = getCS(this.$el).display === "block";
      }
    },
    render: function render(h) {
      var appear = this.appear;
      var $content = h(this.tag, {
        class: this.classObject,
        directives: [{
          name: "show",
          value: this.show
        }],
        attrs: {
          id: this.safeId()
        },
        on: {
          click: this.clickHandler
        }
      }, this.normalizeSlot(SLOT_NAME_DEFAULT, this.slotScope));
      return h(BVCollapse, {
        props: {
          appear
        },
        on: {
          enter: this.onEnter,
          afterEnter: this.onAfterEnter,
          leave: this.onLeave,
          afterLeave: this.onAfterLeave
        }
      }, [$content]);
    }
  });
  var getInstanceFromDirective = function getInstanceFromDirective2(vnode, bindings) {
    return isVue3 ? bindings.instance : vnode.context;
  };
  var CLASS_BV_TOGGLE_COLLAPSED = "collapsed";
  var CLASS_BV_TOGGLE_NOT_COLLAPSED = "not-collapsed";
  var BV_BASE = "__BV_toggle";
  var BV_TOGGLE_ROOT_HANDLER = "".concat(BV_BASE, "_HANDLER__");
  var BV_TOGGLE_CLICK_HANDLER = "".concat(BV_BASE, "_CLICK__");
  var BV_TOGGLE_STATE = "".concat(BV_BASE, "_STATE__");
  var BV_TOGGLE_TARGETS = "".concat(BV_BASE, "_TARGETS__");
  var STRING_FALSE = "false";
  var STRING_TRUE = "true";
  var ATTR_ARIA_CONTROLS = "aria-controls";
  var ATTR_ARIA_EXPANDED = "aria-expanded";
  var ATTR_ROLE = "role";
  var ATTR_TABINDEX = "tabindex";
  var STYLE_OVERFLOW_ANCHOR = "overflow-anchor";
  var ROOT_ACTION_EVENT_NAME_TOGGLE$1 = getRootActionEventName(NAME_COLLAPSE, "toggle");
  var ROOT_EVENT_NAME_STATE$2 = getRootEventName(NAME_COLLAPSE, "state");
  var ROOT_EVENT_NAME_SYNC_STATE$2 = getRootEventName(NAME_COLLAPSE, "sync-state");
  var ROOT_ACTION_EVENT_NAME_REQUEST_STATE$1 = getRootActionEventName(NAME_COLLAPSE, "request-state");
  var KEYDOWN_KEY_CODES = [CODE_ENTER, CODE_SPACE];
  var isNonStandardTag = function isNonStandardTag2(el) {
    return !arrayIncludes(["button", "a"], el.tagName.toLowerCase());
  };
  var getTargets = function getTargets2(_ref, el) {
    var modifiers2 = _ref.modifiers, arg = _ref.arg, value = _ref.value;
    var targets2 = keys(modifiers2 || {});
    value = isString(value) ? value.split(RX_SPACE_SPLIT) : value;
    if (isTag(el.tagName, "a")) {
      var href = getAttr(el, "href") || "";
      if (RX_HASH_ID.test(href)) {
        targets2.push(href.replace(RX_HASH, ""));
      }
    }
    concat(arg, value).forEach(function(t2) {
      return isString(t2) && targets2.push(t2);
    });
    return targets2.filter(function(t2, index, arr) {
      return t2 && arr.indexOf(t2) === index;
    });
  };
  var removeClickListener = function removeClickListener2(el) {
    var handler = el[BV_TOGGLE_CLICK_HANDLER];
    if (handler) {
      eventOff(el, "click", handler, EVENT_OPTIONS_PASSIVE);
      eventOff(el, "keydown", handler, EVENT_OPTIONS_PASSIVE);
    }
    el[BV_TOGGLE_CLICK_HANDLER] = null;
  };
  var addClickListener = function addClickListener2(el, instance) {
    removeClickListener(el);
    if (instance) {
      var handler = function handler2(event2) {
        if (!(event2.type === "keydown" && !arrayIncludes(KEYDOWN_KEY_CODES, event2.keyCode)) && !isDisabled(el)) {
          var targets2 = el[BV_TOGGLE_TARGETS] || [];
          targets2.forEach(function(target) {
            getEventRoot(instance).$emit(ROOT_ACTION_EVENT_NAME_TOGGLE$1, target);
          });
        }
      };
      el[BV_TOGGLE_CLICK_HANDLER] = handler;
      eventOn(el, "click", handler, EVENT_OPTIONS_PASSIVE);
      if (isNonStandardTag(el)) {
        eventOn(el, "keydown", handler, EVENT_OPTIONS_PASSIVE);
      }
    }
  };
  var removeRootListeners = function removeRootListeners2(el, instance) {
    if (el[BV_TOGGLE_ROOT_HANDLER] && instance) {
      getEventRoot(instance).$off([ROOT_EVENT_NAME_STATE$2, ROOT_EVENT_NAME_SYNC_STATE$2], el[BV_TOGGLE_ROOT_HANDLER]);
    }
    el[BV_TOGGLE_ROOT_HANDLER] = null;
  };
  var addRootListeners = function addRootListeners2(el, instance) {
    removeRootListeners(el, instance);
    if (instance) {
      var handler = function handler2(id, state) {
        if (arrayIncludes(el[BV_TOGGLE_TARGETS] || [], id)) {
          el[BV_TOGGLE_STATE] = state;
          setToggleState(el, state);
        }
      };
      el[BV_TOGGLE_ROOT_HANDLER] = handler;
      getEventRoot(instance).$on([ROOT_EVENT_NAME_STATE$2, ROOT_EVENT_NAME_SYNC_STATE$2], handler);
    }
  };
  var setToggleState = function setToggleState2(el, state) {
    if (state) {
      removeClass(el, CLASS_BV_TOGGLE_COLLAPSED);
      addClass(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);
      setAttr(el, ATTR_ARIA_EXPANDED, STRING_TRUE);
    } else {
      removeClass(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);
      addClass(el, CLASS_BV_TOGGLE_COLLAPSED);
      setAttr(el, ATTR_ARIA_EXPANDED, STRING_FALSE);
    }
  };
  var resetProp = function resetProp2(el, prop2) {
    el[prop2] = null;
    delete el[prop2];
  };
  var handleUpdate = function handleUpdate2(el, binding, vnode) {
    if (!IS_BROWSER || !getInstanceFromDirective(vnode, binding)) {
      return;
    }
    if (isNonStandardTag(el)) {
      if (!hasAttr(el, ATTR_ROLE)) {
        setAttr(el, ATTR_ROLE, "button");
      }
      if (!hasAttr(el, ATTR_TABINDEX)) {
        setAttr(el, ATTR_TABINDEX, "0");
      }
    }
    setToggleState(el, el[BV_TOGGLE_STATE]);
    var targets2 = getTargets(binding, el);
    if (targets2.length > 0) {
      setAttr(el, ATTR_ARIA_CONTROLS, targets2.join(" "));
      setStyle(el, STYLE_OVERFLOW_ANCHOR, "none");
    } else {
      removeAttr(el, ATTR_ARIA_CONTROLS);
      removeStyle(el, STYLE_OVERFLOW_ANCHOR);
    }
    requestAF(function() {
      addClickListener(el, getInstanceFromDirective(vnode, binding));
    });
    if (!looseEqual(targets2, el[BV_TOGGLE_TARGETS])) {
      el[BV_TOGGLE_TARGETS] = targets2;
      targets2.forEach(function(target) {
        getEventRoot(getInstanceFromDirective(vnode, binding)).$emit(ROOT_ACTION_EVENT_NAME_REQUEST_STATE$1, target);
      });
    }
  };
  var VBToggle = {
    bind: function bind2(el, binding, vnode) {
      el[BV_TOGGLE_STATE] = false;
      el[BV_TOGGLE_TARGETS] = [];
      addRootListeners(el, getInstanceFromDirective(vnode, binding));
      handleUpdate(el, binding, vnode);
    },
    componentUpdated: handleUpdate,
    updated: handleUpdate,
    unbind: function unbind2(el, binding, vnode) {
      removeClickListener(el);
      removeRootListeners(el, getInstanceFromDirective(vnode, binding));
      resetProp(el, BV_TOGGLE_ROOT_HANDLER);
      resetProp(el, BV_TOGGLE_CLICK_HANDLER);
      resetProp(el, BV_TOGGLE_STATE);
      resetProp(el, BV_TOGGLE_TARGETS);
      removeClass(el, CLASS_BV_TOGGLE_COLLAPSED);
      removeClass(el, CLASS_BV_TOGGLE_NOT_COLLAPSED);
      removeAttr(el, ATTR_ARIA_EXPANDED);
      removeAttr(el, ATTR_ARIA_CONTROLS);
      removeAttr(el, ATTR_ROLE);
      removeStyle(el, STYLE_OVERFLOW_ANCHOR);
    }
  };
  var VBTogglePlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBToggle
    }
  });
  var CollapsePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BCollapse
    },
    plugins: {
      VBTogglePlugin
    }
  });
  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.16.1
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && typeof navigator !== "undefined";
  var timeoutDuration = function() {
    var longerTimeoutBrowsers = ["Edge", "Trident", "Firefox"];
    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
        return 1;
      }
    }
    return 0;
  }();
  function microtaskDebounce(fn) {
    var called = false;
    return function() {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function() {
        called = false;
        fn();
      });
    };
  }
  function taskDebounce(fn) {
    var scheduled = false;
    return function() {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function() {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }
  var supportsMicroTasks = isBrowser && window.Promise;
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
  }
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    var window2 = element.ownerDocument.defaultView;
    var css = window2.getComputedStyle(element, null);
    return property ? css[property] : css;
  }
  function getParentNode(element) {
    if (element.nodeName === "HTML") {
      return element;
    }
    return element.parentNode || element.host;
  }
  function getScrollParent(element) {
    if (!element) {
      return document.body;
    }
    switch (element.nodeName) {
      case "HTML":
      case "BODY":
        return element.ownerDocument.body;
      case "#document":
        return element.body;
    }
    var _getStyleComputedProp = getStyleComputedProperty(element), overflow = _getStyleComputedProp.overflow, overflowX = _getStyleComputedProp.overflowX, overflowY = _getStyleComputedProp.overflowY;
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return element;
    }
    return getScrollParent(getParentNode(element));
  }
  function getReferenceNode(reference) {
    return reference && reference.referenceNode ? reference.referenceNode : reference;
  }
  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
  function isIE(version) {
    if (version === 11) {
      return isIE11;
    }
    if (version === 10) {
      return isIE10;
    }
    return isIE11 || isIE10;
  }
  function getOffsetParent(element) {
    if (!element) {
      return document.documentElement;
    }
    var noOffsetParent = isIE(10) ? document.body : null;
    var offsetParent = element.offsetParent || null;
    while (offsetParent === noOffsetParent && element.nextElementSibling) {
      offsetParent = (element = element.nextElementSibling).offsetParent;
    }
    var nodeName = offsetParent && offsetParent.nodeName;
    if (!nodeName || nodeName === "BODY" || nodeName === "HTML") {
      return element ? element.ownerDocument.documentElement : document.documentElement;
    }
    if (["TH", "TD", "TABLE"].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, "position") === "static") {
      return getOffsetParent(offsetParent);
    }
    return offsetParent;
  }
  function isOffsetContainer(element) {
    var nodeName = element.nodeName;
    if (nodeName === "BODY") {
      return false;
    }
    return nodeName === "HTML" || getOffsetParent(element.firstElementChild) === element;
  }
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }
    return node;
  }
  function findCommonOffsetParent(element1, element2) {
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;
    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }
      return getOffsetParent(commonAncestorContainer);
    }
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top";
    var upperSide = side === "top" ? "scrollTop" : "scrollLeft";
    var nodeName = element.nodeName;
    if (nodeName === "BODY" || nodeName === "HTML") {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }
    return element[upperSide];
  }
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var scrollTop = getScroll(element, "top");
    var scrollLeft = getScroll(element, "left");
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }
  function getBordersSize(styles, axis) {
    var sideA = axis === "x" ? "Left" : "Top";
    var sideB = sideA === "Left" ? "Right" : "Bottom";
    return parseFloat(styles["border" + sideA + "Width"]) + parseFloat(styles["border" + sideB + "Width"]);
  }
  function getSize(axis, body, html, computedStyle) {
    return Math.max(body["offset" + axis], body["scroll" + axis], html["client" + axis], html["offset" + axis], html["scroll" + axis], isIE(10) ? parseInt(html["offset" + axis]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Top" : "Left")]) + parseInt(computedStyle["margin" + (axis === "Height" ? "Bottom" : "Right")]) : 0);
  }
  function getWindowSizes(document2) {
    var body = document2.body;
    var html = document2.documentElement;
    var computedStyle = isIE(10) && getComputedStyle(html);
    return {
      height: getSize("Height", body, html, computedStyle),
      width: getSize("Width", body, html, computedStyle)
    };
  }
  var classCallCheck = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  var createClass = /* @__PURE__ */ function() {
    function defineProperties2(target, props2) {
      for (var i = 0; i < props2.length; i++) {
        var descriptor = props2[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties2(Constructor.prototype, protoProps);
      if (staticProps) defineProperties2(Constructor, staticProps);
      return Constructor;
    };
  }();
  var defineProperty = function(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  };
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }
  function getBoundingClientRect(element) {
    var rect = {};
    try {
      if (isIE(10)) {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, "top");
        var scrollLeft = getScroll(element, "left");
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } else {
        rect = element.getBoundingClientRect();
      }
    } catch (e2) {
    }
    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
    var sizes = element.nodeName === "HTML" ? getWindowSizes(element.ownerDocument) : {};
    var width = sizes.width || element.clientWidth || result.width;
    var height = sizes.height || element.clientHeight || result.height;
    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, "x");
      vertScrollbar -= getBordersSize(styles, "y");
      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }
    return getClientRect(result);
  }
  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var fixedPosition = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var isIE102 = isIE(10);
    var isHTML = parent.nodeName === "HTML";
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);
    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth);
    if (fixedPosition && isHTML) {
      parentRect.top = Math.max(parentRect.top, 0);
      parentRect.left = Math.max(parentRect.left, 0);
    }
    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;
    if (!isIE102 && isHTML) {
      var marginTop = parseFloat(styles.marginTop);
      var marginLeft = parseFloat(styles.marginLeft);
      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }
    if (isIE102 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== "BODY") {
      offsets = includeScroll(offsets, parent);
    }
    return offsets;
  }
  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var excludeScroll = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);
    var scrollTop = !excludeScroll ? getScroll(html) : 0;
    var scrollLeft = !excludeScroll ? getScroll(html, "left") : 0;
    var offset2 = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width,
      height
    };
    return getClientRect(offset2);
  }
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === "BODY" || nodeName === "HTML") {
      return false;
    }
    if (getStyleComputedProperty(element, "position") === "fixed") {
      return true;
    }
    var parentNode = getParentNode(element);
    if (!parentNode) {
      return false;
    }
    return isFixed(parentNode);
  }
  function getFixedPositionOffsetParent(element) {
    if (!element || !element.parentElement || isIE()) {
      return document.documentElement;
    }
    var el = element.parentElement;
    while (el && getStyleComputedProperty(el, "transform") === "none") {
      el = el.parentElement;
    }
    return el || document.documentElement;
  }
  function getBoundaries(popper, reference, padding, boundariesElement) {
    var fixedPosition = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    var boundaries = { top: 0, left: 0 };
    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    if (boundariesElement === "viewport") {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
    } else {
      var boundariesNode = void 0;
      if (boundariesElement === "scrollParent") {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === "BODY") {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === "window") {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }
      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);
      if (boundariesNode.nodeName === "HTML" && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(popper.ownerDocument), height = _getWindowSizes.height, width = _getWindowSizes.width;
        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        boundaries = offsets;
      }
    }
    padding = padding || 0;
    var isPaddingNumber = typeof padding === "number";
    boundaries.left += isPaddingNumber ? padding : padding.left || 0;
    boundaries.top += isPaddingNumber ? padding : padding.top || 0;
    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
    return boundaries;
  }
  function getArea(_ref) {
    var width = _ref.width, height = _ref.height;
    return width * height;
  }
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    if (placement.indexOf("auto") === -1) {
      return placement;
    }
    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };
    var sortedAreas = Object.keys(rects).map(function(key) {
      return _extends({
        key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function(a2, b) {
      return b.area - a2.area;
    });
    var filteredAreas = sortedAreas.filter(function(_ref2) {
      var width = _ref2.width, height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });
    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
    var variation = placement.split("-")[1];
    return computedPlacement + (variation ? "-" + variation : "");
  }
  function getReferenceOffsets(state, popper, reference) {
    var fixedPosition = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
  }
  function getOuterSizes(element) {
    var window2 = element.ownerDocument.defaultView;
    var styles = window2.getComputedStyle(element);
    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }
  function getOppositePlacement(placement) {
    var hash = { left: "right", right: "left", bottom: "top", top: "bottom" };
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash[matched];
    });
  }
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split("-")[0];
    var popperRect = getOuterSizes(popper);
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };
    var isHoriz = ["right", "left"].indexOf(placement) !== -1;
    var mainSide = isHoriz ? "top" : "left";
    var secondarySide = isHoriz ? "left" : "top";
    var measurement = isHoriz ? "height" : "width";
    var secondaryMeasurement = !isHoriz ? "height" : "width";
    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }
    return popperOffsets;
  }
  function find(arr, check) {
    if (Array.prototype.find) {
      return arr.find(check);
    }
    return arr.filter(check)[0];
  }
  function findIndex(arr, prop2, value) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(function(cur) {
        return cur[prop2] === value;
      });
    }
    var match = find(arr, function(obj) {
      return obj[prop2] === value;
    });
    return arr.indexOf(match);
  }
  function runModifiers(modifiers2, data, ends) {
    var modifiersToRun = ends === void 0 ? modifiers2 : modifiers2.slice(0, findIndex(modifiers2, "name", ends));
    modifiersToRun.forEach(function(modifier) {
      if (modifier["function"]) {
        console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
      }
      var fn = modifier["function"] || modifier.fn;
      if (modifier.enabled && isFunction(fn)) {
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);
        data = fn(data, modifier);
      }
    });
    return data;
  }
  function update() {
    if (this.state.isDestroyed) {
      return;
    }
    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);
    data.originalPlacement = data.placement;
    data.positionFixed = this.options.positionFixed;
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute";
    data = runModifiers(this.modifiers, data);
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }
  function isModifierEnabled(modifiers2, modifierName) {
    return modifiers2.some(function(_ref) {
      var name = _ref.name, enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }
  function getSupportedPropertyName(property) {
    var prefixes = [false, "ms", "Webkit", "Moz", "O"];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);
    for (var i = 0; i < prefixes.length; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? "" + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== "undefined") {
        return toCheck;
      }
    }
    return null;
  }
  function destroy() {
    this.state.isDestroyed = true;
    if (isModifierEnabled(this.modifiers, "applyStyle")) {
      this.popper.removeAttribute("x-placement");
      this.popper.style.position = "";
      this.popper.style.top = "";
      this.popper.style.left = "";
      this.popper.style.right = "";
      this.popper.style.bottom = "";
      this.popper.style.willChange = "";
      this.popper.style[getSupportedPropertyName("transform")] = "";
    }
    this.disableEventListeners();
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }
  function attachToScrollParents(scrollParent, event2, callback, scrollParents) {
    var isBody = scrollParent.nodeName === "BODY";
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event2, callback, { passive: true });
    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event2, callback, scrollParents);
    }
    scrollParents.push(target);
  }
  function setupEventListeners(reference, options, state, updateBound) {
    state.updateBound = updateBound;
    getWindow(reference).addEventListener("resize", state.updateBound, { passive: true });
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, "scroll", state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;
    return state;
  }
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }
  function removeEventListeners(reference, state) {
    getWindow(reference).removeEventListener("resize", state.updateBound);
    state.scrollParents.forEach(function(target) {
      target.removeEventListener("scroll", state.updateBound);
    });
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }
  function isNumeric(n) {
    return n !== "" && !isNaN(parseFloat(n)) && isFinite(n);
  }
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function(prop2) {
      var unit = "";
      if (["width", "height", "top", "right", "bottom", "left"].indexOf(prop2) !== -1 && isNumeric(styles[prop2])) {
        unit = "px";
      }
      element.style[prop2] = styles[prop2] + unit;
    });
  }
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function(prop2) {
      var value = attributes[prop2];
      if (value !== false) {
        element.setAttribute(prop2, attributes[prop2]);
      } else {
        element.removeAttribute(prop2);
      }
    });
  }
  function applyStyle(data) {
    setStyles(data.instance.popper, data.styles);
    setAttributes(data.instance.popper, data.attributes);
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }
    return data;
  }
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
    popper.setAttribute("x-placement", placement);
    setStyles(popper, { position: options.positionFixed ? "fixed" : "absolute" });
    return options;
  }
  function getRoundedOffsets(data, shouldRound) {
    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
    var round = Math.round, floor = Math.floor;
    var noRound = function noRound2(v) {
      return v;
    };
    var referenceWidth = round(reference.width);
    var popperWidth = round(popper.width);
    var isVertical = ["left", "right"].indexOf(data.placement) !== -1;
    var isVariation = data.placement.indexOf("-") !== -1;
    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
    var verticalToInteger = !shouldRound ? noRound : round;
    return {
      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
      top: verticalToInteger(popper.top),
      bottom: verticalToInteger(popper.bottom),
      right: horizontalToInteger(popper.right)
    };
  }
  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
  function computeStyle(data, options) {
    var x = options.x, y = options.y;
    var popper = data.offsets.popper;
    var legacyGpuAccelerationOption = find(data.instance.modifiers, function(modifier) {
      return modifier.name === "applyStyle";
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== void 0) {
      console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== void 0 ? legacyGpuAccelerationOption : options.gpuAcceleration;
    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);
    var styles = {
      position: popper.position
    };
    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
    var sideA = x === "bottom" ? "top" : "bottom";
    var sideB = y === "right" ? "left" : "right";
    var prefixedProperty = getSupportedPropertyName("transform");
    var left = void 0, top2 = void 0;
    if (sideA === "bottom") {
      if (offsetParent.nodeName === "HTML") {
        top2 = -offsetParent.clientHeight + offsets.bottom;
      } else {
        top2 = -offsetParentRect.height + offsets.bottom;
      }
    } else {
      top2 = offsets.top;
    }
    if (sideB === "right") {
      if (offsetParent.nodeName === "HTML") {
        left = -offsetParent.clientWidth + offsets.right;
      } else {
        left = -offsetParentRect.width + offsets.right;
      }
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = "translate3d(" + left + "px, " + top2 + "px, 0)";
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = "transform";
    } else {
      var invertTop = sideA === "bottom" ? -1 : 1;
      var invertLeft = sideB === "right" ? -1 : 1;
      styles[sideA] = top2 * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ", " + sideB;
    }
    var attributes = {
      "x-placement": data.placement
    };
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
    return data;
  }
  function isModifierRequired(modifiers2, requestingName, requestedName) {
    var requesting = find(modifiers2, function(_ref) {
      var name = _ref.name;
      return name === requestingName;
    });
    var isRequired = !!requesting && modifiers2.some(function(modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });
    if (!isRequired) {
      var _requesting = "`" + requestingName + "`";
      var requested = "`" + requestedName + "`";
      console.warn(requested + " modifier is required by " + _requesting + " modifier in order to work, be sure to include it before " + _requesting + "!");
    }
    return isRequired;
  }
  function arrow(data, options) {
    var _data$offsets$arrow;
    if (!isModifierRequired(data.instance.modifiers, "arrow", "keepTogether")) {
      return data;
    }
    var arrowElement = options.element;
    if (typeof arrowElement === "string") {
      arrowElement = data.instance.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return data;
      }
    } else {
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn("WARNING: `arrow.element` must be child of its popper element!");
        return data;
      }
    }
    var placement = data.placement.split("-")[0];
    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
    var isVertical = ["left", "right"].indexOf(placement) !== -1;
    var len = isVertical ? "height" : "width";
    var sideCapitalized = isVertical ? "Top" : "Left";
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? "left" : "top";
    var opSide = isVertical ? "bottom" : "right";
    var arrowElementSize = getOuterSizes(arrowElement)[len];
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css["margin" + sideCapitalized]);
    var popperBorderSide = parseFloat(css["border" + sideCapitalized + "Width"]);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ""), _data$offsets$arrow);
    return data;
  }
  function getOppositeVariation(variation) {
    if (variation === "end") {
      return "start";
    } else if (variation === "start") {
      return "end";
    }
    return variation;
  }
  var placements = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"];
  var validPlacements = placements.slice(3);
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }
  var BEHAVIORS = {
    FLIP: "flip",
    CLOCKWISE: "clockwise",
    COUNTERCLOCKWISE: "counterclockwise"
  };
  function flip(data, options) {
    if (isModifierEnabled(data.instance.modifiers, "inner")) {
      return data;
    }
    if (data.flipped && data.placement === data.originalPlacement) {
      return data;
    }
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
    var placement = data.placement.split("-")[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split("-")[1] || "";
    var flipOrder = [];
    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }
    flipOrder.forEach(function(step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }
      placement = data.placement.split("-")[0];
      placementOpposite = getOppositePlacement(placement);
      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;
      var floor = Math.floor;
      var overlapsRef = placement === "left" && floor(popperOffsets.right) > floor(refOffsets.left) || placement === "right" && floor(popperOffsets.left) < floor(refOffsets.right) || placement === "top" && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === "bottom" && floor(popperOffsets.top) < floor(refOffsets.bottom);
      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
      var overflowsBoundaries = placement === "left" && overflowsLeft || placement === "right" && overflowsRight || placement === "top" && overflowsTop || placement === "bottom" && overflowsBottom;
      var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === "start" && overflowsLeft || isVertical && variation === "end" && overflowsRight || !isVertical && variation === "start" && overflowsTop || !isVertical && variation === "end" && overflowsBottom);
      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === "start" && overflowsRight || isVertical && variation === "end" && overflowsLeft || !isVertical && variation === "start" && overflowsBottom || !isVertical && variation === "end" && overflowsTop);
      var flippedVariation = flippedVariationByRef || flippedVariationByContent;
      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        data.flipped = true;
        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }
        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }
        data.placement = placement + (variation ? "-" + variation : "");
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
        data = runModifiers(data.instance.modifiers, data, "flip");
      }
    });
    return data;
  }
  function keepTogether(data) {
    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
    var placement = data.placement.split("-")[0];
    var floor = Math.floor;
    var isVertical = ["top", "bottom"].indexOf(placement) !== -1;
    var side = isVertical ? "right" : "bottom";
    var opSide = isVertical ? "left" : "top";
    var measurement = isVertical ? "width" : "height";
    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }
    return data;
  }
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];
    if (!value) {
      return str;
    }
    if (unit.indexOf("%") === 0) {
      var element = void 0;
      switch (unit) {
        case "%p":
          element = popperOffsets;
          break;
        case "%":
        case "%r":
        default:
          element = referenceOffsets;
      }
      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === "vh" || unit === "vw") {
      var size = void 0;
      if (unit === "vh") {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      return value;
    }
  }
  function parseOffset(offset2, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];
    var useHeight = ["right", "left"].indexOf(basePlacement) !== -1;
    var fragments = offset2.split(/(\+|\-)/).map(function(frag) {
      return frag.trim();
    });
    var divider = fragments.indexOf(find(fragments, function(frag) {
      return frag.search(/,|\s/) !== -1;
    }));
    if (fragments[divider] && fragments[divider].indexOf(",") === -1) {
      console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
    }
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];
    ops = ops.map(function(op, index) {
      var measurement = (index === 1 ? !useHeight : useHeight) ? "height" : "width";
      var mergeWithPrevious = false;
      return op.reduce(function(a2, b) {
        if (a2[a2.length - 1] === "" && ["+", "-"].indexOf(b) !== -1) {
          a2[a2.length - 1] = b;
          mergeWithPrevious = true;
          return a2;
        } else if (mergeWithPrevious) {
          a2[a2.length - 1] += b;
          mergeWithPrevious = false;
          return a2;
        } else {
          return a2.concat(b);
        }
      }, []).map(function(str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });
    ops.forEach(function(op, index) {
      op.forEach(function(frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === "-" ? -1 : 1);
        }
      });
    });
    return offsets;
  }
  function offset(data, _ref) {
    var offset2 = _ref.offset;
    var placement = data.placement, _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
    var basePlacement = placement.split("-")[0];
    var offsets = void 0;
    if (isNumeric(+offset2)) {
      offsets = [+offset2, 0];
    } else {
      offsets = parseOffset(offset2, popper, reference, basePlacement);
    }
    if (basePlacement === "left") {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === "right") {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === "top") {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === "bottom") {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }
    data.popper = popper;
    return data;
  }
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }
    var transformProp = getSupportedPropertyName("transform");
    var popperStyles = data.instance.popper.style;
    var top2 = popperStyles.top, left = popperStyles.left, transform = popperStyles[transformProp];
    popperStyles.top = "";
    popperStyles.left = "";
    popperStyles[transformProp] = "";
    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);
    popperStyles.top = top2;
    popperStyles.left = left;
    popperStyles[transformProp] = transform;
    options.boundaries = boundaries;
    var order = options.priority;
    var popper = data.offsets.popper;
    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === "right" ? "left" : "top";
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === "right" ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };
    order.forEach(function(placement) {
      var side = ["left", "top"].indexOf(placement) !== -1 ? "primary" : "secondary";
      popper = _extends({}, popper, check[side](placement));
    });
    data.offsets.popper = popper;
    return data;
  }
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var shiftvariation = placement.split("-")[1];
    if (shiftvariation) {
      var _data$offsets = data.offsets, reference = _data$offsets.reference, popper = _data$offsets.popper;
      var isVertical = ["bottom", "top"].indexOf(basePlacement) !== -1;
      var side = isVertical ? "left" : "top";
      var measurement = isVertical ? "width" : "height";
      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };
      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }
    return data;
  }
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, "hide", "preventOverflow")) {
      return data;
    }
    var refRect = data.offsets.reference;
    var bound = find(data.instance.modifiers, function(modifier) {
      return modifier.name === "preventOverflow";
    }).boundaries;
    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      if (data.hide === true) {
        return data;
      }
      data.hide = true;
      data.attributes["x-out-of-boundaries"] = "";
    } else {
      if (data.hide === false) {
        return data;
      }
      data.hide = false;
      data.attributes["x-out-of-boundaries"] = false;
    }
    return data;
  }
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split("-")[0];
    var _data$offsets = data.offsets, popper = _data$offsets.popper, reference = _data$offsets.reference;
    var isHoriz = ["left", "right"].indexOf(basePlacement) !== -1;
    var subtractLength = ["top", "left"].indexOf(basePlacement) === -1;
    popper[isHoriz ? "left" : "top"] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? "width" : "height"] : 0);
    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);
    return data;
  }
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },
    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unit-less, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the `height`.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },
    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * A scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries" — or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ["left", "right", "top", "bottom"],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper. This makes sure the popper always has a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier. Can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: "scrollParent"
    },
    /**
     * Modifier used to make sure the reference and its popper stay near each other
     * without leaving any gap between the two. Especially useful when the arrow is
     * enabled and you want to ensure that it points to its reference element.
     * It cares only about the first axis. You can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },
    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjunction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: "[x-arrow]"
    },
    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations)
       */
      behavior: "flip",
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position.
       * The popper will never be placed outside of the defined boundaries
       * (except if `keepTogether` is enabled)
       */
      boundariesElement: "viewport",
      /**
       * @prop {Boolean} flipVariations=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the reference element overlaps its boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariations: false,
      /**
       * @prop {Boolean} flipVariationsByContent=false
       * The popper will switch placement variation between `-start` and `-end` when
       * the popper element overlaps its reference boundaries.
       *
       * The original placement should have a set variation.
       */
      flipVariationsByContent: false
    },
    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },
    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },
    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: "bottom",
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: "right"
    },
    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define your own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3D transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties
       */
      gpuAcceleration: void 0
    }
  };
  var Defaults = {
    /**
     * Popper's placement.
     * @prop {Popper.placements} placement='bottom'
     */
    placement: "bottom",
    /**
     * Set this to true if you want popper to position it self in 'fixed' mode
     * @prop {Boolean} positionFixed=false
     */
    positionFixed: false,
    /**
     * Whether events (resize, scroll) are initially enabled.
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,
    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,
    /**
     * Callback called when the popper is created.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {
    },
    /**
     * Callback called when the popper is updated. This callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, it is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {
    },
    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js.
     * @prop {modifiers}
     */
    modifiers
  };
  var Popper = function() {
    function Popper2(reference, popper) {
      var _this = this;
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      classCallCheck(this, Popper2);
      this.scheduleUpdate = function() {
        return requestAnimationFrame(_this.update);
      };
      this.update = debounce(this.update.bind(this));
      this.options = _extends({}, Popper2.Defaults, options);
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper2.Defaults.modifiers, options.modifiers)).forEach(function(name) {
        _this.options.modifiers[name] = _extends({}, Popper2.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });
      this.modifiers = Object.keys(this.options.modifiers).map(function(name) {
        return _extends({
          name
        }, _this.options.modifiers[name]);
      }).sort(function(a2, b) {
        return a2.order - b.order;
      });
      this.modifiers.forEach(function(modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });
      this.update();
      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        this.enableEventListeners();
      }
      this.state.eventsEnabled = eventsEnabled;
    }
    createClass(Popper2, [{
      key: "update",
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: "destroy",
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: "enableEventListeners",
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: "disableEventListeners",
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }
      /**
       * Schedules an update. It will run on the next UI update available.
       * @method scheduleUpdate
       * @memberof Popper
       */
      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */
    }]);
    return Popper2;
  }();
  Popper.Utils = (typeof window !== "undefined" ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults;
  var PLACEMENT_TOP_START = "top-start";
  var PLACEMENT_TOP_END = "top-end";
  var PLACEMENT_BOTTOM_START = "bottom-start";
  var PLACEMENT_BOTTOM_END = "bottom-end";
  var PLACEMENT_RIGHT_START = "right-start";
  var PLACEMENT_LEFT_START = "left-start";
  function _classCallCheck$4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$4(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$4(Constructor, protoProps, staticProps) {
    _defineProperties$4(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var BvEvent = /* @__PURE__ */ function() {
    function BvEvent2(type) {
      var eventInit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck$4(this, BvEvent2);
      if (!type) {
        throw new TypeError("Failed to construct '".concat(this.constructor.name, "'. 1 argument required, ").concat(arguments.length, " given."));
      }
      assign(this, BvEvent2.Defaults, this.constructor.Defaults, eventInit, {
        type
      });
      defineProperties(this, {
        type: readonlyDescriptor(),
        cancelable: readonlyDescriptor(),
        nativeEvent: readonlyDescriptor(),
        target: readonlyDescriptor(),
        relatedTarget: readonlyDescriptor(),
        vueTarget: readonlyDescriptor(),
        componentId: readonlyDescriptor()
      });
      var defaultPrevented = false;
      this.preventDefault = function preventDefault() {
        if (this.cancelable) {
          defaultPrevented = true;
        }
      };
      defineProperty$1(this, "defaultPrevented", {
        enumerable: true,
        get: function get2() {
          return defaultPrevented;
        }
      });
    }
    _createClass$4(BvEvent2, null, [{
      key: "Defaults",
      get: function get2() {
        return {
          type: "",
          cancelable: true,
          nativeEvent: null,
          target: null,
          relatedTarget: null,
          vueTarget: null,
          componentId: null
        };
      }
    }]);
    return BvEvent2;
  }();
  var clickOutMixin = extend({
    data: function data() {
      return {
        listenForClickOut: false
      };
    },
    watch: {
      listenForClickOut: function listenForClickOut(newValue, oldValue) {
        if (newValue !== oldValue) {
          eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
          if (newValue) {
            eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
          }
        }
      }
    },
    beforeCreate: function beforeCreate() {
      this.clickOutElement = null;
      this.clickOutEventName = null;
    },
    mounted: function mounted() {
      if (!this.clickOutElement) {
        this.clickOutElement = document;
      }
      if (!this.clickOutEventName) {
        this.clickOutEventName = "click";
      }
      if (this.listenForClickOut) {
        eventOn(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
      }
    },
    beforeDestroy: function beforeDestroy() {
      eventOff(this.clickOutElement, this.clickOutEventName, this._clickOutHandler, EVENT_OPTIONS_NO_CAPTURE);
    },
    methods: {
      isClickOut: function isClickOut(event2) {
        return !contains(this.$el, event2.target);
      },
      _clickOutHandler: function _clickOutHandler(event2) {
        if (this.clickOutHandler && this.isClickOut(event2)) {
          this.clickOutHandler(event2);
        }
      }
    }
  });
  var focusInMixin = extend({
    data: function data() {
      return {
        listenForFocusIn: false
      };
    },
    watch: {
      listenForFocusIn: function listenForFocusIn(newValue, oldValue) {
        if (newValue !== oldValue) {
          eventOff(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
          if (newValue) {
            eventOn(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
          }
        }
      }
    },
    beforeCreate: function beforeCreate() {
      this.focusInElement = null;
    },
    mounted: function mounted() {
      if (!this.focusInElement) {
        this.focusInElement = document;
      }
      if (this.listenForFocusIn) {
        eventOn(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
      }
    },
    beforeDestroy: function beforeDestroy() {
      eventOff(this.focusInElement, "focusin", this._focusInHandler, EVENT_OPTIONS_NO_CAPTURE);
    },
    methods: {
      _focusInHandler: function _focusInHandler(event2) {
        if (this.focusInHandler) {
          this.focusInHandler(event2);
        }
      }
    }
  });
  var registry = null;
  if (isVue3) {
    registry = /* @__PURE__ */ new WeakMap();
  }
  var registerElementToInstance = function registerElementToInstance2(element, instance) {
    if (!isVue3) {
      return;
    }
    registry.set(element, instance);
  };
  var removeElementToInstance = function removeElementToInstance2(element) {
    if (!isVue3) {
      return;
    }
    registry.delete(element);
  };
  var getInstanceFromElement = function getInstanceFromElement2(element) {
    if (!isVue3) {
      return element.__vue__;
    }
    var currentElement = element;
    while (currentElement) {
      if (registry.has(currentElement)) {
        return registry.get(currentElement);
      }
      currentElement = currentElement.parentNode;
    }
    return null;
  };
  function ownKeys$1b(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1b(Object(source), true).forEach(function(key) {
        _defineProperty$1t(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1b(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1t(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ROOT_EVENT_NAME_SHOWN = getRootEventName(NAME_DROPDOWN, EVENT_NAME_SHOWN);
  var ROOT_EVENT_NAME_HIDDEN = getRootEventName(NAME_DROPDOWN, EVENT_NAME_HIDDEN);
  var SELECTOR_FORM_CHILD = ".dropdown form";
  var SELECTOR_ITEM = [".dropdown-item", ".b-dropdown-form"].map(function(selector) {
    return "".concat(selector, ":not(.disabled):not([disabled])");
  }).join(", ");
  var filterVisibles = function filterVisibles2(els) {
    return (els || []).filter(isVisible);
  };
  var props$1O = makePropsConfigurable(sortKeys(_objectSpread$1b(_objectSpread$1b({}, props$25), {}, {
    // String: `scrollParent`, `window` or `viewport`
    // HTMLElement: HTML Element reference
    boundary: makeProp([HTMLElement, PROP_TYPE_STRING], "scrollParent"),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place left if possible
    dropleft: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place right if possible
    dropright: makeProp(PROP_TYPE_BOOLEAN, false),
    // Place on top if possible
    dropup: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable auto-flipping of menu from bottom <=> top
    noFlip: makeProp(PROP_TYPE_BOOLEAN, false),
    // Number of pixels or a CSS unit value to offset menu
    // (i.e. `1px`, `1rem`, etc.)
    offset: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    popperOpts: makeProp(PROP_TYPE_OBJECT, {}),
    // Right align menu (default is left align)
    right: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_DROPDOWN);
  var dropdownMixin = extend({
    mixins: [idMixin, listenOnRootMixin, clickOutMixin, focusInMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvDropdown: function getBvDropdown() {
          return _this;
        }
      };
    },
    inject: {
      getBvNavbar: {
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    props: props$1O,
    data: function data() {
      return {
        visible: false,
        visibleChangePrevented: false
      };
    },
    computed: {
      bvNavbar: function bvNavbar() {
        return this.getBvNavbar();
      },
      inNavbar: function inNavbar() {
        return !isNull(this.bvNavbar);
      },
      toggler: function toggler() {
        var toggle = this.$refs.toggle;
        return toggle ? toggle.$el || toggle : null;
      },
      directionClass: function directionClass() {
        if (this.dropup) {
          return "dropup";
        } else if (this.dropright) {
          return "dropright";
        } else if (this.dropleft) {
          return "dropleft";
        }
        return "";
      },
      boundaryClass: function boundaryClass() {
        return this.boundary !== "scrollParent" && !this.inNavbar ? "position-static" : "";
      },
      hideDelay: function hideDelay() {
        return this.inNavbar ? HAS_TOUCH_SUPPORT ? 300 : 50 : 0;
      }
    },
    watch: {
      visible: function visible(newValue, oldValue) {
        if (this.visibleChangePrevented) {
          this.visibleChangePrevented = false;
          return;
        }
        if (newValue !== oldValue) {
          var eventName = newValue ? EVENT_NAME_SHOW : EVENT_NAME_HIDE;
          var bvEvent = new BvEvent(eventName, {
            cancelable: true,
            vueTarget: this,
            target: this.$refs.menu,
            relatedTarget: null,
            componentId: this.safeId ? this.safeId() : this.id || null
          });
          this.emitEvent(bvEvent);
          if (bvEvent.defaultPrevented) {
            this.visibleChangePrevented = true;
            this.visible = oldValue;
            this.$off(EVENT_NAME_HIDDEN, this.focusToggler);
            return;
          }
          if (newValue) {
            this.showMenu();
          } else {
            this.hideMenu();
          }
        }
      },
      disabled: function disabled(newValue, oldValue) {
        if (newValue !== oldValue && newValue && this.visible) {
          this.visible = false;
        }
      }
    },
    created: function created() {
      this.$_popper = null;
      this.$_hideTimeout = null;
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.visible = false;
      this.whileOpenListen(false);
      this.destroyPopper();
    },
    mounted: function mounted() {
      registerElementToInstance(this.$el, this);
    },
    beforeDestroy: function beforeDestroy() {
      this.visible = false;
      this.whileOpenListen(false);
      this.destroyPopper();
      this.clearHideTimeout();
      removeElementToInstance(this.$el);
    },
    methods: {
      // Event emitter
      emitEvent: function emitEvent(bvEvent) {
        var type = bvEvent.type;
        this.emitOnRoot(getRootEventName(NAME_DROPDOWN, type), bvEvent);
        this.$emit(type, bvEvent);
      },
      showMenu: function showMenu() {
        var _this2 = this;
        if (this.disabled) {
          return;
        }
        if (!this.inNavbar) {
          if (typeof Popper === "undefined") {
            warn("Popper.js not found. Falling back to CSS positioning", NAME_DROPDOWN);
          } else {
            var el = this.dropup && this.right || this.split ? this.$el : this.$refs.toggle;
            el = el.$el || el;
            this.createPopper(el);
          }
        }
        this.emitOnRoot(ROOT_EVENT_NAME_SHOWN, this);
        this.whileOpenListen(true);
        this.$nextTick(function() {
          _this2.focusMenu();
          _this2.$emit(EVENT_NAME_SHOWN);
        });
      },
      hideMenu: function hideMenu() {
        this.whileOpenListen(false);
        this.emitOnRoot(ROOT_EVENT_NAME_HIDDEN, this);
        this.$emit(EVENT_NAME_HIDDEN);
        this.destroyPopper();
      },
      createPopper: function createPopper(element) {
        this.destroyPopper();
        this.$_popper = new Popper(element, this.$refs.menu, this.getPopperConfig());
      },
      // Ensure popper event listeners are removed cleanly
      destroyPopper: function destroyPopper() {
        this.$_popper && this.$_popper.destroy();
        this.$_popper = null;
      },
      // Instructs popper to re-computes the dropdown position
      // useful if the content changes size
      updatePopper: function updatePopper() {
        try {
          this.$_popper.scheduleUpdate();
        } catch (_unused) {
        }
      },
      clearHideTimeout: function clearHideTimeout() {
        clearTimeout(this.$_hideTimeout);
        this.$_hideTimeout = null;
      },
      getPopperConfig: function getPopperConfig() {
        var placement = PLACEMENT_BOTTOM_START;
        if (this.dropup) {
          placement = this.right ? PLACEMENT_TOP_END : PLACEMENT_TOP_START;
        } else if (this.dropright) {
          placement = PLACEMENT_RIGHT_START;
        } else if (this.dropleft) {
          placement = PLACEMENT_LEFT_START;
        } else if (this.right) {
          placement = PLACEMENT_BOTTOM_END;
        }
        var popperConfig = {
          placement,
          modifiers: {
            offset: {
              offset: this.offset || 0
            },
            flip: {
              enabled: !this.noFlip
            }
          }
        };
        var boundariesElement = this.boundary;
        if (boundariesElement) {
          popperConfig.modifiers.preventOverflow = {
            boundariesElement
          };
        }
        return mergeDeep(popperConfig, this.popperOpts || {});
      },
      // Turn listeners on/off while open
      whileOpenListen: function whileOpenListen(isOpen) {
        this.listenForClickOut = isOpen;
        this.listenForFocusIn = isOpen;
        var method = isOpen ? "listenOnRoot" : "listenOffRoot";
        this[method](ROOT_EVENT_NAME_SHOWN, this.rootCloseListener);
      },
      rootCloseListener: function rootCloseListener(vm) {
        if (vm !== this) {
          this.visible = false;
        }
      },
      // Public method to show dropdown
      show: function show() {
        var _this3 = this;
        if (this.disabled) {
          return;
        }
        requestAF(function() {
          _this3.visible = true;
        });
      },
      // Public method to hide dropdown
      hide: function hide2() {
        var refocus = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (this.disabled) {
          return;
        }
        this.visible = false;
        if (refocus) {
          this.$once(EVENT_NAME_HIDDEN, this.focusToggler);
        }
      },
      // Called only by a button that toggles the menu
      toggle: function toggle(event2) {
        event2 = event2 || {};
        var _event = event2, type = _event.type, keyCode = _event.keyCode;
        if (type !== "click" && !(type === "keydown" && [CODE_ENTER, CODE_SPACE, CODE_DOWN].indexOf(keyCode) !== -1)) {
          return;
        }
        if (this.disabled) {
          this.visible = false;
          return;
        }
        this.$emit(EVENT_NAME_TOGGLE, event2);
        stopEvent(event2);
        if (this.visible) {
          this.hide(true);
        } else {
          this.show();
        }
      },
      // Mousedown handler for the toggle
      /* istanbul ignore next */
      onMousedown: function onMousedown(event2) {
        stopEvent(event2, {
          propagation: false
        });
      },
      // Called from dropdown menu context
      onKeydown: function onKeydown(event2) {
        var keyCode = event2.keyCode;
        if (keyCode === CODE_ESC) {
          this.onEsc(event2);
        } else if (keyCode === CODE_DOWN) {
          this.focusNext(event2, false);
        } else if (keyCode === CODE_UP) {
          this.focusNext(event2, true);
        }
      },
      // If user presses ESC, close the menu
      onEsc: function onEsc(event2) {
        if (this.visible) {
          this.visible = false;
          stopEvent(event2);
          this.$once(EVENT_NAME_HIDDEN, this.focusToggler);
        }
      },
      // Called only in split button mode, for the split button
      onSplitClick: function onSplitClick(event2) {
        if (this.disabled) {
          this.visible = false;
          return;
        }
        this.$emit(EVENT_NAME_CLICK, event2);
      },
      // Shared hide handler between click-out and focus-in events
      hideHandler: function hideHandler(event2) {
        var _this4 = this;
        var target = event2.target;
        if (this.visible && !contains(this.$refs.menu, target) && !contains(this.toggler, target)) {
          this.clearHideTimeout();
          this.$_hideTimeout = setTimeout(function() {
            return _this4.hide();
          }, this.hideDelay);
        }
      },
      // Document click-out listener
      clickOutHandler: function clickOutHandler(event2) {
        this.hideHandler(event2);
      },
      // Document focus-in listener
      focusInHandler: function focusInHandler(event2) {
        this.hideHandler(event2);
      },
      // Keyboard nav
      focusNext: function focusNext(event2, up) {
        var _this5 = this;
        var target = event2.target;
        if (!this.visible || event2 && closest(SELECTOR_FORM_CHILD, target)) {
          return;
        }
        stopEvent(event2);
        this.$nextTick(function() {
          var items = _this5.getItems();
          if (items.length < 1) {
            return;
          }
          var index = items.indexOf(target);
          if (up && index > 0) {
            index--;
          } else if (!up && index < items.length - 1) {
            index++;
          }
          if (index < 0) {
            index = 0;
          }
          _this5.focusItem(index, items);
        });
      },
      focusItem: function focusItem(index, items) {
        var el = items.find(function(el2, i) {
          return i === index;
        });
        attemptFocus(el);
      },
      getItems: function getItems() {
        return filterVisibles(selectAll(SELECTOR_ITEM, this.$refs.menu));
      },
      focusMenu: function focusMenu() {
        attemptFocus(this.$refs.menu);
      },
      focusToggler: function focusToggler() {
        var _this6 = this;
        this.$nextTick(function() {
          attemptFocus(_this6.toggler);
        });
      }
    }
  });
  function ownKeys$1a(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1a(Object(source), true).forEach(function(key) {
        _defineProperty$1s(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1s(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1N = makePropsConfigurable(sortKeys(_objectSpread$1a(_objectSpread$1a(_objectSpread$1a({}, props$25), props$1O), {}, {
    block: makeProp(PROP_TYPE_BOOLEAN, false),
    html: makeProp(PROP_TYPE_STRING),
    // If `true`, only render menu contents when open
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    menuClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    noCaret: makeProp(PROP_TYPE_BOOLEAN, false),
    role: makeProp(PROP_TYPE_STRING, "menu"),
    size: makeProp(PROP_TYPE_STRING),
    split: makeProp(PROP_TYPE_BOOLEAN, false),
    splitButtonType: makeProp(PROP_TYPE_STRING, "button", function(value) {
      return arrayIncludes(["button", "submit", "reset"], value);
    }),
    splitClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    splitHref: makeProp(PROP_TYPE_STRING),
    splitTo: makeProp(PROP_TYPE_OBJECT_STRING),
    splitVariant: makeProp(PROP_TYPE_STRING),
    text: makeProp(PROP_TYPE_STRING),
    toggleAttrs: makeProp(PROP_TYPE_OBJECT, {}),
    toggleClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    toggleTag: makeProp(PROP_TYPE_STRING, "button"),
    // TODO: This really should be `toggleLabel`
    toggleText: makeProp(PROP_TYPE_STRING, "Toggle dropdown"),
    variant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_DROPDOWN);
  var BDropdown = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN,
    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
    props: props$1N,
    computed: {
      dropdownClasses: function dropdownClasses() {
        var block = this.block, split = this.split;
        return [this.directionClass, this.boundaryClass, {
          show: this.visible,
          // The 'btn-group' class is required in `split` mode for button alignment
          // It needs also to be applied when `block` is disabled to allow multiple
          // dropdowns to be aligned one line
          "btn-group": split || !block,
          // When `block` is enabled and we are in `split` mode the 'd-flex' class
          // needs to be applied to allow the buttons to stretch to full width
          "d-flex": block && split
        }];
      },
      menuClasses: function menuClasses() {
        return [this.menuClass, {
          "dropdown-menu-right": this.right,
          show: this.visible
        }];
      },
      toggleClasses: function toggleClasses() {
        var split = this.split;
        return [this.toggleClass, {
          "dropdown-toggle-split": split,
          "dropdown-toggle-no-caret": this.noCaret && !split
        }];
      }
    },
    render: function render(h) {
      var visible = this.visible, variant = this.variant, size = this.size, block = this.block, disabled = this.disabled, split = this.split, role = this.role, hide2 = this.hide, toggle = this.toggle;
      var commonProps = {
        variant,
        size,
        block,
        disabled
      };
      var $buttonChildren = this.normalizeSlot(SLOT_NAME_BUTTON_CONTENT);
      var buttonContentDomProps = this.hasNormalizedSlot(SLOT_NAME_BUTTON_CONTENT) ? {} : htmlOrText(this.html, this.text);
      var $split = h();
      if (split) {
        var splitTo = this.splitTo, splitHref = this.splitHref, splitButtonType = this.splitButtonType;
        var btnProps = _objectSpread$1a(_objectSpread$1a({}, commonProps), {}, {
          variant: this.splitVariant || variant
        });
        if (splitTo) {
          btnProps.to = splitTo;
        } else if (splitHref) {
          btnProps.href = splitHref;
        } else if (splitButtonType) {
          btnProps.type = splitButtonType;
        }
        $split = h(BButton, {
          class: this.splitClass,
          attrs: {
            id: this.safeId("_BV_button_")
          },
          props: btnProps,
          domProps: buttonContentDomProps,
          on: {
            click: this.onSplitClick
          },
          ref: "button"
        }, $buttonChildren);
        $buttonChildren = [h("span", {
          class: ["sr-only"]
        }, [this.toggleText])];
        buttonContentDomProps = {};
      }
      var ariaHasPopupRoles = ["menu", "listbox", "tree", "grid", "dialog"];
      var $toggle = h(BButton, {
        staticClass: "dropdown-toggle",
        class: this.toggleClasses,
        attrs: _objectSpread$1a(_objectSpread$1a({}, this.toggleAttrs), {}, {
          // Must have attributes
          id: this.safeId("_BV_toggle_"),
          "aria-haspopup": ariaHasPopupRoles.includes(role) ? role : "false",
          "aria-expanded": toString(visible)
        }),
        props: _objectSpread$1a(_objectSpread$1a({}, commonProps), {}, {
          tag: this.toggleTag,
          block: block && !split
        }),
        domProps: buttonContentDomProps,
        on: {
          mousedown: this.onMousedown,
          click: toggle,
          keydown: toggle
          // Handle ENTER, SPACE and DOWN
        },
        ref: "toggle"
      }, $buttonChildren);
      var $menu = h("ul", {
        staticClass: "dropdown-menu",
        class: this.menuClasses,
        attrs: {
          role,
          tabindex: "-1",
          "aria-labelledby": this.safeId(split ? "_BV_button_" : "_BV_toggle_")
        },
        on: {
          keydown: this.onKeydown
          // Handle UP, DOWN and ESC
        },
        ref: "menu"
      }, [!this.lazy || visible ? this.normalizeSlot(SLOT_NAME_DEFAULT, {
        hide: hide2
      }) : h()]);
      return h("div", {
        staticClass: "dropdown b-dropdown",
        class: this.dropdownClasses,
        attrs: {
          id: this.safeId()
        }
      }, [$split, $toggle, $menu]);
    }
  });
  function ownKeys$19(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$19(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$19(Object(source), true).forEach(function(key) {
        _defineProperty$1r(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$19(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1r(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var linkProps$4 = omit(props$2f, ["event", "routerTag"]);
  var props$1M = makePropsConfigurable(sortKeys(_objectSpread$19(_objectSpread$19({}, linkProps$4), {}, {
    linkClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    variant: makeProp(PROP_TYPE_STRING)
  })), NAME_DROPDOWN_ITEM);
  var BDropdownItem = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_ITEM,
    mixins: [attrsMixin, normalizeSlotMixin],
    inject: {
      getBvDropdown: {
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    inheritAttrs: false,
    props: props$1M,
    computed: {
      bvDropdown: function bvDropdown() {
        return this.getBvDropdown();
      },
      computedAttrs: function computedAttrs() {
        return _objectSpread$19(_objectSpread$19({}, this.bvAttrs), {}, {
          role: "menuitem"
        });
      }
    },
    methods: {
      closeDropdown: function closeDropdown() {
        var _this = this;
        requestAF(function() {
          if (_this.bvDropdown) {
            _this.bvDropdown.hide(true);
          }
        });
      },
      onClick: function onClick(event2) {
        this.$emit(EVENT_NAME_CLICK, event2);
        this.closeDropdown();
      }
    },
    render: function render(h) {
      var linkClass = this.linkClass, variant = this.variant, active = this.active, disabled = this.disabled, onClick = this.onClick, bvAttrs = this.bvAttrs;
      return h("li", {
        class: bvAttrs.class,
        style: bvAttrs.style,
        attrs: {
          role: "presentation"
        }
      }, [h(BLink, {
        staticClass: "dropdown-item",
        class: [linkClass, _defineProperty$1r({}, "text-".concat(variant), variant && !(active || disabled))],
        props: pluckProps(linkProps$4, this.$props),
        attrs: this.computedAttrs,
        on: {
          click: onClick
        },
        ref: "item"
      }, this.normalizeSlot())]);
    }
  });
  function ownKeys$18(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$18(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$18(Object(source), true).forEach(function(key) {
        _defineProperty$1q(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$18(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1q(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1L = makePropsConfigurable({
    active: makeProp(PROP_TYPE_BOOLEAN, false),
    activeClass: makeProp(PROP_TYPE_STRING, "active"),
    buttonClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_DROPDOWN_ITEM_BUTTON);
  var BDropdownItemButton = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_ITEM_BUTTON,
    mixins: [attrsMixin, normalizeSlotMixin],
    inject: {
      getBvDropdown: {
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    inheritAttrs: false,
    props: props$1L,
    computed: {
      bvDropdown: function bvDropdown() {
        return this.getBvDropdown();
      },
      computedAttrs: function computedAttrs() {
        return _objectSpread$18(_objectSpread$18({}, this.bvAttrs), {}, {
          role: "menuitem",
          type: "button",
          disabled: this.disabled
        });
      }
    },
    methods: {
      closeDropdown: function closeDropdown() {
        if (this.bvDropdown) {
          this.bvDropdown.hide(true);
        }
      },
      onClick: function onClick(event2) {
        this.$emit(EVENT_NAME_CLICK, event2);
        this.closeDropdown();
      }
    },
    render: function render(h) {
      var _ref;
      var active = this.active, variant = this.variant, bvAttrs = this.bvAttrs;
      return h("li", {
        class: bvAttrs.class,
        style: bvAttrs.style,
        attrs: {
          role: "presentation"
        }
      }, [h("button", {
        staticClass: "dropdown-item",
        class: [this.buttonClass, (_ref = {}, _defineProperty$1q(_ref, this.activeClass, active), _defineProperty$1q(_ref, "text-".concat(variant), variant && !(active || this.disabled)), _ref)],
        attrs: this.computedAttrs,
        on: {
          click: this.onClick
        },
        ref: "button"
      }, this.normalizeSlot())]);
    }
  });
  function ownKeys$17(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$17(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$17(Object(source), true).forEach(function(key) {
        _defineProperty$1p(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$17(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1p(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1K = makePropsConfigurable({
    id: makeProp(PROP_TYPE_STRING),
    tag: makeProp(PROP_TYPE_STRING, "header"),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_DROPDOWN_HEADER);
  var BDropdownHeader = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_HEADER,
    functional: true,
    props: props$1K,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var tag = props2.tag, variant = props2.variant;
      return h("li", a(omit(data, ["attrs"]), {
        attrs: {
          role: "presentation"
        }
      }), [h(tag, {
        staticClass: "dropdown-header",
        class: _defineProperty$1p({}, "text-".concat(variant), variant),
        attrs: _objectSpread$17(_objectSpread$17({}, data.attrs || {}), {}, {
          id: props2.id || null,
          role: isTag(tag, "header") ? null : "heading"
        }),
        ref: "header"
      }, children)]);
    }
  });
  function ownKeys$16(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$16(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$16(Object(source), true).forEach(function(key) {
        _defineProperty$1o(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$16(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1o(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1J = makePropsConfigurable({
    tag: makeProp(PROP_TYPE_STRING, "hr")
  }, NAME_DROPDOWN_DIVIDER);
  var BDropdownDivider = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_DIVIDER,
    functional: true,
    props: props$1J,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data;
      return h("li", a(omit(data, ["attrs"]), {
        attrs: {
          role: "presentation"
        }
      }), [h(props2.tag, {
        staticClass: "dropdown-divider",
        attrs: _objectSpread$16(_objectSpread$16({}, data.attrs || {}), {}, {
          role: "separator",
          "aria-orientation": "horizontal"
        }),
        ref: "divider"
      })]);
    }
  });
  var props$1I = makePropsConfigurable({
    id: makeProp(PROP_TYPE_STRING),
    inline: makeProp(PROP_TYPE_BOOLEAN, false),
    novalidate: makeProp(PROP_TYPE_BOOLEAN, false),
    validated: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_FORM);
  var BForm = /* @__PURE__ */ extend({
    name: NAME_FORM,
    functional: true,
    props: props$1I,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h("form", a(data, {
        class: {
          "form-inline": props2.inline,
          "was-validated": props2.validated
        },
        attrs: {
          id: props2.id,
          novalidate: props2.novalidate
        }
      }), children);
    }
  });
  function ownKeys$15(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$15(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$15(Object(source), true).forEach(function(key) {
        _defineProperty$1n(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$15(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1n(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1H = makePropsConfigurable(sortKeys(_objectSpread$15(_objectSpread$15({}, props$1I), {}, {
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    formClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  })), NAME_DROPDOWN_FORM);
  var BDropdownForm = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_FORM,
    functional: true,
    props: props$1H,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, listeners = _ref.listeners, children = _ref.children;
      return h("li", a(omit(data, ["attrs", "on"]), {
        attrs: {
          role: "presentation"
        }
      }), [h(BForm, {
        staticClass: "b-dropdown-form",
        class: [props2.formClass, {
          disabled: props2.disabled
        }],
        props: props2,
        attrs: _objectSpread$15(_objectSpread$15({}, data.attrs || {}), {}, {
          disabled: props2.disabled,
          // Tab index of -1 for keyboard navigation
          tabindex: props2.disabled ? null : "-1"
        }),
        on: listeners,
        ref: "form"
      }, children)]);
    }
  });
  function _defineProperty$1m(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1G = makePropsConfigurable({
    tag: makeProp(PROP_TYPE_STRING, "p"),
    textClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_DROPDOWN_TEXT);
  var BDropdownText = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_TEXT,
    functional: true,
    props: props$1G,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var tag = props2.tag, textClass = props2.textClass, variant = props2.variant;
      return h("li", a(omit(data, ["attrs"]), {
        attrs: {
          role: "presentation"
        }
      }), [h(tag, {
        staticClass: "b-dropdown-text",
        class: [textClass, _defineProperty$1m({}, "text-".concat(variant), variant)],
        props: props2,
        attrs: data.attrs || {},
        ref: "text"
      }, children)]);
    }
  });
  function ownKeys$14(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$14(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$14(Object(source), true).forEach(function(key) {
        _defineProperty$1l(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$14(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1l(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1F = makePropsConfigurable({
    ariaDescribedby: makeProp(PROP_TYPE_STRING),
    header: makeProp(PROP_TYPE_STRING),
    headerClasses: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    headerVariant: makeProp(PROP_TYPE_STRING),
    id: makeProp(PROP_TYPE_STRING)
  }, NAME_DROPDOWN_GROUP);
  var BDropdownGroup = /* @__PURE__ */ extend({
    name: NAME_DROPDOWN_GROUP,
    functional: true,
    props: props$1F,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var id = props2.id, variant = props2.variant, header = props2.header, headerTag = props2.headerTag;
      var $slots = slots();
      var $scopedSlots = scopedSlots || {};
      var slotScope = {};
      var headerId = id ? "_bv_".concat(id, "_group_dd_header") : null;
      var $header = h();
      if (hasNormalizedSlot(SLOT_NAME_HEADER, $scopedSlots, $slots) || header) {
        $header = h(headerTag, {
          staticClass: "dropdown-header",
          class: [props2.headerClasses, _defineProperty$1l({}, "text-".concat(variant), variant)],
          attrs: {
            id: headerId,
            role: isTag(headerTag, "header") ? null : "heading"
          }
        }, normalizeSlot(SLOT_NAME_HEADER, slotScope, $scopedSlots, $slots) || header);
      }
      return h("li", a(omit(data, ["attrs"]), {
        attrs: {
          role: "presentation"
        }
      }), [$header, h("ul", {
        staticClass: "list-unstyled",
        attrs: _objectSpread$14(_objectSpread$14({}, data.attrs || {}), {}, {
          id,
          role: "group",
          "aria-describedby": [headerId, props2.ariaDescribedBy].filter(identity).join(" ").trim() || null
        })
      }, normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots))]);
    }
  });
  var DropdownPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BDropdown,
      BDd: BDropdown,
      BDropdownItem,
      BDdItem: BDropdownItem,
      BDropdownItemButton,
      BDropdownItemBtn: BDropdownItemButton,
      BDdItemButton: BDropdownItemButton,
      BDdItemBtn: BDropdownItemButton,
      BDropdownHeader,
      BDdHeader: BDropdownHeader,
      BDropdownDivider,
      BDdDivider: BDropdownDivider,
      BDropdownForm,
      BDdForm: BDropdownForm,
      BDropdownText,
      BDdText: BDropdownText,
      BDropdownGroup,
      BDdGroup: BDropdownGroup
    }
  });
  function _defineProperty$1k(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TYPES$2 = ["iframe", "embed", "video", "object", "img", "b-img", "b-img-lazy"];
  var props$1E = makePropsConfigurable({
    aspect: makeProp(PROP_TYPE_STRING, "16by9"),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    type: makeProp(PROP_TYPE_STRING, "iframe", function(value) {
      return arrayIncludes(TYPES$2, value);
    })
  }, NAME_EMBED);
  var BEmbed = /* @__PURE__ */ extend({
    name: NAME_EMBED,
    functional: true,
    props: props$1E,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var aspect = props2.aspect;
      return h(props2.tag, {
        staticClass: "embed-responsive",
        class: _defineProperty$1k({}, "embed-responsive-".concat(aspect), aspect),
        ref: data.ref
      }, [h(props2.type, a(omit(data, ["ref"]), {
        staticClass: "embed-responsive-item"
      }), children)]);
    }
  });
  var EmbedPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BEmbed
    }
  });
  var OPTIONS_OBJECT_DEPRECATED_MSG = 'Setting prop "options" to an object is deprecated. Use the array format instead.';
  var props$1D = makePropsConfigurable({
    disabledField: makeProp(PROP_TYPE_STRING, "disabled"),
    htmlField: makeProp(PROP_TYPE_STRING, "html"),
    options: makeProp(PROP_TYPE_ARRAY_OBJECT, []),
    textField: makeProp(PROP_TYPE_STRING, "text"),
    valueField: makeProp(PROP_TYPE_STRING, "value")
  }, "formOptionControls");
  var formOptionsMixin = extend({
    props: props$1D,
    computed: {
      formOptions: function formOptions() {
        return this.normalizeOptions(this.options);
      }
    },
    methods: {
      normalizeOption: function normalizeOption(option) {
        var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        if (isPlainObject(option)) {
          var value = get(option, this.valueField);
          var text = get(option, this.textField);
          return {
            value: isUndefined(value) ? key || text : value,
            text: stripTags(String(isUndefined(text) ? key : text)),
            html: get(option, this.htmlField),
            disabled: Boolean(get(option, this.disabledField))
          };
        }
        return {
          value: key || option,
          text: stripTags(String(option)),
          disabled: false
        };
      },
      normalizeOptions: function normalizeOptions(options) {
        var _this = this;
        if (isArray(options)) {
          return options.map(function(option) {
            return _this.normalizeOption(option);
          });
        } else if (isPlainObject(options)) {
          warn(OPTIONS_OBJECT_DEPRECATED_MSG, this.$options.name);
          return keys(options).map(function(key) {
            return _this.normalizeOption(options[key] || {}, key);
          });
        }
        return [];
      }
    }
  });
  function ownKeys$13(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$13(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$13(Object(source), true).forEach(function(key) {
        _defineProperty$1j(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$13(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1j(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1C = makePropsConfigurable(sortKeys(_objectSpread$13(_objectSpread$13({}, props$1D), {}, {
    id: makeProp(PROP_TYPE_STRING, void 0, true)
    // Required
  })), NAME_FORM_DATALIST);
  var BFormDatalist = /* @__PURE__ */ extend({
    name: NAME_FORM_DATALIST,
    mixins: [formOptionsMixin, normalizeSlotMixin],
    props: props$1C,
    render: function render(h) {
      var id = this.id;
      var $options = this.formOptions.map(function(option, index) {
        var value = option.value, text = option.text, html = option.html, disabled = option.disabled;
        return h("option", {
          attrs: {
            value,
            disabled
          },
          domProps: htmlOrText(html, text),
          key: "option_".concat(index)
        });
      });
      return h("datalist", {
        attrs: {
          id
        }
      }, [$options, this.normalizeSlot()]);
    }
  });
  function _defineProperty$1i(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1B = makePropsConfigurable({
    id: makeProp(PROP_TYPE_STRING),
    inline: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "small"),
    textVariant: makeProp(PROP_TYPE_STRING, "muted")
  }, NAME_FORM_TEXT);
  var BFormText = /* @__PURE__ */ extend({
    name: NAME_FORM_TEXT,
    functional: true,
    props: props$1B,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        class: _defineProperty$1i({
          "form-text": !props2.inline
        }, "text-".concat(props2.textVariant), props2.textVariant),
        attrs: {
          id: props2.id
        }
      }), children);
    }
  });
  var props$1A = makePropsConfigurable({
    ariaLive: makeProp(PROP_TYPE_STRING),
    forceShow: makeProp(PROP_TYPE_BOOLEAN, false),
    id: makeProp(PROP_TYPE_STRING),
    role: makeProp(PROP_TYPE_STRING),
    // Tri-state prop: `true`, `false`, or `null`
    state: makeProp(PROP_TYPE_BOOLEAN, null),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    tooltip: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_FORM_INVALID_FEEDBACK);
  var BFormInvalidFeedback = /* @__PURE__ */ extend({
    name: NAME_FORM_INVALID_FEEDBACK,
    functional: true,
    props: props$1A,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var tooltip = props2.tooltip, ariaLive = props2.ariaLive;
      var show = props2.forceShow === true || props2.state === false;
      return h(props2.tag, a(data, {
        class: {
          "d-block": show,
          "invalid-feedback": !tooltip,
          "invalid-tooltip": tooltip
        },
        attrs: {
          id: props2.id || null,
          role: props2.role || null,
          "aria-live": ariaLive || null,
          "aria-atomic": ariaLive ? "true" : null
        }
      }), children);
    }
  });
  var props$1z = makePropsConfigurable({
    ariaLive: makeProp(PROP_TYPE_STRING),
    forceShow: makeProp(PROP_TYPE_BOOLEAN, false),
    id: makeProp(PROP_TYPE_STRING),
    role: makeProp(PROP_TYPE_STRING),
    // Tri-state prop: `true`, `false`, or `null`
    state: makeProp(PROP_TYPE_BOOLEAN, null),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    tooltip: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_FORM_VALID_FEEDBACK);
  var BFormValidFeedback = /* @__PURE__ */ extend({
    name: NAME_FORM_VALID_FEEDBACK,
    functional: true,
    props: props$1z,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var tooltip = props2.tooltip, ariaLive = props2.ariaLive;
      var show = props2.forceShow === true || props2.state === true;
      return h(props2.tag, a(data, {
        class: {
          "d-block": show,
          "valid-feedback": !tooltip,
          "valid-tooltip": tooltip
        },
        attrs: {
          id: props2.id || null,
          role: props2.role || null,
          "aria-live": ariaLive || null,
          "aria-atomic": ariaLive ? "true" : null
        }
      }), children);
    }
  });
  var props$1y = makePropsConfigurable({
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_FORM_ROW);
  var BFormRow = /* @__PURE__ */ extend({
    name: NAME_FORM_ROW,
    functional: true,
    props: props$1y,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        staticClass: "form-row"
      }), children);
    }
  });
  var FormPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BForm,
      BFormDatalist,
      BDatalist: BFormDatalist,
      BFormText,
      BFormInvalidFeedback,
      BFormFeedback: BFormInvalidFeedback,
      BFormValidFeedback,
      // Added here for convenience
      BFormRow
    }
  });
  var looseIndexOf = function looseIndexOf2(array, value) {
    for (var i = 0; i < array.length; i++) {
      if (looseEqual(array[i], value)) {
        return i;
      }
    }
    return -1;
  };
  var SELECTOR = "input, textarea, select";
  var props$1x = makePropsConfigurable({
    autofocus: makeProp(PROP_TYPE_BOOLEAN, false),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    form: makeProp(PROP_TYPE_STRING),
    id: makeProp(PROP_TYPE_STRING),
    name: makeProp(PROP_TYPE_STRING),
    required: makeProp(PROP_TYPE_BOOLEAN, false)
  }, "formControls");
  var formControlMixin = extend({
    props: props$1x,
    mounted: function mounted() {
      this.handleAutofocus();
    },
    /* istanbul ignore next */
    activated: function activated() {
      this.handleAutofocus();
    },
    methods: {
      handleAutofocus: function handleAutofocus() {
        var _this = this;
        this.$nextTick(function() {
          requestAF(function() {
            var el = _this.$el;
            if (_this.autofocus && isVisible(el)) {
              if (!matches(el, SELECTOR)) {
                el = select(SELECTOR, el);
              }
              attemptFocus(el);
            }
          });
        });
      }
    }
  });
  var props$1w = makePropsConfigurable({
    plain: makeProp(PROP_TYPE_BOOLEAN, false)
  }, "formControls");
  var formCustomMixin = extend({
    props: props$1w,
    computed: {
      custom: function custom() {
        return !this.plain;
      }
    }
  });
  var props$1v = makePropsConfigurable({
    size: makeProp(PROP_TYPE_STRING)
  }, "formControls");
  var formSizeMixin = extend({
    props: props$1v,
    computed: {
      sizeFormClass: function sizeFormClass() {
        return [this.size ? "form-control-".concat(this.size) : null];
      }
    }
  });
  var props$1u = makePropsConfigurable({
    // Tri-state prop: true, false, null (or undefined)
    state: makeProp(PROP_TYPE_BOOLEAN, null)
  }, "formState");
  var formStateMixin = extend({
    props: props$1u,
    computed: {
      computedState: function computedState() {
        return isBoolean(this.state) ? this.state : null;
      },
      stateClass: function stateClass() {
        var state = this.computedState;
        return state === true ? "is-valid" : state === false ? "is-invalid" : null;
      },
      computedAriaInvalid: function computedAriaInvalid() {
        var ariaInvalid = safeVueInstance(this).ariaInvalid;
        if (ariaInvalid === true || ariaInvalid === "true" || ariaInvalid === "") {
          return "true";
        }
        return this.computedState === false ? "true" : ariaInvalid;
      }
    }
  });
  var _watch$f, _methods;
  function ownKeys$12(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$12(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$12(Object(source), true).forEach(function(key) {
        _defineProperty$1h(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1h(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$g = makeModelMixin("checked", {
    defaultValue: null
  }), modelMixin$f = _makeModelMixin$g.mixin, modelProps$f = _makeModelMixin$g.props, MODEL_PROP_NAME$f = _makeModelMixin$g.prop, MODEL_EVENT_NAME$f = _makeModelMixin$g.event;
  var props$1t = makePropsConfigurable(sortKeys(_objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12(_objectSpread$12({}, props$25), modelProps$f), props$1x), props$1v), props$1u), props$1w), {}, {
    ariaLabel: makeProp(PROP_TYPE_STRING),
    ariaLabelledby: makeProp(PROP_TYPE_STRING),
    // Only applicable in standalone mode (non group)
    button: makeProp(PROP_TYPE_BOOLEAN, false),
    // Only applicable when rendered with button style
    buttonVariant: makeProp(PROP_TYPE_STRING),
    inline: makeProp(PROP_TYPE_BOOLEAN, false),
    value: makeProp(PROP_TYPE_ANY)
  })), "formRadioCheckControls");
  var formRadioCheckMixin = extend({
    mixins: [attrsMixin, idMixin, modelMixin$f, normalizeSlotMixin, formControlMixin, formSizeMixin, formStateMixin, formCustomMixin],
    inheritAttrs: false,
    props: props$1t,
    data: function data() {
      return {
        localChecked: this.isGroup ? this.bvGroup[MODEL_PROP_NAME$f] : this[MODEL_PROP_NAME$f],
        hasFocus: false
      };
    },
    computed: {
      computedLocalChecked: {
        get: function get2() {
          return this.isGroup ? this.bvGroup.localChecked : this.localChecked;
        },
        set: function set(value) {
          if (this.isGroup) {
            this.bvGroup.localChecked = value;
          } else {
            this.localChecked = value;
          }
        }
      },
      isChecked: function isChecked() {
        return looseEqual(this.value, this.computedLocalChecked);
      },
      isRadio: function isRadio() {
        return true;
      },
      isGroup: function isGroup() {
        return !!this.bvGroup;
      },
      isBtnMode: function isBtnMode() {
        return this.isGroup ? this.bvGroup.buttons : this.button;
      },
      isPlain: function isPlain() {
        return this.isBtnMode ? false : this.isGroup ? this.bvGroup.plain : this.plain;
      },
      isCustom: function isCustom() {
        return this.isBtnMode ? false : !this.isPlain;
      },
      isSwitch: function isSwitch() {
        return this.isBtnMode || this.isRadio || this.isPlain ? false : this.isGroup ? this.bvGroup.switches : this.switch;
      },
      isInline: function isInline() {
        return this.isGroup ? this.bvGroup.inline : this.inline;
      },
      isDisabled: function isDisabled2() {
        return this.isGroup ? this.bvGroup.disabled || this.disabled : this.disabled;
      },
      isRequired: function isRequired() {
        return this.computedName && (this.isGroup ? this.bvGroup.required : this.required);
      },
      computedName: function computedName() {
        return (this.isGroup ? this.bvGroup.groupName : this.name) || null;
      },
      computedForm: function computedForm() {
        return (this.isGroup ? this.bvGroup.form : this.form) || null;
      },
      computedSize: function computedSize() {
        return (this.isGroup ? this.bvGroup.size : this.size) || "";
      },
      computedState: function computedState() {
        return this.isGroup ? this.bvGroup.computedState : isBoolean(this.state) ? this.state : null;
      },
      computedButtonVariant: function computedButtonVariant() {
        var buttonVariant = this.buttonVariant;
        if (buttonVariant) {
          return buttonVariant;
        }
        if (this.isGroup && this.bvGroup.buttonVariant) {
          return this.bvGroup.buttonVariant;
        }
        return "secondary";
      },
      buttonClasses: function buttonClasses() {
        var _ref;
        var computedSize = this.computedSize;
        return ["btn", "btn-".concat(this.computedButtonVariant), (_ref = {}, _defineProperty$1h(_ref, "btn-".concat(computedSize), computedSize), _defineProperty$1h(_ref, "disabled", this.isDisabled), _defineProperty$1h(_ref, "active", this.isChecked), _defineProperty$1h(_ref, "focus", this.hasFocus), _ref)];
      },
      computedAttrs: function computedAttrs() {
        var disabled = this.isDisabled, required = this.isRequired;
        return _objectSpread$12(_objectSpread$12({}, this.bvAttrs), {}, {
          id: this.safeId(),
          type: this.isRadio ? "radio" : "checkbox",
          name: this.computedName,
          form: this.computedForm,
          disabled,
          required,
          "aria-required": required || null,
          "aria-label": this.ariaLabel || null,
          "aria-labelledby": this.ariaLabelledby || null
        });
      }
    },
    watch: (_watch$f = {}, _defineProperty$1h(_watch$f, MODEL_PROP_NAME$f, function() {
      this["".concat(MODEL_PROP_NAME$f, "Watcher")].apply(this, arguments);
    }), _defineProperty$1h(_watch$f, "computedLocalChecked", function computedLocalChecked() {
      this.computedLocalCheckedWatcher.apply(this, arguments);
    }), _watch$f),
    methods: (_methods = {}, _defineProperty$1h(_methods, "".concat(MODEL_PROP_NAME$f, "Watcher"), function Watcher(newValue) {
      if (!looseEqual(newValue, this.computedLocalChecked)) {
        this.computedLocalChecked = newValue;
      }
    }), _defineProperty$1h(_methods, "computedLocalCheckedWatcher", function computedLocalCheckedWatcher(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.$emit(MODEL_EVENT_NAME$f, newValue);
      }
    }), _defineProperty$1h(_methods, "handleChange", function handleChange(_ref2) {
      var _this = this;
      var checked = _ref2.target.checked;
      var value = this.value;
      var localChecked = checked ? value : null;
      this.computedLocalChecked = value;
      this.$nextTick(function() {
        _this.$emit(EVENT_NAME_CHANGE, localChecked);
        if (_this.isGroup) {
          _this.bvGroup.$emit(EVENT_NAME_CHANGE, localChecked);
        }
      });
    }), _defineProperty$1h(_methods, "handleFocus", function handleFocus2(event2) {
      if (event2.target) {
        if (event2.type === "focus") {
          this.hasFocus = true;
        } else if (event2.type === "blur") {
          this.hasFocus = false;
        }
      }
    }), _defineProperty$1h(_methods, "focus", function focus() {
      if (!this.isDisabled) {
        attemptFocus(this.$refs.input);
      }
    }), _defineProperty$1h(_methods, "blur", function blur() {
      if (!this.isDisabled) {
        attemptBlur(this.$refs.input);
      }
    }), _methods),
    render: function render(h) {
      var isRadio = this.isRadio, isBtnMode = this.isBtnMode, isPlain = this.isPlain, isCustom = this.isCustom, isInline = this.isInline, isSwitch = this.isSwitch, computedSize = this.computedSize, bvAttrs = this.bvAttrs;
      var $content = this.normalizeSlot();
      var $input = h("input", {
        class: [{
          "form-check-input": isPlain,
          "custom-control-input": isCustom,
          // https://github.com/bootstrap-vue/bootstrap-vue/issues/2911
          "position-static": isPlain && !$content
        }, isBtnMode ? "" : this.stateClass],
        directives: [{
          name: "model",
          value: this.computedLocalChecked
        }],
        attrs: this.computedAttrs,
        domProps: {
          value: this.value,
          checked: this.isChecked
        },
        on: _objectSpread$12({
          change: this.handleChange
        }, isBtnMode ? {
          focus: this.handleFocus,
          blur: this.handleFocus
        } : {}),
        key: "input",
        ref: "input"
      });
      if (isBtnMode) {
        var $button = h("label", {
          class: this.buttonClasses
        }, [$input, $content]);
        if (!this.isGroup) {
          $button = h("div", {
            class: ["btn-group-toggle", "d-inline-block"]
          }, [$button]);
        }
        return $button;
      }
      var $label = h();
      if (!(isPlain && !$content)) {
        $label = h("label", {
          class: {
            "form-check-label": isPlain,
            "custom-control-label": isCustom
          },
          attrs: {
            for: this.safeId()
          }
        }, $content);
      }
      return h("div", {
        class: [_defineProperty$1h({
          "form-check": isPlain,
          "form-check-inline": isPlain && isInline,
          "custom-control": isCustom,
          "custom-control-inline": isCustom && isInline,
          "custom-checkbox": isCustom && !isRadio && !isSwitch,
          "custom-switch": isSwitch,
          "custom-radio": isCustom && isRadio
        }, "b-custom-control-".concat(computedSize), computedSize && !isBtnMode), bvAttrs.class],
        style: bvAttrs.style
      }, [$input, $label]);
    }
  });
  var _objectSpread2$2;
  function ownKeys$11(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$11(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$11(Object(source), true).forEach(function(key) {
        _defineProperty$1g(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$11(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1g(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_INDETERMINATE = "indeterminate";
  var MODEL_EVENT_NAME_INDETERMINATE = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_INDETERMINATE;
  var props$1s = makePropsConfigurable(sortKeys(_objectSpread$11(_objectSpread$11({}, props$1t), {}, (_objectSpread2$2 = {}, _defineProperty$1g(_objectSpread2$2, MODEL_PROP_NAME_INDETERMINATE, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1g(_objectSpread2$2, "switch", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$1g(_objectSpread2$2, "uncheckedValue", makeProp(PROP_TYPE_ANY, false)), _defineProperty$1g(_objectSpread2$2, "value", makeProp(PROP_TYPE_ANY, true)), _objectSpread2$2))), NAME_FORM_CHECKBOX);
  var BFormCheckbox = /* @__PURE__ */ extend({
    name: NAME_FORM_CHECKBOX,
    mixins: [formRadioCheckMixin],
    inject: {
      getBvGroup: {
        from: "getBvCheckGroup",
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    props: props$1s,
    computed: {
      bvGroup: function bvGroup() {
        return this.getBvGroup();
      },
      isChecked: function isChecked() {
        var value = this.value, checked = this.computedLocalChecked;
        return isArray(checked) ? looseIndexOf(checked, value) > -1 : looseEqual(checked, value);
      },
      isRadio: function isRadio() {
        return false;
      }
    },
    watch: _defineProperty$1g({}, MODEL_PROP_NAME_INDETERMINATE, function(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.setIndeterminate(newValue);
      }
    }),
    mounted: function mounted() {
      this.setIndeterminate(this[MODEL_PROP_NAME_INDETERMINATE]);
    },
    methods: {
      computedLocalCheckedWatcher: function computedLocalCheckedWatcher(newValue, oldValue) {
        if (!looseEqual(newValue, oldValue)) {
          this.$emit(MODEL_EVENT_NAME$f, newValue);
          var $input = this.$refs.input;
          if ($input) {
            this.$emit(MODEL_EVENT_NAME_INDETERMINATE, $input.indeterminate);
          }
        }
      },
      handleChange: function handleChange(_ref) {
        var _this = this;
        var _ref$target = _ref.target, checked = _ref$target.checked, indeterminate = _ref$target.indeterminate;
        var value = this.value, uncheckedValue = this.uncheckedValue;
        var localChecked = this.computedLocalChecked;
        if (isArray(localChecked)) {
          var index = looseIndexOf(localChecked, value);
          if (checked && index < 0) {
            localChecked = localChecked.concat(value);
          } else if (!checked && index > -1) {
            localChecked = localChecked.slice(0, index).concat(localChecked.slice(index + 1));
          }
        } else {
          localChecked = checked ? value : uncheckedValue;
        }
        this.computedLocalChecked = localChecked;
        this.$nextTick(function() {
          _this.$emit(EVENT_NAME_CHANGE, localChecked);
          if (_this.isGroup) {
            _this.bvGroup.$emit(EVENT_NAME_CHANGE, localChecked);
          }
          _this.$emit(MODEL_EVENT_NAME_INDETERMINATE, indeterminate);
        });
      },
      setIndeterminate: function setIndeterminate(state) {
        if (isArray(this.computedLocalChecked)) {
          state = false;
        }
        var $input = this.$refs.input;
        if ($input) {
          $input.indeterminate = state;
          this.$emit(MODEL_EVENT_NAME_INDETERMINATE, state);
        }
      }
    }
  });
  var props$1r = makePropsConfigurable(props$1t, NAME_FORM_RADIO);
  var BFormRadio = /* @__PURE__ */ extend({
    name: NAME_FORM_RADIO,
    mixins: [formRadioCheckMixin],
    inject: {
      getBvGroup: {
        from: "getBvRadioGroup",
        default: function _default() {
          return function() {
            return null;
          };
        }
      }
    },
    props: props$1r,
    computed: {
      bvGroup: function bvGroup() {
        return this.getBvGroup();
      }
    }
  });
  var _watch$e;
  function ownKeys$10(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$10(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$10(Object(source), true).forEach(function(key) {
        _defineProperty$1f(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$10(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1f(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var PASS_DOWN_ATTRS = ["aria-describedby", "aria-labelledby"];
  var _makeModelMixin$f = makeModelMixin("checked"), modelMixin$e = _makeModelMixin$f.mixin, modelProps$e = _makeModelMixin$f.props, MODEL_PROP_NAME$e = _makeModelMixin$f.prop, MODEL_EVENT_NAME$e = _makeModelMixin$f.event;
  var props$1q = makePropsConfigurable(sortKeys(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10(_objectSpread$10({}, props$25), modelProps$e), props$1x), props$1D), props$1v), props$1u), props$1w), {}, {
    ariaInvalid: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    // Only applicable when rendered with button style
    buttonVariant: makeProp(PROP_TYPE_STRING),
    // Render as button style
    buttons: makeProp(PROP_TYPE_BOOLEAN, false),
    stacked: makeProp(PROP_TYPE_BOOLEAN, false),
    validated: makeProp(PROP_TYPE_BOOLEAN, false)
  })), "formRadioCheckGroups");
  var formRadioCheckGroupMixin = extend({
    mixins: [idMixin, modelMixin$e, normalizeSlotMixin, formControlMixin, formOptionsMixin, formSizeMixin, formStateMixin, formCustomMixin],
    inheritAttrs: false,
    props: props$1q,
    data: function data() {
      return {
        localChecked: this[MODEL_PROP_NAME$e]
      };
    },
    computed: {
      inline: function inline() {
        return !this.stacked;
      },
      groupName: function groupName() {
        return this.name || this.safeId();
      },
      groupClasses: function groupClasses() {
        var inline = this.inline, size = this.size, validated = this.validated;
        var classes = {
          "was-validated": validated
        };
        if (this.buttons) {
          classes = [classes, "btn-group-toggle", _defineProperty$1f({
            "btn-group": inline,
            "btn-group-vertical": !inline
          }, "btn-group-".concat(size), size)];
        }
        return classes;
      }
    },
    watch: (_watch$e = {}, _defineProperty$1f(_watch$e, MODEL_PROP_NAME$e, function(newValue) {
      if (!looseEqual(newValue, this.localChecked)) {
        this.localChecked = newValue;
      }
    }), _defineProperty$1f(_watch$e, "localChecked", function localChecked(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.$emit(MODEL_EVENT_NAME$e, newValue);
      }
    }), _watch$e),
    render: function render(h) {
      var _this = this;
      var isRadioGroup = this.isRadioGroup;
      var attrs = pick$1(this.$attrs, PASS_DOWN_ATTRS);
      var optionComponent = isRadioGroup ? BFormRadio : BFormCheckbox;
      var $inputs = this.formOptions.map(function(option, index) {
        var key = "BV_option_".concat(index);
        return h(optionComponent, {
          props: {
            // Individual radios or checks can be disabled in a group
            disabled: option.disabled || false,
            id: _this.safeId(key),
            value: option.value
            // We don't need to include these, since the input's will know they are inside here
            // form: this.form || null,
            // name: this.groupName,
            // required: Boolean(this.name && this.required),
            // state: this.state
          },
          attrs,
          key
        }, [h("span", {
          domProps: htmlOrText(option.html, option.text)
        })]);
      });
      return h("div", {
        class: [this.groupClasses, "bv-no-focus-ring"],
        attrs: _objectSpread$10(_objectSpread$10({}, omit(this.$attrs, PASS_DOWN_ATTRS)), {}, {
          "aria-invalid": this.computedAriaInvalid,
          "aria-required": this.required ? "true" : null,
          id: this.safeId(),
          role: isRadioGroup ? "radiogroup" : "group",
          // Add `tabindex="-1"` to allow group to be focused if needed by screen readers
          tabindex: "-1"
        })
      }, [this.normalizeSlot(SLOT_NAME_FIRST), $inputs, this.normalizeSlot()]);
    }
  });
  var _objectSpread2$1;
  function ownKeys$$(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$$(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$$(Object(source), true).forEach(function(key) {
        _defineProperty$1e(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$$(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1e(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1p = makePropsConfigurable(sortKeys(_objectSpread$$(_objectSpread$$({}, props$1q), {}, (_objectSpread2$1 = {}, _defineProperty$1e(_objectSpread2$1, MODEL_PROP_NAME$e, makeProp(PROP_TYPE_ARRAY, [])), _defineProperty$1e(_objectSpread2$1, "switches", makeProp(PROP_TYPE_BOOLEAN, false)), _objectSpread2$1))), NAME_FORM_CHECKBOX_GROUP);
  var BFormCheckboxGroup = /* @__PURE__ */ extend({
    name: NAME_FORM_CHECKBOX_GROUP,
    // Includes render function
    mixins: [formRadioCheckGroupMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvCheckGroup: function getBvCheckGroup() {
          return _this;
        }
      };
    },
    props: props$1p,
    computed: {
      isRadioGroup: function isRadioGroup() {
        return false;
      }
    }
  });
  var FormCheckboxPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormCheckbox,
      BCheckbox: BFormCheckbox,
      BCheck: BFormCheckbox,
      BFormCheckboxGroup,
      BCheckboxGroup: BFormCheckboxGroup,
      BCheckGroup: BFormCheckboxGroup
    }
  });
  var PROP$2 = "__BV_hover_handler__";
  var MOUSEENTER = "mouseenter";
  var MOUSELEAVE = "mouseleave";
  var createListener = function createListener2(handler) {
    var listener = function listener2(event2) {
      handler(event2.type === MOUSEENTER, event2);
    };
    listener.fn = handler;
    return listener;
  };
  var updateListeners = function updateListeners2(on, el, listener) {
    eventOnOff(on, el, MOUSEENTER, listener, EVENT_OPTIONS_NO_CAPTURE);
    eventOnOff(on, el, MOUSELEAVE, listener, EVENT_OPTIONS_NO_CAPTURE);
  };
  var directive = function directive2(el, _ref) {
    var _ref$value = _ref.value, handler = _ref$value === void 0 ? null : _ref$value;
    if (IS_BROWSER) {
      var listener = el[PROP$2];
      var hasListener = isFunction$1(listener);
      var handlerChanged = !(hasListener && listener.fn === handler);
      if (hasListener && handlerChanged) {
        updateListeners(false, el, listener);
        delete el[PROP$2];
      }
      if (isFunction$1(handler) && handlerChanged) {
        el[PROP$2] = createListener(handler);
        updateListeners(true, el, el[PROP$2]);
      }
    }
  };
  var VBHover = {
    bind: directive,
    componentUpdated: directive,
    unbind: function unbind2(el) {
      directive(el, {
        value: null
      });
    }
  };
  function ownKeys$_(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$_(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$_(Object(source), true).forEach(function(key) {
        _defineProperty$1d(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$_(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1d(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1o = sortKeys(_objectSpread$_(_objectSpread$_(_objectSpread$_(_objectSpread$_(_objectSpread$_(_objectSpread$_({}, props$25), props$1v), props$1u), omit(props$1O, ["disabled"])), omit(props$1x, ["autofocus"])), {}, {
    // When `true`, renders a `btn-group` wrapper and visually hides the label
    buttonOnly: makeProp(PROP_TYPE_BOOLEAN, false),
    // Applicable in button mode only
    buttonVariant: makeProp(PROP_TYPE_STRING, "secondary"),
    // This is the value shown in the label
    // Defaults back to `value`
    formattedValue: makeProp(PROP_TYPE_STRING),
    // Value placed in `.sr-only` span inside label when value is present
    labelSelected: makeProp(PROP_TYPE_STRING),
    lang: makeProp(PROP_TYPE_STRING),
    // Extra classes to apply to the `dropdown-menu` div
    menuClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // This is the value placed on the hidden input when no value selected
    placeholder: makeProp(PROP_TYPE_STRING),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    // Tri-state prop: `true`, `false` or `null`
    rtl: makeProp(PROP_TYPE_BOOLEAN, null),
    value: makeProp(PROP_TYPE_STRING, "")
  }));
  var BVFormBtnLabelControl = /* @__PURE__ */ extend({
    name: NAME_FORM_BUTTON_LABEL_CONTROL,
    directives: {
      "b-hover": VBHover
    },
    mixins: [idMixin, formSizeMixin, formStateMixin, dropdownMixin, normalizeSlotMixin],
    props: props$1o,
    data: function data() {
      return {
        isHovered: false,
        hasFocus: false
      };
    },
    computed: {
      idButton: function idButton() {
        return this.safeId();
      },
      idLabel: function idLabel() {
        return this.safeId("_value_");
      },
      idMenu: function idMenu() {
        return this.safeId("_dialog_");
      },
      idWrapper: function idWrapper() {
        return this.safeId("_outer_");
      },
      computedDir: function computedDir() {
        return this.rtl === true ? "rtl" : this.rtl === false ? "ltr" : null;
      }
    },
    methods: {
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.toggle);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$refs.toggle);
        }
      },
      setFocus: function setFocus(event2) {
        this.hasFocus = event2.type === "focus";
      },
      handleHover: function handleHover(hovered) {
        this.isHovered = hovered;
      }
    },
    render: function render(h) {
      var _class;
      var idButton = this.idButton, idLabel = this.idLabel, idMenu = this.idMenu, idWrapper = this.idWrapper, disabled = this.disabled, readonly = this.readonly, required = this.required, name = this.name, state = this.state, visible = this.visible, size = this.size, isHovered = this.isHovered, hasFocus = this.hasFocus, labelSelected = this.labelSelected, buttonVariant = this.buttonVariant, buttonOnly = this.buttonOnly;
      var value = toString(this.value) || "";
      var invalid = state === false || required && !value;
      var btnScope = {
        isHovered,
        hasFocus,
        state,
        opened: visible
      };
      var $button = h("button", {
        staticClass: "btn",
        class: (_class = {}, _defineProperty$1d(_class, "btn-".concat(buttonVariant), buttonOnly), _defineProperty$1d(_class, "btn-".concat(size), size), _defineProperty$1d(_class, "h-auto", !buttonOnly), _defineProperty$1d(_class, "dropdown-toggle", buttonOnly), _defineProperty$1d(_class, "dropdown-toggle-no-caret", buttonOnly), _class),
        attrs: {
          id: idButton,
          type: "button",
          disabled,
          "aria-haspopup": "dialog",
          "aria-expanded": visible ? "true" : "false",
          "aria-invalid": invalid ? "true" : null,
          "aria-required": required ? "true" : null
        },
        directives: [{
          name: "b-hover",
          value: this.handleHover
        }],
        on: {
          mousedown: this.onMousedown,
          click: this.toggle,
          keydown: this.toggle,
          // Handle ENTER, SPACE and DOWN
          "!focus": this.setFocus,
          "!blur": this.setFocus
        },
        ref: "toggle"
      }, [this.hasNormalizedSlot(SLOT_NAME_BUTTON_CONTENT) ? this.normalizeSlot(SLOT_NAME_BUTTON_CONTENT, btnScope) : (
        /* istanbul ignore next */
        h(BIconChevronDown, {
          props: {
            scale: 1.25
          }
        })
      )]);
      var $hidden = h();
      if (name && !disabled) {
        $hidden = h("input", {
          attrs: {
            type: "hidden",
            name: name || null,
            form: this.form || null,
            value
          }
        });
      }
      var $menu = h("div", {
        staticClass: "dropdown-menu",
        class: [this.menuClass, {
          show: visible,
          "dropdown-menu-right": this.right
        }],
        attrs: {
          id: idMenu,
          role: "dialog",
          tabindex: "-1",
          "aria-modal": "false",
          "aria-labelledby": idLabel
        },
        on: {
          keydown: this.onKeydown
          // Handle ESC
        },
        ref: "menu"
      }, [this.normalizeSlot(SLOT_NAME_DEFAULT, {
        opened: visible
      })]);
      var $label = h("label", {
        class: buttonOnly ? "sr-only" : [
          "form-control",
          // Mute the text if showing the placeholder
          {
            "text-muted": !value
          },
          this.stateClass,
          this.sizeFormClass
        ],
        attrs: {
          id: idLabel,
          for: idButton,
          "aria-invalid": invalid ? "true" : null,
          "aria-required": required ? "true" : null
        },
        directives: [{
          name: "b-hover",
          value: this.handleHover
        }],
        on: {
          // Disable bubbling of the click event to
          // prevent menu from closing and re-opening
          "!click": (
            /* istanbul ignore next */
            function click(event2) {
              stopEvent(event2, {
                preventDefault: false
              });
            }
          )
        }
      }, [
        value ? this.formattedValue || value : this.placeholder || "",
        // Add the selected label for screen readers when a value is provided
        value && labelSelected ? h("bdi", {
          staticClass: "sr-only"
        }, labelSelected) : ""
      ]);
      return h("div", {
        staticClass: "b-form-btn-label-control dropdown",
        class: [this.directionClass, this.boundaryClass, [{
          "btn-group": buttonOnly,
          "form-control": !buttonOnly,
          focus: hasFocus && !buttonOnly,
          show: visible,
          "is-valid": state === true,
          "is-invalid": state === false
        }, buttonOnly ? null : this.sizeFormClass]],
        attrs: {
          id: idWrapper,
          role: buttonOnly ? null : "group",
          lang: this.lang || null,
          dir: this.computedDir,
          "aria-disabled": disabled,
          "aria-readonly": readonly && !disabled,
          "aria-labelledby": idLabel,
          "aria-invalid": state === false || required && !value ? "true" : null,
          "aria-required": required ? "true" : null
        }
      }, [$button, $hidden, $menu, $label]);
    }
  });
  var _watch$d;
  function ownKeys$Z(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$Z(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Z(Object(source), true).forEach(function(key) {
        _defineProperty$1c(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Z(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1c(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$e = makeModelMixin("value", {
    type: PROP_TYPE_DATE_STRING
  }), modelMixin$d = _makeModelMixin$e.mixin, modelProps$d = _makeModelMixin$e.props, MODEL_PROP_NAME$d = _makeModelMixin$e.prop, MODEL_EVENT_NAME$d = _makeModelMixin$e.event;
  var calendarProps = omit(props$24, ["block", "hidden", "id", "noKeyNav", "roleDescription", "value", "width"]);
  var formBtnLabelControlProps$1 = omit(props$1o, ["formattedValue", "id", "lang", "rtl", "value"]);
  var props$1n = makePropsConfigurable(sortKeys(_objectSpread$Z(_objectSpread$Z(_objectSpread$Z(_objectSpread$Z(_objectSpread$Z({}, props$25), modelProps$d), calendarProps), formBtnLabelControlProps$1), {}, {
    // Width of the calendar dropdown
    calendarWidth: makeProp(PROP_TYPE_STRING, "270px"),
    closeButton: makeProp(PROP_TYPE_BOOLEAN, false),
    closeButtonVariant: makeProp(PROP_TYPE_STRING, "outline-secondary"),
    // Dark mode
    dark: makeProp(PROP_TYPE_BOOLEAN, false),
    labelCloseButton: makeProp(PROP_TYPE_STRING, "Close"),
    labelResetButton: makeProp(PROP_TYPE_STRING, "Reset"),
    labelTodayButton: makeProp(PROP_TYPE_STRING, "Select today"),
    noCloseOnSelect: makeProp(PROP_TYPE_BOOLEAN, false),
    resetButton: makeProp(PROP_TYPE_BOOLEAN, false),
    resetButtonVariant: makeProp(PROP_TYPE_STRING, "outline-danger"),
    resetValue: makeProp(PROP_TYPE_DATE_STRING),
    todayButton: makeProp(PROP_TYPE_BOOLEAN, false),
    todayButtonVariant: makeProp(PROP_TYPE_STRING, "outline-primary")
  })), NAME_FORM_DATEPICKER);
  var BFormDatepicker = /* @__PURE__ */ extend({
    name: NAME_FORM_DATEPICKER,
    mixins: [idMixin, modelMixin$d],
    props: props$1n,
    data: function data() {
      return {
        // We always use `YYYY-MM-DD` value internally
        localYMD: formatYMD(this[MODEL_PROP_NAME$d]) || "",
        // If the popup is open
        isVisible: false,
        // Context data from BCalendar
        localLocale: null,
        isRTL: false,
        formattedValue: "",
        activeYMD: ""
      };
    },
    computed: {
      calendarYM: function calendarYM() {
        return this.activeYMD.slice(0, -3);
      },
      computedLang: function computedLang() {
        return (this.localLocale || "").replace(/-u-.*$/i, "") || null;
      },
      computedResetValue: function computedResetValue() {
        return formatYMD(constrainDate(this.resetValue)) || "";
      }
    },
    watch: (_watch$d = {}, _defineProperty$1c(_watch$d, MODEL_PROP_NAME$d, function(newValue) {
      this.localYMD = formatYMD(newValue) || "";
    }), _defineProperty$1c(_watch$d, "localYMD", function localYMD(newValue) {
      if (this.isVisible) {
        this.$emit(MODEL_EVENT_NAME$d, this.valueAsDate ? parseYMD(newValue) || null : newValue || "");
      }
    }), _defineProperty$1c(_watch$d, "calendarYM", function calendarYM(newValue, oldValue) {
      if (newValue !== oldValue && oldValue) {
        try {
          this.$refs.control.updatePopper();
        } catch (_unused) {
        }
      }
    }), _watch$d),
    methods: {
      // Public methods
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.control);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$refs.control);
        }
      },
      // Private methods
      setAndClose: function setAndClose(ymd) {
        var _this = this;
        this.localYMD = ymd;
        if (!this.noCloseOnSelect) {
          this.$nextTick(function() {
            _this.$refs.control.hide(true);
          });
        }
      },
      onSelected: function onSelected(ymd) {
        var _this2 = this;
        this.$nextTick(function() {
          _this2.setAndClose(ymd);
        });
      },
      onInput: function onInput(ymd) {
        if (this.localYMD !== ymd) {
          this.localYMD = ymd;
        }
      },
      onContext: function onContext(ctx) {
        var activeYMD = ctx.activeYMD, isRTL = ctx.isRTL, locale = ctx.locale, selectedYMD = ctx.selectedYMD, selectedFormatted = ctx.selectedFormatted;
        this.isRTL = isRTL;
        this.localLocale = locale;
        this.formattedValue = selectedFormatted;
        this.localYMD = selectedYMD;
        this.activeYMD = activeYMD;
        this.$emit(EVENT_NAME_CONTEXT, ctx);
      },
      onTodayButton: function onTodayButton() {
        this.setAndClose(formatYMD(constrainDate(createDate(), this.min, this.max)));
      },
      onResetButton: function onResetButton() {
        this.setAndClose(this.computedResetValue);
      },
      onCloseButton: function onCloseButton() {
        this.$refs.control.hide(true);
      },
      // Menu handlers
      onShow: function onShow() {
        this.isVisible = true;
      },
      onShown: function onShown() {
        var _this3 = this;
        this.$nextTick(function() {
          attemptFocus(_this3.$refs.calendar);
          _this3.$emit(EVENT_NAME_SHOWN);
        });
      },
      onHidden: function onHidden() {
        this.isVisible = false;
        this.$emit(EVENT_NAME_HIDDEN);
      },
      // Render helpers
      defaultButtonFn: function defaultButtonFn(_ref) {
        var isHovered = _ref.isHovered, hasFocus = _ref.hasFocus;
        return this.$createElement(isHovered || hasFocus ? BIconCalendarFill : BIconCalendar, {
          attrs: {
            "aria-hidden": "true"
          }
        });
      }
    },
    render: function render(h) {
      var localYMD = this.localYMD, disabled = this.disabled, readonly = this.readonly, dark = this.dark, $props = this.$props, $scopedSlots = this.$scopedSlots;
      var placeholder = isUndefinedOrNull(this.placeholder) ? this.labelNoDateSelected : this.placeholder;
      var $footer = [];
      if (this.todayButton) {
        var label = this.labelTodayButton;
        $footer.push(h(BButton, {
          props: {
            disabled: disabled || readonly,
            size: "sm",
            variant: this.todayButtonVariant
          },
          attrs: {
            "aria-label": label || null
          },
          on: {
            click: this.onTodayButton
          }
        }, label));
      }
      if (this.resetButton) {
        var _label = this.labelResetButton;
        $footer.push(h(BButton, {
          props: {
            disabled: disabled || readonly,
            size: "sm",
            variant: this.resetButtonVariant
          },
          attrs: {
            "aria-label": _label || null
          },
          on: {
            click: this.onResetButton
          }
        }, _label));
      }
      if (this.closeButton) {
        var _label2 = this.labelCloseButton;
        $footer.push(h(BButton, {
          props: {
            disabled,
            size: "sm",
            variant: this.closeButtonVariant
          },
          attrs: {
            "aria-label": _label2 || null
          },
          on: {
            click: this.onCloseButton
          }
        }, _label2));
      }
      if ($footer.length > 0) {
        $footer = [h("div", {
          staticClass: "b-form-date-controls d-flex flex-wrap",
          class: {
            "justify-content-between": $footer.length > 1,
            "justify-content-end": $footer.length < 2
          }
        }, $footer)];
      }
      var $calendar = h(BCalendar, {
        staticClass: "b-form-date-calendar w-100",
        props: _objectSpread$Z(_objectSpread$Z({}, pluckProps(calendarProps, $props)), {}, {
          hidden: !this.isVisible,
          value: localYMD,
          valueAsDate: false,
          width: this.calendarWidth
        }),
        on: {
          selected: this.onSelected,
          input: this.onInput,
          context: this.onContext
        },
        scopedSlots: pick$1($scopedSlots, ["nav-prev-decade", "nav-prev-year", "nav-prev-month", "nav-this-month", "nav-next-month", "nav-next-year", "nav-next-decade"]),
        key: "calendar",
        ref: "calendar"
      }, $footer);
      return h(BVFormBtnLabelControl, {
        staticClass: "b-form-datepicker",
        props: _objectSpread$Z(_objectSpread$Z({}, pluckProps(formBtnLabelControlProps$1, $props)), {}, {
          formattedValue: localYMD ? this.formattedValue : "",
          id: this.safeId(),
          lang: this.computedLang,
          menuClass: [{
            "bg-dark": dark,
            "text-light": dark
          }, this.menuClass],
          placeholder,
          rtl: this.isRTL,
          value: localYMD
        }),
        on: {
          show: this.onShow,
          shown: this.onShown,
          hidden: this.onHidden
        },
        scopedSlots: _defineProperty$1c({}, SLOT_NAME_BUTTON_CONTENT, $scopedSlots[SLOT_NAME_BUTTON_CONTENT] || this.defaultButtonFn),
        ref: "control"
      }, [$calendar]);
    }
  });
  var FormDatepickerPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormDatepicker,
      BDatepicker: BFormDatepicker
    }
  });
  var _watch$c;
  function ownKeys$Y(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$Y(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Y(Object(source), true).forEach(function(key) {
        _defineProperty$1b(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Y(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1b(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$d = makeModelMixin("value", {
    type: [PROP_TYPE_ARRAY, File],
    defaultValue: null,
    validator: function validator(value) {
      if (value === "") {
        warn(VALUE_EMPTY_DEPRECATED_MSG, NAME_FORM_FILE);
        return true;
      }
      return isUndefinedOrNull(value) || isValidValue(value);
    }
  }), modelMixin$c = _makeModelMixin$d.mixin, modelProps$c = _makeModelMixin$d.props, MODEL_PROP_NAME$c = _makeModelMixin$d.prop, MODEL_EVENT_NAME$c = _makeModelMixin$d.event;
  var VALUE_EMPTY_DEPRECATED_MSG = 'Setting "value"/"v-model" to an empty string for reset is deprecated. Set to "null" instead.';
  var isValidValue = function isValidValue2(value) {
    return isFile(value) || isArray(value) && value.every(function(v) {
      return isValidValue2(v);
    });
  };
  var getDataTransferItemEntry = function getDataTransferItemEntry2(item) {
    return isFunction$1(item.getAsEntry) ? item.getAsEntry() : isFunction$1(item.webkitGetAsEntry) ? item.webkitGetAsEntry() : null;
  };
  var getAllFileEntries = function getAllFileEntries2(dataTransferItemList) {
    var traverseDirectories = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    return Promise.all(from(dataTransferItemList).filter(function(item) {
      return item.kind === "file";
    }).map(function(item) {
      var entry = getDataTransferItemEntry(item);
      if (entry) {
        if (entry.isDirectory && traverseDirectories) {
          return getAllFileEntriesInDirectory(entry.createReader(), "".concat(entry.name, "/"));
        } else if (entry.isFile) {
          return new Promise(function(resolve) {
            entry.file(function(file) {
              file.$path = "";
              resolve(file);
            });
          });
        }
      }
      return null;
    }).filter(identity));
  };
  var getAllFileEntriesInDirectory = function getAllFileEntriesInDirectory2(directoryReader) {
    var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    return new Promise(function(resolve) {
      var entryPromises = [];
      var readDirectoryEntries = function readDirectoryEntries2() {
        directoryReader.readEntries(function(entries) {
          if (entries.length === 0) {
            resolve(Promise.all(entryPromises).then(function(entries2) {
              return flatten(entries2);
            }));
          } else {
            entryPromises.push(Promise.all(entries.map(function(entry) {
              if (entry) {
                if (entry.isDirectory) {
                  return getAllFileEntriesInDirectory2(entry.createReader(), "".concat(path).concat(entry.name, "/"));
                } else if (entry.isFile) {
                  return new Promise(function(resolve2) {
                    entry.file(function(file) {
                      file.$path = "".concat(path).concat(file.name);
                      resolve2(file);
                    });
                  });
                }
              }
              return null;
            }).filter(identity)));
            readDirectoryEntries2();
          }
        });
      };
      readDirectoryEntries();
    });
  };
  var props$1m = makePropsConfigurable(sortKeys(_objectSpread$Y(_objectSpread$Y(_objectSpread$Y(_objectSpread$Y(_objectSpread$Y(_objectSpread$Y(_objectSpread$Y({}, props$25), modelProps$c), props$1x), props$1w), props$1u), props$1v), {}, {
    accept: makeProp(PROP_TYPE_STRING, ""),
    browseText: makeProp(PROP_TYPE_STRING, "Browse"),
    // Instruct input to capture from camera
    capture: makeProp(PROP_TYPE_BOOLEAN, false),
    directory: makeProp(PROP_TYPE_BOOLEAN, false),
    dropPlaceholder: makeProp(PROP_TYPE_STRING, "Drop files here"),
    fileNameFormatter: makeProp(PROP_TYPE_FUNCTION),
    multiple: makeProp(PROP_TYPE_BOOLEAN, false),
    noDrop: makeProp(PROP_TYPE_BOOLEAN, false),
    noDropPlaceholder: makeProp(PROP_TYPE_STRING, "Not allowed"),
    // TODO:
    //   Should we deprecate this and only support flat file structures?
    //   Nested file structures are only supported when files are dropped
    //   A Chromium "bug" prevents `webkitEntries` from being populated
    //   on the file input's `change` event and is marked as "WontFix"
    //   Mozilla implemented the behavior the same way as Chromium
    //   See: https://bugs.chromium.org/p/chromium/issues/detail?id=138987
    //   See: https://bugzilla.mozilla.org/show_bug.cgi?id=1326031
    noTraverse: makeProp(PROP_TYPE_BOOLEAN, false),
    placeholder: makeProp(PROP_TYPE_STRING, "No file chosen")
  })), NAME_FORM_FILE);
  var BFormFile = /* @__PURE__ */ extend({
    name: NAME_FORM_FILE,
    mixins: [attrsMixin, idMixin, modelMixin$c, normalizeSlotMixin, formControlMixin, formStateMixin, formCustomMixin, normalizeSlotMixin],
    inheritAttrs: false,
    props: props$1m,
    data: function data() {
      return {
        files: [],
        dragging: false,
        // IE 11 doesn't respect setting `event.dataTransfer.dropEffect`,
        // so we handle it ourselves as well
        // https://stackoverflow.com/a/46915971/2744776
        dropAllowed: !this.noDrop,
        hasFocus: false
      };
    },
    computed: {
      // Convert `accept` to an array of `[{ RegExpr, isMime }, ...]`
      computedAccept: function computedAccept() {
        var accept = this.accept;
        accept = (accept || "").trim().split(/[,\s]+/).filter(identity);
        if (accept.length === 0) {
          return null;
        }
        return accept.map(function(extOrType) {
          var prop2 = "name";
          var startMatch = "^";
          var endMatch = "$";
          if (RX_EXTENSION.test(extOrType)) {
            startMatch = "";
          } else {
            prop2 = "type";
            if (RX_STAR.test(extOrType)) {
              endMatch = ".+$";
              extOrType = extOrType.slice(0, -1);
            }
          }
          extOrType = escapeRegExp(extOrType);
          var rx = new RegExp("".concat(startMatch).concat(extOrType).concat(endMatch));
          return {
            rx,
            prop: prop2
          };
        });
      },
      computedCapture: function computedCapture() {
        var capture = this.capture;
        return capture === true || capture === "" ? true : capture || null;
      },
      computedAttrs: function computedAttrs() {
        var name = this.name, disabled = this.disabled, required = this.required, form = this.form, computedCapture = this.computedCapture, accept = this.accept, multiple = this.multiple, directory = this.directory;
        return _objectSpread$Y(_objectSpread$Y({}, this.bvAttrs), {}, {
          type: "file",
          id: this.safeId(),
          name,
          disabled,
          required,
          form: form || null,
          capture: computedCapture,
          accept: accept || null,
          multiple,
          directory,
          webkitdirectory: directory,
          "aria-required": required ? "true" : null
        });
      },
      computedFileNameFormatter: function computedFileNameFormatter() {
        var fileNameFormatter = this.fileNameFormatter;
        return hasPropFunction(fileNameFormatter) ? fileNameFormatter : this.defaultFileNameFormatter;
      },
      clonedFiles: function clonedFiles() {
        return cloneDeep(this.files);
      },
      flattenedFiles: function flattenedFiles() {
        return flattenDeep(this.files);
      },
      fileNames: function fileNames() {
        return this.flattenedFiles.map(function(file) {
          return file.name;
        });
      },
      labelContent: function labelContent() {
        if (this.dragging && !this.noDrop) {
          return (
            // TODO: Add additional scope with file count, and other not-allowed reasons
            this.normalizeSlot(SLOT_NAME_DROP_PLACEHOLDER, {
              allowed: this.dropAllowed
            }) || (this.dropAllowed ? this.dropPlaceholder : this.$createElement("span", {
              staticClass: "text-danger"
            }, this.noDropPlaceholder))
          );
        }
        if (this.files.length === 0) {
          return this.normalizeSlot(SLOT_NAME_PLACEHOLDER) || this.placeholder;
        }
        var flattenedFiles = this.flattenedFiles, clonedFiles = this.clonedFiles, fileNames = this.fileNames, computedFileNameFormatter = this.computedFileNameFormatter;
        if (this.hasNormalizedSlot(SLOT_NAME_FILE_NAME)) {
          return this.normalizeSlot(SLOT_NAME_FILE_NAME, {
            files: flattenedFiles,
            filesTraversed: clonedFiles,
            names: fileNames
          });
        }
        return computedFileNameFormatter(flattenedFiles, clonedFiles, fileNames);
      }
    },
    watch: (_watch$c = {}, _defineProperty$1b(_watch$c, MODEL_PROP_NAME$c, function(newValue) {
      if (!newValue || isArray(newValue) && newValue.length === 0) {
        this.reset();
      }
    }), _defineProperty$1b(_watch$c, "files", function files(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        var multiple = this.multiple, noTraverse = this.noTraverse;
        var files2 = !multiple || noTraverse ? flattenDeep(newValue) : newValue;
        this.$emit(MODEL_EVENT_NAME$c, multiple ? files2 : files2[0] || null);
      }
    }), _watch$c),
    created: function created() {
      this.$_form = null;
    },
    mounted: function mounted() {
      var $form = closest("form", this.$el);
      if ($form) {
        eventOn($form, "reset", this.reset, EVENT_OPTIONS_PASSIVE);
        this.$_form = $form;
      }
    },
    beforeDestroy: function beforeDestroy() {
      var $form = this.$_form;
      if ($form) {
        eventOff($form, "reset", this.reset, EVENT_OPTIONS_PASSIVE);
      }
    },
    methods: {
      isFileValid: function isFileValid(file) {
        if (!file) {
          return false;
        }
        var accept = this.computedAccept;
        return accept ? accept.some(function(a2) {
          return a2.rx.test(file[a2.prop]);
        }) : true;
      },
      isFilesArrayValid: function isFilesArrayValid(files) {
        var _this = this;
        return isArray(files) ? files.every(function(file) {
          return _this.isFileValid(file);
        }) : this.isFileValid(files);
      },
      defaultFileNameFormatter: function defaultFileNameFormatter(flattenedFiles, clonedFiles, fileNames) {
        return fileNames.join(", ");
      },
      setFiles: function setFiles(files) {
        this.dropAllowed = !this.noDrop;
        this.dragging = false;
        this.files = this.multiple ? this.directory ? files : flattenDeep(files) : flattenDeep(files).slice(0, 1);
      },
      /* istanbul ignore next: used by Drag/Drop */
      setInputFiles: function setInputFiles(files) {
        try {
          var dataTransfer = new ClipboardEvent("").clipboardData || new DataTransfer();
          flattenDeep(cloneDeep(files)).forEach(function(file) {
            delete file.$path;
            dataTransfer.items.add(file);
          });
          this.$refs.input.files = dataTransfer.files;
        } catch (_unused) {
        }
      },
      reset: function reset() {
        try {
          var $input = this.$refs.input;
          $input.value = "";
          $input.type = "";
          $input.type = "file";
        } catch (_unused2) {
        }
        this.files = [];
      },
      handleFiles: function handleFiles(files) {
        var isDrop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (isDrop) {
          var filteredFiles = files.filter(this.isFilesArrayValid);
          if (filteredFiles.length > 0) {
            this.setFiles(filteredFiles);
            this.setInputFiles(filteredFiles);
          }
        } else {
          this.setFiles(files);
        }
      },
      focusHandler: function focusHandler(event2) {
        if (this.plain || event2.type === "focusout") {
          this.hasFocus = false;
        } else {
          this.hasFocus = true;
        }
      },
      onChange: function onChange(event2) {
        var _this2 = this;
        var type = event2.type, target = event2.target, _event$dataTransfer = event2.dataTransfer, dataTransfer = _event$dataTransfer === void 0 ? {} : _event$dataTransfer;
        var isDrop = type === "drop";
        this.$emit(EVENT_NAME_CHANGE, event2);
        var items = from(dataTransfer.items || []);
        if (HAS_PROMISE_SUPPORT && items.length > 0 && !isNull(getDataTransferItemEntry(items[0]))) {
          getAllFileEntries(items, this.directory).then(function(files2) {
            return _this2.handleFiles(files2, isDrop);
          });
        } else {
          var files = from(target.files || dataTransfer.files || []).map(function(file) {
            file.$path = file.webkitRelativePath || "";
            return file;
          });
          this.handleFiles(files, isDrop);
        }
      },
      onDragenter: function onDragenter(event2) {
        stopEvent(event2);
        this.dragging = true;
        var _event$dataTransfer2 = event2.dataTransfer, dataTransfer = _event$dataTransfer2 === void 0 ? {} : _event$dataTransfer2;
        if (this.noDrop || this.disabled || !this.dropAllowed) {
          dataTransfer.dropEffect = "none";
          this.dropAllowed = false;
          return;
        }
        dataTransfer.dropEffect = "copy";
      },
      // Note this event fires repeatedly while the mouse is over the dropzone at
      // intervals in the milliseconds, so avoid doing much processing in here
      onDragover: function onDragover(event2) {
        stopEvent(event2);
        this.dragging = true;
        var _event$dataTransfer3 = event2.dataTransfer, dataTransfer = _event$dataTransfer3 === void 0 ? {} : _event$dataTransfer3;
        if (this.noDrop || this.disabled || !this.dropAllowed) {
          dataTransfer.dropEffect = "none";
          this.dropAllowed = false;
          return;
        }
        dataTransfer.dropEffect = "copy";
      },
      onDragleave: function onDragleave(event2) {
        var _this3 = this;
        stopEvent(event2);
        this.$nextTick(function() {
          _this3.dragging = false;
          _this3.dropAllowed = !_this3.noDrop;
        });
      },
      // Triggered by a file drop onto drop target
      onDrop: function onDrop(event2) {
        var _this4 = this;
        stopEvent(event2);
        this.dragging = false;
        if (this.noDrop || this.disabled || !this.dropAllowed) {
          this.$nextTick(function() {
            _this4.dropAllowed = !_this4.noDrop;
          });
          return;
        }
        this.onChange(event2);
      }
    },
    render: function render(h) {
      var custom = this.custom, plain = this.plain, size = this.size, dragging = this.dragging, stateClass = this.stateClass, bvAttrs = this.bvAttrs;
      var $input = h("input", {
        class: [{
          "form-control-file": plain,
          "custom-file-input": custom,
          focus: custom && this.hasFocus
        }, stateClass],
        // With IE 11, the input gets in the "way" of the drop events,
        // so we move it out of the way by putting it behind the label
        // Bootstrap v4 has it in front
        style: custom ? {
          zIndex: -5
        } : {},
        attrs: this.computedAttrs,
        on: {
          change: this.onChange,
          focusin: this.focusHandler,
          focusout: this.focusHandler,
          reset: this.reset
        },
        ref: "input"
      });
      if (plain) {
        return $input;
      }
      var $label = h("label", {
        staticClass: "custom-file-label",
        class: {
          dragging
        },
        attrs: {
          for: this.safeId(),
          // This goes away in Bootstrap v5
          "data-browse": this.browseText || null
        }
      }, [h("span", {
        staticClass: "d-block form-file-text",
        // `pointer-events: none` is used to make sure
        // the drag events fire only on the label
        style: {
          pointerEvents: "none"
        }
      }, [this.labelContent])]);
      return h("div", {
        staticClass: "custom-file b-form-file",
        class: [_defineProperty$1b({}, "b-custom-control-".concat(size), size), stateClass, bvAttrs.class],
        style: bvAttrs.style,
        attrs: {
          id: this.safeId("_BV_file_outer_")
        },
        on: {
          dragenter: this.onDragenter,
          dragover: this.onDragover,
          dragleave: this.onDragleave,
          drop: this.onDrop
        }
      }, [$input, $label]);
    }
  });
  var FormFilePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormFile,
      BFile: BFormFile
    }
  });
  var escapeChar = function escapeChar2(value) {
    return "\\" + value;
  };
  var cssEscape = function cssEscape2(value) {
    value = toString(value);
    var length = value.length;
    var firstCharCode = value.charCodeAt(0);
    return value.split("").reduce(function(result, char, index) {
      var charCode = value.charCodeAt(index);
      if (charCode === 0) {
        return result + "�";
      }
      if (
        // ... is U+007F OR
        charCode === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
        charCode >= 1 && charCode <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
        index === 0 && charCode >= 48 && charCode <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
        // and the first character is a `-` (U+002D) ...
        index === 1 && charCode >= 48 && charCode <= 57 && firstCharCode === 45
      ) {
        return result + escapeChar("".concat(charCode.toString(16), " "));
      }
      if (
        // ... is the first character AND ...
        index === 0 && // ... is a `-` (U+002D) AND ...
        charCode === 45 && // ... there is no second character ...
        length === 1
      ) {
        return result + escapeChar(char);
      }
      if (
        // ... is greater than or equal to U+0080 OR ...
        charCode >= 128 || // ... is `-` (U+002D) OR ...
        charCode === 45 || // ... is `_` (U+005F) OR ...
        charCode === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
        charCode >= 48 && charCode <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
        charCode >= 65 && charCode <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
        charCode >= 97 && charCode <= 122
      ) {
        return result + char;
      }
      return result + escapeChar(char);
    }, "");
  };
  function ownKeys$X(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$X(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$X(Object(source), true).forEach(function(key) {
        _defineProperty$1a(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$X(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1a(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var ALIGN_SELF_VALUES = ["auto", "start", "end", "center", "baseline", "stretch"];
  var computeBreakpoint = function computeBreakpoint2(type, breakpoint, value) {
    var className = type;
    if (isUndefinedOrNull(value) || value === false) {
      return void 0;
    }
    if (breakpoint) {
      className += "-".concat(breakpoint);
    }
    if (type === "col" && (value === "" || value === true)) {
      return lowerCase(className);
    }
    className += "-".concat(value);
    return lowerCase(className);
  };
  var computeBreakpointClass = memoize(computeBreakpoint);
  var breakpointPropMap = create(null);
  var generateProps$2 = function generateProps2() {
    var breakpoints = getBreakpointsUpCached().filter(identity);
    var breakpointCol = breakpoints.reduce(function(props2, breakpoint) {
      props2[breakpoint] = makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);
      return props2;
    }, create(null));
    var breakpointOffset = breakpoints.reduce(function(props2, breakpoint) {
      props2[suffixPropName(breakpoint, "offset")] = makeProp(PROP_TYPE_NUMBER_STRING);
      return props2;
    }, create(null));
    var breakpointOrder = breakpoints.reduce(function(props2, breakpoint) {
      props2[suffixPropName(breakpoint, "order")] = makeProp(PROP_TYPE_NUMBER_STRING);
      return props2;
    }, create(null));
    breakpointPropMap = assign(create(null), {
      col: keys(breakpointCol),
      offset: keys(breakpointOffset),
      order: keys(breakpointOrder)
    });
    return makePropsConfigurable(sortKeys(_objectSpread$X(_objectSpread$X(_objectSpread$X(_objectSpread$X({}, breakpointCol), breakpointOffset), breakpointOrder), {}, {
      // Flex alignment
      alignSelf: makeProp(PROP_TYPE_STRING, null, function(value) {
        return arrayIncludes(ALIGN_SELF_VALUES, value);
      }),
      // Generic flexbox 'col' (xs)
      col: makeProp(PROP_TYPE_BOOLEAN, false),
      // i.e. 'col-1', 'col-2', 'col-auto', ...
      cols: makeProp(PROP_TYPE_NUMBER_STRING),
      offset: makeProp(PROP_TYPE_NUMBER_STRING),
      order: makeProp(PROP_TYPE_NUMBER_STRING),
      tag: makeProp(PROP_TYPE_STRING, "div")
    })), NAME_COL);
  };
  var BCol = {
    name: NAME_COL,
    functional: true,
    get props() {
      delete this.props;
      return this.props = generateProps$2();
    },
    render: function render(h, _ref) {
      var _classList$push;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var cols = props2.cols, offset2 = props2.offset, order = props2.order, alignSelf = props2.alignSelf;
      var classList = [];
      for (var type in breakpointPropMap) {
        var _keys = breakpointPropMap[type];
        for (var i = 0; i < _keys.length; i++) {
          var c = computeBreakpointClass(type, _keys[i].replace(type, ""), props2[_keys[i]]);
          if (c) {
            classList.push(c);
          }
        }
      }
      var hasColClasses = classList.some(function(className) {
        return RX_COL_CLASS.test(className);
      });
      classList.push((_classList$push = {
        // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
        col: props2.col || !hasColClasses && !cols
      }, _defineProperty$1a(_classList$push, "col-".concat(cols), cols), _defineProperty$1a(_classList$push, "offset-".concat(offset2), offset2), _defineProperty$1a(_classList$push, "order-".concat(order), order), _defineProperty$1a(_classList$push, "align-self-".concat(alignSelf), alignSelf), _classList$push));
      return h(props2.tag, a(data, {
        class: classList
      }), children);
    }
  };
  function ownKeys$W(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$W(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$W(Object(source), true).forEach(function(key) {
        _defineProperty$19(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$W(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$19(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var INPUTS = ["input", "select", "textarea"];
  var INPUT_SELECTOR = INPUTS.map(function(v) {
    return "".concat(v, ":not([disabled])");
  }).join();
  var LEGEND_INTERACTIVE_ELEMENTS = [].concat(INPUTS, ["a", "button", "label"]);
  var generateProps$1 = function generateProps2() {
    return makePropsConfigurable(sortKeys(_objectSpread$W(_objectSpread$W(_objectSpread$W(_objectSpread$W({}, props$25), props$1u), getBreakpointsUpCached().reduce(function(props2, breakpoint) {
      props2[suffixPropName(breakpoint, "contentCols")] = makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);
      props2[suffixPropName(breakpoint, "labelAlign")] = makeProp(PROP_TYPE_STRING);
      props2[suffixPropName(breakpoint, "labelCols")] = makeProp(PROP_TYPE_BOOLEAN_NUMBER_STRING);
      return props2;
    }, create(null))), {}, {
      description: makeProp(PROP_TYPE_STRING),
      disabled: makeProp(PROP_TYPE_BOOLEAN, false),
      feedbackAriaLive: makeProp(PROP_TYPE_STRING, "assertive"),
      invalidFeedback: makeProp(PROP_TYPE_STRING),
      label: makeProp(PROP_TYPE_STRING),
      labelClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
      labelFor: makeProp(PROP_TYPE_STRING),
      labelSize: makeProp(PROP_TYPE_STRING),
      labelSrOnly: makeProp(PROP_TYPE_BOOLEAN, false),
      tooltip: makeProp(PROP_TYPE_BOOLEAN, false),
      validFeedback: makeProp(PROP_TYPE_STRING),
      validated: makeProp(PROP_TYPE_BOOLEAN, false)
    })), NAME_FORM_GROUP);
  };
  var BFormGroup = {
    name: NAME_FORM_GROUP,
    mixins: [idMixin, formStateMixin, normalizeSlotMixin],
    get props() {
      delete this.props;
      return this.props = generateProps$1();
    },
    data: function data() {
      return {
        ariaDescribedby: null
      };
    },
    computed: {
      contentColProps: function contentColProps() {
        return this.getColProps(this.$props, "content");
      },
      labelAlignClasses: function labelAlignClasses() {
        return this.getAlignClasses(this.$props, "label");
      },
      labelColProps: function labelColProps() {
        return this.getColProps(this.$props, "label");
      },
      isHorizontal: function isHorizontal() {
        return keys(this.contentColProps).length > 0 || keys(this.labelColProps).length > 0;
      }
    },
    watch: {
      ariaDescribedby: function ariaDescribedby(newValue, oldValue) {
        if (newValue !== oldValue) {
          this.updateAriaDescribedby(newValue, oldValue);
        }
      }
    },
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function() {
        _this.updateAriaDescribedby(_this.ariaDescribedby);
      });
    },
    methods: {
      getAlignClasses: function getAlignClasses(props2, prefix) {
        return getBreakpointsUpCached().reduce(function(result, breakpoint) {
          var propValue = props2[suffixPropName(breakpoint, "".concat(prefix, "Align"))] || null;
          if (propValue) {
            result.push(["text", breakpoint, propValue].filter(identity).join("-"));
          }
          return result;
        }, []);
      },
      getColProps: function getColProps(props2, prefix) {
        return getBreakpointsUpCached().reduce(function(result, breakpoint) {
          var propValue = props2[suffixPropName(breakpoint, "".concat(prefix, "Cols"))];
          propValue = propValue === "" ? true : propValue || false;
          if (!isBoolean(propValue) && propValue !== "auto") {
            propValue = toInteger(propValue, 0);
            propValue = propValue > 0 ? propValue : false;
          }
          if (propValue) {
            result[breakpoint || (isBoolean(propValue) ? "col" : "cols")] = propValue;
          }
          return result;
        }, {});
      },
      // Sets the `aria-describedby` attribute on the input if `labelFor` is set
      // Optionally accepts a string of IDs to remove as the second parameter
      // Preserves any `aria-describedby` value(s) user may have on input
      updateAriaDescribedby: function updateAriaDescribedby(newValue, oldValue) {
        var labelFor = this.labelFor;
        if (IS_BROWSER && labelFor) {
          var $input = select("#".concat(cssEscape(labelFor)), this.$refs.content);
          if ($input) {
            var attr = "aria-describedby";
            var newIds = (newValue || "").split(RX_SPACE_SPLIT);
            var oldIds = (oldValue || "").split(RX_SPACE_SPLIT);
            var ids = (getAttr($input, attr) || "").split(RX_SPACE_SPLIT).filter(function(id) {
              return !arrayIncludes(oldIds, id);
            }).concat(newIds).filter(function(id, index, ids2) {
              return ids2.indexOf(id) === index;
            }).filter(identity).join(" ").trim();
            if (ids) {
              setAttr($input, attr, ids);
            } else {
              removeAttr($input, attr);
            }
          }
        }
      },
      onLegendClick: function onLegendClick(event2) {
        if (this.labelFor) {
          return;
        }
        var target = event2.target;
        var tagName = target ? target.tagName : "";
        if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) {
          return;
        }
        var inputs = selectAll(INPUT_SELECTOR, this.$refs.content).filter(isVisible);
        if (inputs.length === 1) {
          attemptFocus(inputs[0]);
        }
      }
    },
    render: function render(h) {
      var state = this.computedState, feedbackAriaLive = this.feedbackAriaLive, isHorizontal = this.isHorizontal, labelFor = this.labelFor, normalizeSlot2 = this.normalizeSlot, safeId = this.safeId, tooltip = this.tooltip;
      var id = safeId();
      var isFieldset = !labelFor;
      var $label = h();
      var labelContent = normalizeSlot2(SLOT_NAME_LABEL) || this.label;
      var labelId = labelContent ? safeId("_BV_label_") : null;
      if (labelContent || isHorizontal) {
        var labelSize = this.labelSize, labelColProps = this.labelColProps;
        var labelTag = isFieldset ? "legend" : "label";
        if (this.labelSrOnly) {
          if (labelContent) {
            $label = h(labelTag, {
              class: "sr-only",
              attrs: {
                id: labelId,
                for: labelFor || null
              }
            }, [labelContent]);
          }
          $label = h(isHorizontal ? BCol : "div", {
            props: isHorizontal ? labelColProps : {}
          }, [$label]);
        } else {
          $label = h(isHorizontal ? BCol : labelTag, {
            on: isFieldset ? {
              click: this.onLegendClick
            } : {},
            props: isHorizontal ? _objectSpread$W(_objectSpread$W({}, labelColProps), {}, {
              tag: labelTag
            }) : {},
            attrs: {
              id: labelId,
              for: labelFor || null,
              // We add a `tabindex` to legend so that screen readers
              // will properly read the `aria-labelledby` in IE
              tabindex: isFieldset ? "-1" : null
            },
            class: [
              // Hide the focus ring on the legend
              isFieldset ? "bv-no-focus-ring" : "",
              // When horizontal or if a legend is rendered, add 'col-form-label' class
              // for correct sizing as Bootstrap has inconsistent font styling for
              // legend in non-horizontal form groups
              // See: https://github.com/twbs/bootstrap/issues/27805
              isHorizontal || isFieldset ? "col-form-label" : "",
              // Emulate label padding top of `0` on legend when not horizontal
              !isHorizontal && isFieldset ? "pt-0" : "",
              // If not horizontal and not a legend, we add 'd-block' class to label
              // so that label-align works
              !isHorizontal && !isFieldset ? "d-block" : "",
              labelSize ? "col-form-label-".concat(labelSize) : "",
              this.labelAlignClasses,
              this.labelClass
            ]
          }, [labelContent]);
        }
      }
      var $invalidFeedback = h();
      var invalidFeedbackContent = normalizeSlot2(SLOT_NAME_INVALID_FEEDBACK) || this.invalidFeedback;
      var invalidFeedbackId = invalidFeedbackContent ? safeId("_BV_feedback_invalid_") : null;
      if (invalidFeedbackContent) {
        $invalidFeedback = h(BFormInvalidFeedback, {
          props: {
            ariaLive: feedbackAriaLive,
            id: invalidFeedbackId,
            // If state is explicitly `false`, always show the feedback
            state,
            tooltip
          },
          attrs: {
            tabindex: invalidFeedbackContent ? "-1" : null
          }
        }, [invalidFeedbackContent]);
      }
      var $validFeedback = h();
      var validFeedbackContent = normalizeSlot2(SLOT_NAME_VALID_FEEDBACK) || this.validFeedback;
      var validFeedbackId = validFeedbackContent ? safeId("_BV_feedback_valid_") : null;
      if (validFeedbackContent) {
        $validFeedback = h(BFormValidFeedback, {
          props: {
            ariaLive: feedbackAriaLive,
            id: validFeedbackId,
            // If state is explicitly `true`, always show the feedback
            state,
            tooltip
          },
          attrs: {
            tabindex: validFeedbackContent ? "-1" : null
          }
        }, [validFeedbackContent]);
      }
      var $description = h();
      var descriptionContent = normalizeSlot2(SLOT_NAME_DESCRIPTION) || this.description;
      var descriptionId = descriptionContent ? safeId("_BV_description_") : null;
      if (descriptionContent) {
        $description = h(BFormText, {
          attrs: {
            id: descriptionId,
            tabindex: "-1"
          }
        }, [descriptionContent]);
      }
      var ariaDescribedby = this.ariaDescribedby = [descriptionId, state === false ? invalidFeedbackId : null, state === true ? validFeedbackId : null].filter(identity).join(" ") || null;
      var $content = h(isHorizontal ? BCol : "div", {
        props: isHorizontal ? this.contentColProps : {},
        ref: "content"
      }, [normalizeSlot2(SLOT_NAME_DEFAULT, {
        ariaDescribedby,
        descriptionId,
        id,
        labelId
      }) || h(), $invalidFeedback, $validFeedback, $description]);
      return h(isFieldset ? "fieldset" : isHorizontal ? BFormRow : "div", {
        staticClass: "form-group",
        class: [{
          "was-validated": this.validated
        }, this.stateClass],
        attrs: {
          id,
          disabled: isFieldset ? this.disabled : null,
          role: isFieldset ? null : "group",
          "aria-invalid": this.computedAriaInvalid,
          // Only apply `aria-labelledby` if we are a horizontal fieldset
          // as the legend is no longer a direct child of fieldset
          "aria-labelledby": isFieldset && isHorizontal ? labelId : null
        }
      }, isHorizontal && isFieldset ? [h(BFormRow, [$label, $content])] : [$label, $content]);
    }
  };
  var FormGroupPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormGroup,
      BFormFieldset: BFormGroup
    }
  });
  var formSelectionMixin = extend({
    computed: {
      selectionStart: {
        // Expose selectionStart for formatters, etc
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.selectionStart;
        },
        /* istanbul ignore next */
        set: function set(val) {
          this.$refs.input.selectionStart = val;
        }
      },
      selectionEnd: {
        // Expose selectionEnd for formatters, etc
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.selectionEnd;
        },
        /* istanbul ignore next */
        set: function set(val) {
          this.$refs.input.selectionEnd = val;
        }
      },
      selectionDirection: {
        // Expose selectionDirection for formatters, etc
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.selectionDirection;
        },
        /* istanbul ignore next */
        set: function set(val) {
          this.$refs.input.selectionDirection = val;
        }
      }
    },
    methods: {
      /* istanbul ignore next */
      select: function select2() {
        var _this$$refs$input;
        (_this$$refs$input = this.$refs.input).select.apply(_this$$refs$input, arguments);
      },
      /* istanbul ignore next */
      setSelectionRange: function setSelectionRange() {
        var _this$$refs$input2;
        (_this$$refs$input2 = this.$refs.input).setSelectionRange.apply(_this$$refs$input2, arguments);
      },
      /* istanbul ignore next */
      setRangeText: function setRangeText() {
        var _this$$refs$input3;
        (_this$$refs$input3 = this.$refs.input).setRangeText.apply(_this$$refs$input3, arguments);
      }
    }
  });
  function ownKeys$V(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$V(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$V(Object(source), true).forEach(function(key) {
        _defineProperty$18(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$V(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$18(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$c = makeModelMixin("value", {
    type: PROP_TYPE_NUMBER_STRING,
    defaultValue: "",
    event: EVENT_NAME_UPDATE
  }), modelMixin$b = _makeModelMixin$c.mixin, modelProps$b = _makeModelMixin$c.props, MODEL_PROP_NAME$b = _makeModelMixin$c.prop, MODEL_EVENT_NAME$b = _makeModelMixin$c.event;
  var props$1l = makePropsConfigurable(sortKeys(_objectSpread$V(_objectSpread$V({}, modelProps$b), {}, {
    ariaInvalid: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    autocomplete: makeProp(PROP_TYPE_STRING),
    // Debounce timeout (in ms). Not applicable with `lazy` prop
    debounce: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    formatter: makeProp(PROP_TYPE_FUNCTION),
    // Only update the `v-model` on blur/change events
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    lazyFormatter: makeProp(PROP_TYPE_BOOLEAN, false),
    number: makeProp(PROP_TYPE_BOOLEAN, false),
    placeholder: makeProp(PROP_TYPE_STRING),
    plaintext: makeProp(PROP_TYPE_BOOLEAN, false),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    trim: makeProp(PROP_TYPE_BOOLEAN, false)
  })), "formTextControls");
  var formTextMixin = extend({
    mixins: [modelMixin$b],
    props: props$1l,
    data: function data() {
      var value = this[MODEL_PROP_NAME$b];
      return {
        localValue: toString(value),
        vModelValue: this.modifyValue(value)
      };
    },
    computed: {
      computedClass: function computedClass() {
        var plaintext = this.plaintext, type = this.type;
        var isRange = type === "range";
        var isColor = type === "color";
        return [{
          // Range input needs class `custom-range`
          "custom-range": isRange,
          // `plaintext` not supported by `type="range"` or `type="color"`
          "form-control-plaintext": plaintext && !isRange && !isColor,
          // `form-control` not used by `type="range"` or `plaintext`
          // Always used by `type="color"`
          "form-control": isColor || !plaintext && !isRange
        }, this.sizeFormClass, this.stateClass];
      },
      computedDebounce: function computedDebounce() {
        return mathMax(toInteger(this.debounce, 0), 0);
      },
      hasFormatter: function hasFormatter() {
        return hasPropFunction(this.formatter);
      }
    },
    watch: _defineProperty$18({}, MODEL_PROP_NAME$b, function(newValue) {
      var stringifyValue = toString(newValue);
      var modifiedValue = this.modifyValue(newValue);
      if (stringifyValue !== this.localValue || modifiedValue !== this.vModelValue) {
        this.clearDebounce();
        this.localValue = stringifyValue;
        this.vModelValue = modifiedValue;
      }
    }),
    created: function created() {
      this.$_inputDebounceTimer = null;
    },
    beforeDestroy: function beforeDestroy() {
      this.clearDebounce();
    },
    methods: {
      clearDebounce: function clearDebounce() {
        clearTimeout(this.$_inputDebounceTimer);
        this.$_inputDebounceTimer = null;
      },
      formatValue: function formatValue(value, event2) {
        var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        value = toString(value);
        if (this.hasFormatter && (!this.lazyFormatter || force)) {
          value = this.formatter(value, event2);
        }
        return value;
      },
      modifyValue: function modifyValue(value) {
        value = toString(value);
        if (this.trim) {
          value = value.trim();
        }
        if (this.number) {
          value = toFloat(value, value);
        }
        return value;
      },
      updateValue: function updateValue(value) {
        var _this = this;
        var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var lazy = this.lazy;
        if (lazy && !force) {
          return;
        }
        this.clearDebounce();
        var doUpdate = function doUpdate2() {
          value = _this.modifyValue(value);
          if (value !== _this.vModelValue) {
            _this.vModelValue = value;
            _this.$emit(MODEL_EVENT_NAME$b, value);
          } else if (_this.hasFormatter) {
            var $input = _this.$refs.input;
            if ($input && value !== $input.value) {
              $input.value = value;
            }
          }
        };
        var debounce2 = this.computedDebounce;
        if (debounce2 > 0 && !lazy && !force) {
          this.$_inputDebounceTimer = setTimeout(doUpdate, debounce2);
        } else {
          doUpdate();
        }
      },
      onInput: function onInput(event2) {
        if (event2.target.composing) {
          return;
        }
        var value = event2.target.value;
        var formattedValue = this.formatValue(value, event2);
        if (formattedValue === false || event2.defaultPrevented) {
          stopEvent(event2, {
            propagation: false
          });
          return;
        }
        this.localValue = formattedValue;
        this.updateValue(formattedValue);
        this.$emit(EVENT_NAME_INPUT, formattedValue);
      },
      onChange: function onChange(event2) {
        var value = event2.target.value;
        var formattedValue = this.formatValue(value, event2);
        if (formattedValue === false || event2.defaultPrevented) {
          stopEvent(event2, {
            propagation: false
          });
          return;
        }
        this.localValue = formattedValue;
        this.updateValue(formattedValue, true);
        this.$emit(EVENT_NAME_CHANGE, formattedValue);
      },
      onBlur: function onBlur(event2) {
        var value = event2.target.value;
        var formattedValue = this.formatValue(value, event2, true);
        if (formattedValue !== false) {
          this.localValue = toString(this.modifyValue(formattedValue));
          this.updateValue(formattedValue, true);
        }
        this.$emit(EVENT_NAME_BLUR, event2);
      },
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$el);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$el);
        }
      }
    }
  });
  var formValidityMixin = extend({
    computed: {
      validity: {
        // Expose validity property
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.validity;
        }
      },
      validationMessage: {
        // Expose validationMessage property
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.validationMessage;
        }
      },
      willValidate: {
        // Expose willValidate property
        cache: false,
        /* istanbul ignore next */
        get: function get2() {
          return this.$refs.input.willValidate;
        }
      }
    },
    methods: {
      /* istanbul ignore next */
      setCustomValidity: function setCustomValidity() {
        var _this$$refs$input;
        return (_this$$refs$input = this.$refs.input).setCustomValidity.apply(_this$$refs$input, arguments);
      },
      /* istanbul ignore next */
      checkValidity: function checkValidity() {
        var _this$$refs$input2;
        return (_this$$refs$input2 = this.$refs.input).checkValidity.apply(_this$$refs$input2, arguments);
      },
      /* istanbul ignore next */
      reportValidity: function reportValidity() {
        var _this$$refs$input3;
        return (_this$$refs$input3 = this.$refs.input).reportValidity.apply(_this$$refs$input3, arguments);
      }
    }
  });
  function ownKeys$U(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$U(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$U(Object(source), true).forEach(function(key) {
        _defineProperty$17(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$U(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$17(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var TYPES$1 = ["text", "password", "email", "number", "url", "tel", "search", "range", "color", "date", "time", "datetime", "datetime-local", "month", "week"];
  var props$1k = makePropsConfigurable(sortKeys(_objectSpread$U(_objectSpread$U(_objectSpread$U(_objectSpread$U(_objectSpread$U(_objectSpread$U({}, props$25), props$1x), props$1v), props$1u), props$1l), {}, {
    list: makeProp(PROP_TYPE_STRING),
    max: makeProp(PROP_TYPE_NUMBER_STRING),
    min: makeProp(PROP_TYPE_NUMBER_STRING),
    // Disable mousewheel to prevent wheel from changing values (i.e. number/date)
    noWheel: makeProp(PROP_TYPE_BOOLEAN, false),
    step: makeProp(PROP_TYPE_NUMBER_STRING),
    type: makeProp(PROP_TYPE_STRING, "text", function(type) {
      return arrayIncludes(TYPES$1, type);
    })
  })), NAME_FORM_INPUT);
  var BFormInput = /* @__PURE__ */ extend({
    name: NAME_FORM_INPUT,
    // Mixin order is important!
    mixins: [listenersMixin, idMixin, formControlMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],
    props: props$1k,
    computed: {
      localType: function localType() {
        var type = this.type;
        return arrayIncludes(TYPES$1, type) ? type : "text";
      },
      computedAttrs: function computedAttrs() {
        var type = this.localType, name = this.name, form = this.form, disabled = this.disabled, placeholder = this.placeholder, required = this.required, min = this.min, max = this.max, step = this.step;
        return {
          id: this.safeId(),
          name,
          form,
          type,
          disabled,
          placeholder,
          required,
          autocomplete: this.autocomplete || null,
          readonly: this.readonly || this.plaintext,
          min,
          max,
          step,
          list: type !== "password" ? this.list : null,
          "aria-required": required ? "true" : null,
          "aria-invalid": this.computedAriaInvalid
        };
      },
      computedListeners: function computedListeners() {
        return _objectSpread$U(_objectSpread$U({}, this.bvListeners), {}, {
          input: this.onInput,
          change: this.onChange,
          blur: this.onBlur
        });
      }
    },
    watch: {
      noWheel: function noWheel(newValue) {
        this.setWheelStopper(newValue);
      }
    },
    mounted: function mounted() {
      this.setWheelStopper(this.noWheel);
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.setWheelStopper(false);
    },
    /* istanbul ignore next */
    activated: function activated() {
      this.setWheelStopper(this.noWheel);
    },
    beforeDestroy: function beforeDestroy() {
      this.setWheelStopper(false);
    },
    methods: {
      setWheelStopper: function setWheelStopper(on) {
        var input = this.$el;
        eventOnOff(on, input, "focus", this.onWheelFocus);
        eventOnOff(on, input, "blur", this.onWheelBlur);
        if (!on) {
          eventOff(document, "wheel", this.stopWheel);
        }
      },
      onWheelFocus: function onWheelFocus() {
        eventOn(document, "wheel", this.stopWheel);
      },
      onWheelBlur: function onWheelBlur() {
        eventOff(document, "wheel", this.stopWheel);
      },
      stopWheel: function stopWheel(event2) {
        stopEvent(event2, {
          propagation: false
        });
        attemptBlur(this.$el);
      }
    },
    render: function render(h) {
      return h("input", {
        class: this.computedClass,
        attrs: this.computedAttrs,
        domProps: {
          value: this.localValue
        },
        on: this.computedListeners,
        ref: "input"
      });
    }
  });
  var FormInputPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormInput,
      BInput: BFormInput
    }
  });
  var props$1j = makePropsConfigurable(props$1q, NAME_FORM_RADIO_GROUP);
  var BFormRadioGroup = /* @__PURE__ */ extend({
    name: NAME_FORM_RADIO_GROUP,
    mixins: [formRadioCheckGroupMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvRadioGroup: function getBvRadioGroup() {
          return _this;
        }
      };
    },
    props: props$1j,
    computed: {
      isRadioGroup: function isRadioGroup() {
        return true;
      }
    }
  });
  var FormRadioPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormRadio,
      BRadio: BFormRadio,
      BFormRadioGroup,
      BRadioGroup: BFormRadioGroup
    }
  });
  var _watch$b;
  function ownKeys$T(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$T(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$T(Object(source), true).forEach(function(key) {
        _defineProperty$16(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$T(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$16(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$b = makeModelMixin("value", {
    type: PROP_TYPE_NUMBER_STRING,
    event: EVENT_NAME_CHANGE
  }), modelMixin$a = _makeModelMixin$b.mixin, modelProps$a = _makeModelMixin$b.props, MODEL_PROP_NAME$a = _makeModelMixin$b.prop, MODEL_EVENT_NAME$a = _makeModelMixin$b.event;
  var MIN_STARS = 3;
  var DEFAULT_STARS = 5;
  var computeStars = function computeStars2(stars) {
    return mathMax(MIN_STARS, toInteger(stars, DEFAULT_STARS));
  };
  var clampValue = function clampValue2(value, min, max) {
    return mathMax(mathMin(value, max), min);
  };
  var BVFormRatingStar = extend({
    name: NAME_FORM_RATING_STAR,
    mixins: [normalizeSlotMixin],
    props: {
      disabled: makeProp(PROP_TYPE_BOOLEAN, false),
      // If parent is focused
      focused: makeProp(PROP_TYPE_BOOLEAN, false),
      hasClear: makeProp(PROP_TYPE_BOOLEAN, false),
      rating: makeProp(PROP_TYPE_NUMBER, 0),
      readonly: makeProp(PROP_TYPE_BOOLEAN, false),
      star: makeProp(PROP_TYPE_NUMBER, 0),
      variant: makeProp(PROP_TYPE_STRING)
    },
    methods: {
      onClick: function onClick(event2) {
        if (!this.disabled && !this.readonly) {
          stopEvent(event2, {
            propagation: false
          });
          this.$emit(EVENT_NAME_SELECTED, this.star);
        }
      }
    },
    render: function render(h) {
      var rating = this.rating, star = this.star, focused = this.focused, hasClear = this.hasClear, variant = this.variant, disabled = this.disabled, readonly = this.readonly;
      var minStar = hasClear ? 0 : 1;
      var type = rating >= star ? "full" : rating >= star - 0.5 ? "half" : "empty";
      var slotScope = {
        variant,
        disabled,
        readonly
      };
      return h("span", {
        staticClass: "b-rating-star",
        class: {
          // When not hovered, we use this class to focus the current (or first) star
          focused: focused && rating === star || !toInteger(rating) && star === minStar,
          // We add type classes to we can handle RTL styling
          "b-rating-star-empty": type === "empty",
          "b-rating-star-half": type === "half",
          "b-rating-star-full": type === "full"
        },
        attrs: {
          tabindex: !disabled && !readonly ? "-1" : null
        },
        on: {
          click: this.onClick
        }
      }, [h("span", {
        staticClass: "b-rating-icon"
      }, [this.normalizeSlot(type, slotScope)])]);
    }
  });
  var props$1i = makePropsConfigurable(sortKeys(_objectSpread$T(_objectSpread$T(_objectSpread$T(_objectSpread$T(_objectSpread$T({}, props$25), modelProps$a), omit(props$1x, ["required", "autofocus"])), props$1v), {}, {
    // CSS color string (overrides variant)
    color: makeProp(PROP_TYPE_STRING),
    iconClear: makeProp(PROP_TYPE_STRING, "x"),
    iconEmpty: makeProp(PROP_TYPE_STRING, "star"),
    iconFull: makeProp(PROP_TYPE_STRING, "star-fill"),
    iconHalf: makeProp(PROP_TYPE_STRING, "star-half"),
    inline: makeProp(PROP_TYPE_BOOLEAN, false),
    // Locale for the formatted value (if shown)
    // Defaults to the browser locale. Falls back to `en`
    locale: makeProp(PROP_TYPE_ARRAY_STRING),
    noBorder: makeProp(PROP_TYPE_BOOLEAN, false),
    precision: makeProp(PROP_TYPE_NUMBER_STRING),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    showClear: makeProp(PROP_TYPE_BOOLEAN, false),
    showValue: makeProp(PROP_TYPE_BOOLEAN, false),
    showValueMax: makeProp(PROP_TYPE_BOOLEAN, false),
    stars: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_STARS, function(value) {
      return toInteger(value) >= MIN_STARS;
    }),
    variant: makeProp(PROP_TYPE_STRING)
  })), NAME_FORM_RATING);
  var BFormRating = /* @__PURE__ */ extend({
    name: NAME_FORM_RATING,
    components: {
      BIconStar,
      BIconStarHalf,
      BIconStarFill,
      BIconX
    },
    mixins: [idMixin, modelMixin$a, formSizeMixin],
    props: props$1i,
    data: function data() {
      var value = toFloat(this[MODEL_PROP_NAME$a], null);
      var stars = computeStars(this.stars);
      return {
        localValue: isNull(value) ? null : clampValue(value, 0, stars),
        hasFocus: false
      };
    },
    computed: {
      computedStars: function computedStars() {
        return computeStars(this.stars);
      },
      computedRating: function computedRating() {
        var value = toFloat(this.localValue, 0);
        var precision = toInteger(this.precision, 3);
        return clampValue(toFloat(value.toFixed(precision)), 0, this.computedStars);
      },
      computedLocale: function computedLocale() {
        var locales = concat(this.locale).filter(identity);
        var nf = new Intl.NumberFormat(locales);
        return nf.resolvedOptions().locale;
      },
      isInteractive: function isInteractive() {
        return !this.disabled && !this.readonly;
      },
      isRTL: function isRTL() {
        return isLocaleRTL(this.computedLocale);
      },
      formattedRating: function formattedRating() {
        var precision = toInteger(this.precision);
        var showValueMax = this.showValueMax;
        var locale = this.computedLocale;
        var formatOptions = {
          notation: "standard",
          minimumFractionDigits: isNaN(precision) ? 0 : precision,
          maximumFractionDigits: isNaN(precision) ? 3 : precision
        };
        var stars = this.computedStars.toLocaleString(locale);
        var value = this.localValue;
        value = isNull(value) ? showValueMax ? "-" : "" : value.toLocaleString(locale, formatOptions);
        return showValueMax ? "".concat(value, "/").concat(stars) : value;
      }
    },
    watch: (_watch$b = {}, _defineProperty$16(_watch$b, MODEL_PROP_NAME$a, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        var value = toFloat(newValue, null);
        this.localValue = isNull(value) ? null : clampValue(value, 0, this.computedStars);
      }
    }), _defineProperty$16(_watch$b, "localValue", function localValue(newValue, oldValue) {
      if (newValue !== oldValue && newValue !== (this.value || 0)) {
        this.$emit(MODEL_EVENT_NAME$a, newValue || null);
      }
    }), _defineProperty$16(_watch$b, "disabled", function disabled(newValue) {
      if (newValue) {
        this.hasFocus = false;
        this.blur();
      }
    }), _watch$b),
    methods: {
      // --- Public methods ---
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$el);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$el);
        }
      },
      // --- Private methods ---
      onKeydown: function onKeydown(event2) {
        var keyCode = event2.keyCode;
        if (this.isInteractive && arrayIncludes([CODE_LEFT, CODE_DOWN, CODE_RIGHT, CODE_UP], keyCode)) {
          stopEvent(event2, {
            propagation: false
          });
          var value = toInteger(this.localValue, 0);
          var min = this.showClear ? 0 : 1;
          var stars = this.computedStars;
          var amountRtl = this.isRTL ? -1 : 1;
          if (keyCode === CODE_LEFT) {
            this.localValue = clampValue(value - amountRtl, min, stars) || null;
          } else if (keyCode === CODE_RIGHT) {
            this.localValue = clampValue(value + amountRtl, min, stars);
          } else if (keyCode === CODE_DOWN) {
            this.localValue = clampValue(value - 1, min, stars) || null;
          } else if (keyCode === CODE_UP) {
            this.localValue = clampValue(value + 1, min, stars);
          }
        }
      },
      onSelected: function onSelected(value) {
        if (this.isInteractive) {
          this.localValue = value;
        }
      },
      onFocus: function onFocus(event2) {
        this.hasFocus = !this.isInteractive ? false : event2.type === "focus";
      },
      // --- Render methods ---
      renderIcon: function renderIcon(icon) {
        return this.$createElement(BIcon, {
          props: {
            icon,
            variant: this.disabled || this.color ? null : this.variant || null
          }
        });
      },
      iconEmptyFn: function iconEmptyFn() {
        return this.renderIcon(this.iconEmpty);
      },
      iconHalfFn: function iconHalfFn() {
        return this.renderIcon(this.iconHalf);
      },
      iconFullFn: function iconFullFn() {
        return this.renderIcon(this.iconFull);
      },
      iconClearFn: function iconClearFn() {
        return this.$createElement(BIcon, {
          props: {
            icon: this.iconClear
          }
        });
      }
    },
    render: function render(h) {
      var _this = this;
      var disabled = this.disabled, readonly = this.readonly, name = this.name, form = this.form, inline = this.inline, variant = this.variant, color = this.color, noBorder = this.noBorder, hasFocus = this.hasFocus, computedRating = this.computedRating, computedStars = this.computedStars, formattedRating = this.formattedRating, showClear = this.showClear, isRTL = this.isRTL, isInteractive = this.isInteractive, $scopedSlots = this.$scopedSlots;
      var $content = [];
      if (showClear && !disabled && !readonly) {
        var $icon = h("span", {
          staticClass: "b-rating-icon"
        }, [($scopedSlots[SLOT_NAME_ICON_CLEAR] || this.iconClearFn)()]);
        $content.push(h("span", {
          staticClass: "b-rating-star b-rating-star-clear flex-grow-1",
          class: {
            focused: hasFocus && computedRating === 0
          },
          attrs: {
            tabindex: isInteractive ? "-1" : null
          },
          on: {
            click: function click() {
              return _this.onSelected(null);
            }
          },
          key: "clear"
        }, [$icon]));
      }
      for (var index = 0; index < computedStars; index++) {
        var value = index + 1;
        $content.push(h(BVFormRatingStar, {
          staticClass: "flex-grow-1",
          style: color && !disabled ? {
            color
          } : {},
          props: {
            rating: computedRating,
            star: value,
            variant: disabled ? null : variant || null,
            disabled,
            readonly,
            focused: hasFocus,
            hasClear: showClear
          },
          on: {
            selected: this.onSelected
          },
          scopedSlots: {
            empty: $scopedSlots[SLOT_NAME_ICON_EMPTY] || this.iconEmptyFn,
            half: $scopedSlots[SLOT_NAME_ICON_HALF] || this.iconHalfFn,
            full: $scopedSlots[SLOT_NAME_ICON_FULL] || this.iconFullFn
          },
          key: index
        }));
      }
      if (name) {
        $content.push(h("input", {
          attrs: {
            type: "hidden",
            value: isNull(this.localValue) ? "" : computedRating,
            name,
            form: form || null
          },
          key: "hidden"
        }));
      }
      if (this.showValue) {
        $content.push(h("b", {
          staticClass: "b-rating-value flex-grow-1",
          attrs: {
            "aria-hidden": "true"
          },
          key: "value"
        }, toString(formattedRating)));
      }
      return h("output", {
        staticClass: "b-rating form-control align-items-center",
        class: [{
          "d-inline-flex": inline,
          "d-flex": !inline,
          "border-0": noBorder,
          disabled,
          readonly: !disabled && readonly
        }, this.sizeFormClass],
        attrs: {
          id: this.safeId(),
          dir: isRTL ? "rtl" : "ltr",
          tabindex: disabled ? null : "0",
          disabled,
          role: "slider",
          "aria-disabled": disabled ? "true" : null,
          "aria-readonly": !disabled && readonly ? "true" : null,
          "aria-live": "off",
          "aria-valuemin": showClear ? "0" : "1",
          "aria-valuemax": toString(computedStars),
          "aria-valuenow": computedRating ? toString(computedRating) : null
        },
        on: {
          keydown: this.onKeydown,
          focus: this.onFocus,
          blur: this.onFocus
        }
      }, $content);
    }
  });
  var FormRatingPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormRating,
      BRating: BFormRating
    }
  });
  var _makeModelMixin$a = makeModelMixin("value"), mixin = _makeModelMixin$a.mixin, props$1h = _makeModelMixin$a.props, prop = _makeModelMixin$a.prop, event = _makeModelMixin$a.event;
  function ownKeys$S(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$S(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$S(Object(source), true).forEach(function(key) {
        _defineProperty$15(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$S(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$15(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1g = makePropsConfigurable(sortKeys(_objectSpread$S(_objectSpread$S({}, props$1D), {}, {
    labelField: makeProp(PROP_TYPE_STRING, "label"),
    optionsField: makeProp(PROP_TYPE_STRING, "options")
  })), "formOptions");
  var optionsMixin = extend({
    mixins: [formOptionsMixin],
    props: props$1g,
    methods: {
      normalizeOption: function normalizeOption(option) {
        var key = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        if (isPlainObject(option)) {
          var value = get(option, this.valueField);
          var text = get(option, this.textField);
          var options = get(option, this.optionsField, null);
          if (!isNull(options)) {
            return {
              label: String(get(option, this.labelField) || text),
              options: this.normalizeOptions(options)
            };
          }
          return {
            value: isUndefined(value) ? key || text : value,
            text: String(isUndefined(text) ? key : text),
            html: get(option, this.htmlField),
            disabled: Boolean(get(option, this.disabledField))
          };
        }
        return {
          value: key || option,
          text: String(option),
          disabled: false
        };
      }
    }
  });
  var props$1f = makePropsConfigurable({
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    value: makeProp(PROP_TYPE_ANY, void 0, true)
    // Required
  }, NAME_FORM_SELECT_OPTION);
  var BFormSelectOption = /* @__PURE__ */ extend({
    name: NAME_FORM_SELECT_OPTION,
    functional: true,
    props: props$1f,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var value = props2.value, disabled = props2.disabled;
      return h("option", a(data, {
        attrs: {
          disabled
        },
        domProps: {
          value
        }
      }), children);
    }
  });
  function ownKeys$R(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$R(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$R(Object(source), true).forEach(function(key) {
        _defineProperty$14(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$R(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$14(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1e = makePropsConfigurable(sortKeys(_objectSpread$R(_objectSpread$R({}, props$1D), {}, {
    label: makeProp(PROP_TYPE_STRING, void 0, true)
    // Required
  })), NAME_FORM_SELECT_OPTION_GROUP);
  var BFormSelectOptionGroup = /* @__PURE__ */ extend({
    name: NAME_FORM_SELECT_OPTION_GROUP,
    mixins: [normalizeSlotMixin, formOptionsMixin],
    props: props$1e,
    render: function render(h) {
      var label = this.label;
      var $options = this.formOptions.map(function(option, index) {
        var value = option.value, text = option.text, html = option.html, disabled = option.disabled;
        return h(BFormSelectOption, {
          attrs: {
            value,
            disabled
          },
          domProps: htmlOrText(html, text),
          key: "option_".concat(index)
        });
      });
      return h("optgroup", {
        attrs: {
          label
        }
      }, [this.normalizeSlot(SLOT_NAME_FIRST), $options, this.normalizeSlot()]);
    }
  });
  function ownKeys$Q(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$Q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Q(Object(source), true).forEach(function(key) {
        _defineProperty$13(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Q(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$13(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1d = makePropsConfigurable(sortKeys(_objectSpread$Q(_objectSpread$Q(_objectSpread$Q(_objectSpread$Q(_objectSpread$Q(_objectSpread$Q(_objectSpread$Q({}, props$25), props$1h), props$1x), props$1w), props$1v), props$1u), {}, {
    ariaInvalid: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    multiple: makeProp(PROP_TYPE_BOOLEAN, false),
    // Browsers default size to `0`, which shows 4 rows in most browsers in multiple mode
    // Size of `1` can bork out Firefox
    selectSize: makeProp(PROP_TYPE_NUMBER, 0)
  })), NAME_FORM_SELECT);
  var BFormSelect = /* @__PURE__ */ extend({
    name: NAME_FORM_SELECT,
    mixins: [idMixin, mixin, formControlMixin, formSizeMixin, formStateMixin, formCustomMixin, optionsMixin, normalizeSlotMixin],
    props: props$1d,
    data: function data() {
      return {
        localValue: this[prop]
      };
    },
    computed: {
      computedSelectSize: function computedSelectSize() {
        return !this.plain && this.selectSize === 0 ? null : this.selectSize;
      },
      inputClass: function inputClass() {
        return [this.plain ? "form-control" : "custom-select", this.size && this.plain ? "form-control-".concat(this.size) : null, this.size && !this.plain ? "custom-select-".concat(this.size) : null, this.stateClass];
      }
    },
    watch: {
      value: function value(newValue) {
        this.localValue = newValue;
      },
      localValue: function localValue() {
        this.$emit(event, this.localValue);
      }
    },
    methods: {
      focus: function focus() {
        attemptFocus(this.$refs.input);
      },
      blur: function blur() {
        attemptBlur(this.$refs.input);
      },
      onChange: function onChange(event2) {
        var _this = this;
        var target = event2.target;
        var selectedValue = from(target.options).filter(function(o) {
          return o.selected;
        }).map(function(o) {
          return "_value" in o ? o._value : o.value;
        });
        this.localValue = target.multiple ? selectedValue : selectedValue[0];
        this.$nextTick(function() {
          _this.$emit(EVENT_NAME_CHANGE, _this.localValue);
        });
      }
    },
    render: function render(h) {
      var name = this.name, disabled = this.disabled, required = this.required, size = this.computedSelectSize, value = this.localValue;
      var $options = this.formOptions.map(function(option, index) {
        var value2 = option.value, label = option.label, options = option.options, disabled2 = option.disabled;
        var key = "option_".concat(index);
        return isArray(options) ? h(BFormSelectOptionGroup, {
          props: {
            label,
            options
          },
          key
        }) : h(BFormSelectOption, {
          props: {
            value: value2,
            disabled: disabled2
          },
          domProps: htmlOrText(option.html, option.text),
          key
        });
      });
      return h("select", {
        class: this.inputClass,
        attrs: {
          id: this.safeId(),
          name,
          form: this.form || null,
          multiple: this.multiple || null,
          size,
          disabled,
          required,
          "aria-required": required ? "true" : null,
          "aria-invalid": this.computedAriaInvalid
        },
        on: {
          change: this.onChange
        },
        directives: [{
          name: "model",
          value
        }],
        ref: "input"
      }, [this.normalizeSlot(SLOT_NAME_FIRST), $options, this.normalizeSlot()]);
    }
  });
  var FormSelectPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormSelect,
      BFormSelectOption,
      BFormSelectOptionGroup,
      BSelect: BFormSelect,
      BSelectOption: BFormSelectOption,
      BSelectOptionGroup: BFormSelectOptionGroup
    }
  });
  var _watch$a;
  function ownKeys$P(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$P(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$P(Object(source), true).forEach(function(key) {
        _defineProperty$12(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$P(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$12(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$9 = makeModelMixin("value", {
    // Should this really be String, to match native number inputs?
    type: PROP_TYPE_BOOLEAN_NUMBER
  }), modelMixin$9 = _makeModelMixin$9.mixin, modelProps$9 = _makeModelMixin$9.props, MODEL_PROP_NAME$9 = _makeModelMixin$9.prop, MODEL_EVENT_NAME$9 = _makeModelMixin$9.event;
  var DEFAULT_MIN = 1;
  var DEFAULT_MAX = 100;
  var DEFAULT_STEP = 1;
  var DEFAULT_REPEAT_DELAY = 500;
  var DEFAULT_REPEAT_INTERVAL = 100;
  var DEFAULT_REPEAT_THRESHOLD = 10;
  var DEFAULT_REPEAT_MULTIPLIER = 4;
  var KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN];
  var props$1c = makePropsConfigurable(sortKeys(_objectSpread$P(_objectSpread$P(_objectSpread$P(_objectSpread$P(_objectSpread$P(_objectSpread$P({}, props$25), modelProps$9), omit(props$1x, ["required", "autofocus"])), props$1v), props$1u), {}, {
    ariaControls: makeProp(PROP_TYPE_STRING),
    ariaLabel: makeProp(PROP_TYPE_STRING),
    formatterFn: makeProp(PROP_TYPE_FUNCTION),
    inline: makeProp(PROP_TYPE_BOOLEAN, false),
    labelDecrement: makeProp(PROP_TYPE_STRING, "Decrement"),
    labelIncrement: makeProp(PROP_TYPE_STRING, "Increment"),
    locale: makeProp(PROP_TYPE_ARRAY_STRING),
    max: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_MAX),
    min: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_MIN),
    placeholder: makeProp(PROP_TYPE_STRING),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    repeatDelay: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_DELAY),
    repeatInterval: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_INTERVAL),
    repeatStepMultiplier: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_MULTIPLIER),
    repeatThreshold: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_REPEAT_THRESHOLD),
    step: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_STEP),
    vertical: makeProp(PROP_TYPE_BOOLEAN, false),
    wrap: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_FORM_SPINBUTTON);
  var BFormSpinbutton = /* @__PURE__ */ extend({
    name: NAME_FORM_SPINBUTTON,
    // Mixin order is important!
    mixins: [attrsMixin, idMixin, modelMixin$9, formSizeMixin, formStateMixin, normalizeSlotMixin],
    inheritAttrs: false,
    props: props$1c,
    data: function data() {
      return {
        localValue: toFloat(this[MODEL_PROP_NAME$9], null),
        hasFocus: false
      };
    },
    computed: {
      required: function required() {
        return false;
      },
      spinId: function spinId() {
        return this.safeId();
      },
      computedInline: function computedInline() {
        return this.inline && !this.vertical;
      },
      computedReadonly: function computedReadonly() {
        return this.readonly && !this.disabled;
      },
      computedRequired: function computedRequired() {
        return this.required && !this.computedReadonly && !this.disabled;
      },
      computedStep: function computedStep() {
        return toFloat(this.step, DEFAULT_STEP);
      },
      computedMin: function computedMin() {
        return toFloat(this.min, DEFAULT_MIN);
      },
      computedMax: function computedMax() {
        var max = toFloat(this.max, DEFAULT_MAX);
        var step = this.computedStep;
        var min = this.computedMin;
        return mathFloor((max - min) / step) * step + min;
      },
      computedDelay: function computedDelay() {
        var delay = toInteger(this.repeatDelay, 0);
        return delay > 0 ? delay : DEFAULT_REPEAT_DELAY;
      },
      computedInterval: function computedInterval() {
        var interval = toInteger(this.repeatInterval, 0);
        return interval > 0 ? interval : DEFAULT_REPEAT_INTERVAL;
      },
      computedThreshold: function computedThreshold() {
        return mathMax(toInteger(this.repeatThreshold, DEFAULT_REPEAT_THRESHOLD), 1);
      },
      computedStepMultiplier: function computedStepMultiplier() {
        return mathMax(toInteger(this.repeatStepMultiplier, DEFAULT_REPEAT_MULTIPLIER), 1);
      },
      computedPrecision: function computedPrecision() {
        var step = this.computedStep;
        return mathFloor(step) === step ? 0 : (step.toString().split(".")[1] || "").length;
      },
      computedMultiplier: function computedMultiplier() {
        return mathPow(10, this.computedPrecision || 0);
      },
      valueAsFixed: function valueAsFixed() {
        var value = this.localValue;
        return isNull(value) ? "" : value.toFixed(this.computedPrecision);
      },
      computedLocale: function computedLocale() {
        var locales = concat(this.locale).filter(identity);
        var nf = new Intl.NumberFormat(locales);
        return nf.resolvedOptions().locale;
      },
      computedRTL: function computedRTL() {
        return isLocaleRTL(this.computedLocale);
      },
      defaultFormatter: function defaultFormatter() {
        var precision = this.computedPrecision;
        var nf = new Intl.NumberFormat(this.computedLocale, {
          style: "decimal",
          useGrouping: false,
          minimumIntegerDigits: 1,
          minimumFractionDigits: precision,
          maximumFractionDigits: precision,
          notation: "standard"
        });
        return nf.format;
      },
      computedFormatter: function computedFormatter() {
        var formatterFn = this.formatterFn;
        return hasPropFunction(formatterFn) ? formatterFn : this.defaultFormatter;
      },
      computedAttrs: function computedAttrs() {
        return _objectSpread$P(_objectSpread$P({}, this.bvAttrs), {}, {
          role: "group",
          lang: this.computedLocale,
          tabindex: this.disabled ? null : "-1",
          title: this.ariaLabel
        });
      },
      computedSpinAttrs: function computedSpinAttrs() {
        var spinId = this.spinId, value = this.localValue, required = this.computedRequired, disabled = this.disabled, state = this.state, computedFormatter = this.computedFormatter;
        var hasValue = !isNull(value);
        return _objectSpread$P(_objectSpread$P({
          dir: this.computedRTL ? "rtl" : "ltr"
        }, this.bvAttrs), {}, {
          id: spinId,
          role: "spinbutton",
          tabindex: disabled ? null : "0",
          "aria-live": "off",
          "aria-label": this.ariaLabel || null,
          "aria-controls": this.ariaControls || null,
          // TODO: May want to check if the value is in range
          "aria-invalid": state === false || !hasValue && required ? "true" : null,
          "aria-required": required ? "true" : null,
          // These attrs are required for role spinbutton
          "aria-valuemin": toString(this.computedMin),
          "aria-valuemax": toString(this.computedMax),
          // These should be `null` if the value is out of range
          // They must also be non-existent attrs if the value is out of range or `null`
          "aria-valuenow": hasValue ? value : null,
          "aria-valuetext": hasValue ? computedFormatter(value) : null
        });
      }
    },
    watch: (_watch$a = {}, _defineProperty$12(_watch$a, MODEL_PROP_NAME$9, function(value) {
      this.localValue = toFloat(value, null);
    }), _defineProperty$12(_watch$a, "localValue", function localValue(value) {
      this.$emit(MODEL_EVENT_NAME$9, value);
    }), _defineProperty$12(_watch$a, "disabled", function disabled(_disabled) {
      if (_disabled) {
        this.clearRepeat();
      }
    }), _defineProperty$12(_watch$a, "readonly", function readonly(_readonly) {
      if (_readonly) {
        this.clearRepeat();
      }
    }), _watch$a),
    created: function created() {
      this.$_autoDelayTimer = null;
      this.$_autoRepeatTimer = null;
      this.$_keyIsDown = false;
    },
    beforeDestroy: function beforeDestroy() {
      this.clearRepeat();
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.clearRepeat();
    },
    methods: {
      // --- Public methods ---
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.spinner);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$refs.spinner);
        }
      },
      // --- Private methods ---
      emitChange: function emitChange() {
        this.$emit(EVENT_NAME_CHANGE, this.localValue);
      },
      stepValue: function stepValue(direction) {
        var value = this.localValue;
        if (!this.disabled && !isNull(value)) {
          var step = this.computedStep * direction;
          var min = this.computedMin;
          var max = this.computedMax;
          var multiplier = this.computedMultiplier;
          var wrap = this.wrap;
          value = mathRound((value - min) / step) * step + min + step;
          value = mathRound(value * multiplier) / multiplier;
          this.localValue = value > max ? wrap ? min : max : value < min ? wrap ? max : min : value;
        }
      },
      onFocusBlur: function onFocusBlur(event2) {
        this.hasFocus = this.disabled ? false : event2.type === "focus";
      },
      stepUp: function stepUp() {
        var multiplier = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var value = this.localValue;
        if (isNull(value)) {
          this.localValue = this.computedMin;
        } else {
          this.stepValue(1 * multiplier);
        }
      },
      stepDown: function stepDown() {
        var multiplier = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
        var value = this.localValue;
        if (isNull(value)) {
          this.localValue = this.wrap ? this.computedMax : this.computedMin;
        } else {
          this.stepValue(-1 * multiplier);
        }
      },
      onKeydown: function onKeydown(event2) {
        var keyCode = event2.keyCode, altKey = event2.altKey, ctrlKey = event2.ctrlKey, metaKey = event2.metaKey;
        if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {
          return;
        }
        if (arrayIncludes(KEY_CODES, keyCode)) {
          stopEvent(event2, {
            propagation: false
          });
          if (this.$_keyIsDown) {
            return;
          }
          this.resetTimers();
          if (arrayIncludes([CODE_UP, CODE_DOWN], keyCode)) {
            this.$_keyIsDown = true;
            if (keyCode === CODE_UP) {
              this.handleStepRepeat(event2, this.stepUp);
            } else if (keyCode === CODE_DOWN) {
              this.handleStepRepeat(event2, this.stepDown);
            }
          } else {
            if (keyCode === CODE_PAGEUP) {
              this.stepUp(this.computedStepMultiplier);
            } else if (keyCode === CODE_PAGEDOWN) {
              this.stepDown(this.computedStepMultiplier);
            } else if (keyCode === CODE_HOME) {
              this.localValue = this.computedMin;
            } else if (keyCode === CODE_END) {
              this.localValue = this.computedMax;
            }
          }
        }
      },
      onKeyup: function onKeyup(event2) {
        var keyCode = event2.keyCode, altKey = event2.altKey, ctrlKey = event2.ctrlKey, metaKey = event2.metaKey;
        if (this.disabled || this.readonly || altKey || ctrlKey || metaKey) {
          return;
        }
        if (arrayIncludes(KEY_CODES, keyCode)) {
          stopEvent(event2, {
            propagation: false
          });
          this.resetTimers();
          this.$_keyIsDown = false;
          this.emitChange();
        }
      },
      handleStepRepeat: function handleStepRepeat(event2, stepper) {
        var _this = this;
        var _ref = event2 || {}, type = _ref.type, button = _ref.button;
        if (!this.disabled && !this.readonly) {
          if (type === "mousedown" && button) {
            return;
          }
          this.resetTimers();
          stepper(1);
          var threshold = this.computedThreshold;
          var multiplier = this.computedStepMultiplier;
          var delay = this.computedDelay;
          var interval = this.computedInterval;
          this.$_autoDelayTimer = setTimeout(function() {
            var count = 0;
            _this.$_autoRepeatTimer = setInterval(function() {
              stepper(count < threshold ? 1 : multiplier);
              count++;
            }, interval);
          }, delay);
        }
      },
      onMouseup: function onMouseup(event2) {
        var _ref2 = event2 || {}, type = _ref2.type, button = _ref2.button;
        if (type === "mouseup" && button) {
          return;
        }
        stopEvent(event2, {
          propagation: false
        });
        this.resetTimers();
        this.setMouseup(false);
        this.emitChange();
      },
      setMouseup: function setMouseup(on) {
        try {
          eventOnOff(on, document.body, "mouseup", this.onMouseup, false);
          eventOnOff(on, document.body, "touchend", this.onMouseup, false);
        } catch (_unused) {
        }
      },
      resetTimers: function resetTimers() {
        clearTimeout(this.$_autoDelayTimer);
        clearInterval(this.$_autoRepeatTimer);
        this.$_autoDelayTimer = null;
        this.$_autoRepeatTimer = null;
      },
      clearRepeat: function clearRepeat() {
        this.resetTimers();
        this.setMouseup(false);
        this.$_keyIsDown = false;
      }
    },
    render: function render(h) {
      var _this2 = this;
      var spinId = this.spinId, value = this.localValue, inline = this.computedInline, readonly = this.computedReadonly, vertical = this.vertical, disabled = this.disabled, computedFormatter = this.computedFormatter;
      var hasValue = !isNull(value);
      var makeButton = function makeButton2(stepper, label, IconCmp, keyRef, shortcut, btnDisabled, slotName) {
        var $icon = h(IconCmp, {
          props: {
            scale: _this2.hasFocus ? 1.5 : 1.25
          },
          attrs: {
            "aria-hidden": "true"
          }
        });
        var scope = {
          hasFocus: _this2.hasFocus
        };
        var handler = function handler2(event2) {
          if (!disabled && !readonly) {
            stopEvent(event2, {
              propagation: false
            });
            _this2.setMouseup(true);
            attemptFocus(event2.currentTarget);
            _this2.handleStepRepeat(event2, stepper);
          }
        };
        return h("button", {
          staticClass: "btn btn-sm border-0 rounded-0",
          class: {
            "py-0": !vertical
          },
          attrs: {
            tabindex: "-1",
            type: "button",
            disabled: disabled || readonly || btnDisabled,
            "aria-disabled": disabled || readonly || btnDisabled ? "true" : null,
            "aria-controls": spinId,
            "aria-label": label || null,
            "aria-keyshortcuts": shortcut || null
          },
          on: {
            mousedown: handler,
            touchstart: handler
          },
          key: keyRef || null,
          ref: keyRef
        }, [_this2.normalizeSlot(slotName, scope) || $icon]);
      };
      var $increment = makeButton(this.stepUp, this.labelIncrement, BIconPlus, "inc", "ArrowUp", false, SLOT_NAME_INCREMENT);
      var $decrement = makeButton(this.stepDown, this.labelDecrement, BIconDash, "dec", "ArrowDown", false, SLOT_NAME_DECREMENT);
      var $hidden = h();
      if (this.name && !disabled) {
        $hidden = h("input", {
          attrs: {
            type: "hidden",
            name: this.name,
            form: this.form || null,
            // TODO: Should this be set to '' if value is out of range?
            value: this.valueAsFixed
          },
          key: "hidden"
        });
      }
      var $spin = h(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          staticClass: "flex-grow-1",
          class: {
            "d-flex": vertical,
            "align-self-center": !vertical,
            "align-items-center": vertical,
            "border-top": vertical,
            "border-bottom": vertical,
            "border-left": !vertical,
            "border-right": !vertical
          },
          attrs: this.computedSpinAttrs,
          key: "output",
          ref: "spinner"
        },
        [h("bdi", hasValue ? computedFormatter(value) : this.placeholder || "")]
      );
      return h("div", {
        staticClass: "b-form-spinbutton form-control",
        class: [{
          disabled,
          readonly,
          focus: this.hasFocus,
          "d-inline-flex": inline || vertical,
          "d-flex": !inline && !vertical,
          "align-items-stretch": !vertical,
          "flex-column": vertical
        }, this.sizeFormClass, this.stateClass],
        attrs: this.computedAttrs,
        on: {
          keydown: this.onKeydown,
          keyup: this.onKeyup,
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          "!focus": this.onFocusBlur,
          "!blur": this.onFocusBlur
        }
      }, vertical ? [$increment, $hidden, $spin, $decrement] : [$decrement, $hidden, $spin, $increment]);
    }
  });
  var FormSpinbuttonPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormSpinbutton,
      BSpinbutton: BFormSpinbutton
    }
  });
  function ownKeys$O(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$O(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$O(Object(source), true).forEach(function(key) {
        _defineProperty$11(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$O(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$11(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$1b = makePropsConfigurable(sortKeys(_objectSpread$O(_objectSpread$O({}, props$25), {}, {
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    noRemove: makeProp(PROP_TYPE_BOOLEAN, false),
    pill: makeProp(PROP_TYPE_BOOLEAN, false),
    removeLabel: makeProp(PROP_TYPE_STRING, "Remove tag"),
    tag: makeProp(PROP_TYPE_STRING, "span"),
    title: makeProp(PROP_TYPE_STRING),
    variant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_FORM_TAG);
  var BFormTag = /* @__PURE__ */ extend({
    name: NAME_FORM_TAG,
    mixins: [idMixin, normalizeSlotMixin],
    props: props$1b,
    methods: {
      onRemove: function onRemove(event2) {
        var type = event2.type, keyCode = event2.keyCode;
        if (!this.disabled && (type === "click" || type === "keydown" && keyCode === CODE_DELETE)) {
          this.$emit(EVENT_NAME_REMOVE);
        }
      }
    },
    render: function render(h) {
      var title = this.title, tag = this.tag, variant = this.variant, pill = this.pill, disabled = this.disabled;
      var tagId = this.safeId();
      var tagLabelId = this.safeId("_taglabel_");
      var $remove = h();
      if (!this.noRemove && !disabled) {
        $remove = h(BButtonClose, {
          staticClass: "b-form-tag-remove",
          props: {
            ariaLabel: this.removeLabel
          },
          attrs: {
            "aria-controls": tagId,
            "aria-describedby": tagLabelId,
            "aria-keyshortcuts": "Delete"
          },
          on: {
            click: this.onRemove,
            keydown: this.onRemove
          }
        });
      }
      var $tag = h("span", {
        staticClass: "b-form-tag-content flex-grow-1 text-truncate",
        attrs: {
          id: tagLabelId
        }
      }, this.normalizeSlot() || title);
      return h(BBadge, {
        staticClass: "b-form-tag d-inline-flex align-items-baseline mw-100",
        class: {
          disabled
        },
        props: {
          tag,
          variant,
          pill
        },
        attrs: {
          id: tagId,
          title: title || null,
          "aria-labelledby": tagLabelId
        }
      }, [$tag, $remove]);
    }
  });
  var _watch$9;
  function _toConsumableArray$7(arr) {
    return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$7(arr) || _nonIterableSpread$7();
  }
  function _nonIterableSpread$7() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$7(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$7(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen);
  }
  function _iterableToArray$7(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$7(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$7(arr);
  }
  function _arrayLikeToArray$7(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys$N(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$N(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$N(Object(source), true).forEach(function(key) {
        _defineProperty$10(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$N(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$10(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$8 = makeModelMixin("value", {
    type: PROP_TYPE_ARRAY,
    defaultValue: []
  }), modelMixin$8 = _makeModelMixin$8.mixin, modelProps$8 = _makeModelMixin$8.props, MODEL_PROP_NAME$8 = _makeModelMixin$8.prop, MODEL_EVENT_NAME$8 = _makeModelMixin$8.event;
  var TYPES = ["text", "email", "tel", "url", "number"];
  var DEFAULT_INPUT_FOCUS_SELECTOR = [".b-form-tag", "button", "input", "select"].join(" ");
  var escapeRegExpChars = function escapeRegExpChars2(str) {
    return escapeRegExp(str).replace(RX_SPACES, "\\s");
  };
  var cleanTags = function cleanTags2(tags) {
    return concat(tags).map(function(tag) {
      return trim(toString(tag));
    }).filter(function(tag, index, arr) {
      return tag.length > 0 && arr.indexOf(tag) === index;
    });
  };
  var processEventValue = function processEventValue2(event2) {
    return isString(event2) ? event2 : isEvent(event2) ? event2.target.value || "" : "";
  };
  var cleanTagsState = function cleanTagsState2() {
    return {
      all: [],
      valid: [],
      invalid: [],
      duplicate: []
    };
  };
  var props$1a = makePropsConfigurable(sortKeys(_objectSpread$N(_objectSpread$N(_objectSpread$N(_objectSpread$N(_objectSpread$N(_objectSpread$N({}, props$25), modelProps$8), props$1x), props$1v), props$1u), {}, {
    addButtonText: makeProp(PROP_TYPE_STRING, "Add"),
    addButtonVariant: makeProp(PROP_TYPE_STRING, "outline-secondary"),
    // Enable change event triggering tag addition
    // Handy if using <select> as the input
    addOnChange: makeProp(PROP_TYPE_BOOLEAN, false),
    duplicateTagText: makeProp(PROP_TYPE_STRING, "Duplicate tag(s)"),
    feedbackAriaLive: makeProp(PROP_TYPE_STRING, "assertive"),
    // Disable the input focus behavior when clicking
    // on element matching the selector (or selectors)
    ignoreInputFocusSelector: makeProp(PROP_TYPE_ARRAY_STRING, DEFAULT_INPUT_FOCUS_SELECTOR),
    // Additional attributes to add to the input element
    inputAttrs: makeProp(PROP_TYPE_OBJECT, {}),
    inputClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    inputId: makeProp(PROP_TYPE_STRING),
    inputType: makeProp(PROP_TYPE_STRING, "text", function(value) {
      return arrayIncludes(TYPES, value);
    }),
    invalidTagText: makeProp(PROP_TYPE_STRING, "Invalid tag(s)"),
    limit: makeProp(PROP_TYPE_NUMBER),
    limitTagsText: makeProp(PROP_TYPE_STRING, "Tag limit reached"),
    // Disable ENTER key from triggering tag addition
    noAddOnEnter: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable the focus ring on the root element
    noOuterFocus: makeProp(PROP_TYPE_BOOLEAN, false),
    noTagRemove: makeProp(PROP_TYPE_BOOLEAN, false),
    placeholder: makeProp(PROP_TYPE_STRING, "Add tag..."),
    // Enable deleting last tag in list when CODE_BACKSPACE is
    // pressed and input is empty
    removeOnDelete: makeProp(PROP_TYPE_BOOLEAN, false),
    // Character (or characters) that trigger adding tags
    separator: makeProp(PROP_TYPE_ARRAY_STRING),
    tagClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    tagPills: makeProp(PROP_TYPE_BOOLEAN, false),
    tagRemoveLabel: makeProp(PROP_TYPE_STRING, "Remove tag"),
    tagRemovedLabel: makeProp(PROP_TYPE_STRING, "Tag removed"),
    tagValidator: makeProp(PROP_TYPE_FUNCTION),
    tagVariant: makeProp(PROP_TYPE_STRING, "secondary")
  })), NAME_FORM_TAGS);
  var BFormTags = /* @__PURE__ */ extend({
    name: NAME_FORM_TAGS,
    mixins: [listenersMixin, idMixin, modelMixin$8, formControlMixin, formSizeMixin, formStateMixin, normalizeSlotMixin],
    props: props$1a,
    data: function data() {
      return {
        hasFocus: false,
        newTag: "",
        tags: [],
        // Tags that were removed
        removedTags: [],
        // Populated when tags are parsed
        tagsState: cleanTagsState(),
        focusState: null
      };
    },
    computed: {
      computedInputId: function computedInputId() {
        return this.inputId || this.safeId("__input__");
      },
      computedInputType: function computedInputType() {
        return arrayIncludes(TYPES, this.inputType) ? this.inputType : "text";
      },
      computedInputAttrs: function computedInputAttrs() {
        var disabled = this.disabled, form = this.form;
        return _objectSpread$N(_objectSpread$N({}, this.inputAttrs), {}, {
          // Must have attributes
          id: this.computedInputId,
          value: this.newTag,
          disabled,
          form
        });
      },
      computedInputHandlers: function computedInputHandlers() {
        return _objectSpread$N(_objectSpread$N({}, omit(this.bvListeners, [EVENT_NAME_FOCUSIN, EVENT_NAME_FOCUSOUT])), {}, {
          blur: this.onInputBlur,
          change: this.onInputChange,
          focus: this.onInputFocus,
          input: this.onInputInput,
          keydown: this.onInputKeydown,
          reset: this.reset
        });
      },
      computedSeparator: function computedSeparator() {
        return concat(this.separator).filter(isString).filter(identity).join("");
      },
      computedSeparatorRegExp: function computedSeparatorRegExp() {
        var separator = this.computedSeparator;
        return separator ? new RegExp("[".concat(escapeRegExpChars(separator), "]+")) : null;
      },
      computedJoiner: function computedJoiner() {
        var joiner = this.computedSeparator.charAt(0);
        return joiner !== " " ? "".concat(joiner, " ") : joiner;
      },
      computeIgnoreInputFocusSelector: function computeIgnoreInputFocusSelector() {
        return concat(this.ignoreInputFocusSelector).filter(identity).join(",").trim();
      },
      disableAddButton: function disableAddButton() {
        var _this = this;
        var newTag = trim(this.newTag);
        return newTag === "" || !this.splitTags(newTag).some(function(t2) {
          return !arrayIncludes(_this.tags, t2) && _this.validateTag(t2);
        });
      },
      duplicateTags: function duplicateTags() {
        return this.tagsState.duplicate;
      },
      hasDuplicateTags: function hasDuplicateTags() {
        return this.duplicateTags.length > 0;
      },
      invalidTags: function invalidTags() {
        return this.tagsState.invalid;
      },
      hasInvalidTags: function hasInvalidTags() {
        return this.invalidTags.length > 0;
      },
      isLimitReached: function isLimitReached() {
        var limit = this.limit;
        return isNumber(limit) && limit >= 0 && this.tags.length >= limit;
      }
    },
    watch: (_watch$9 = {}, _defineProperty$10(_watch$9, MODEL_PROP_NAME$8, function(newValue) {
      this.tags = cleanTags(newValue);
    }), _defineProperty$10(_watch$9, "tags", function tags(newValue, oldValue) {
      if (!looseEqual(newValue, this[MODEL_PROP_NAME$8])) {
        this.$emit(MODEL_EVENT_NAME$8, newValue);
      }
      if (!looseEqual(newValue, oldValue)) {
        newValue = concat(newValue).filter(identity);
        oldValue = concat(oldValue).filter(identity);
        this.removedTags = oldValue.filter(function(old) {
          return !arrayIncludes(newValue, old);
        });
      }
    }), _defineProperty$10(_watch$9, "tagsState", function tagsState(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.$emit(EVENT_NAME_TAG_STATE, newValue.valid, newValue.invalid, newValue.duplicate);
      }
    }), _watch$9),
    created: function created() {
      this.tags = cleanTags(this[MODEL_PROP_NAME$8]);
    },
    mounted: function mounted() {
      var $form = closest("form", this.$el);
      if ($form) {
        eventOn($form, "reset", this.reset, EVENT_OPTIONS_PASSIVE);
      }
    },
    beforeDestroy: function beforeDestroy() {
      var $form = closest("form", this.$el);
      if ($form) {
        eventOff($form, "reset", this.reset, EVENT_OPTIONS_PASSIVE);
      }
    },
    methods: {
      addTag: function addTag(newTag) {
        newTag = isString(newTag) ? newTag : this.newTag;
        if (this.disabled || trim(newTag) === "" || this.isLimitReached) {
          return;
        }
        var parsed = this.parseTags(newTag);
        if (parsed.valid.length > 0 || parsed.all.length === 0) {
          if (matches(this.getInput(), "select")) {
            this.newTag = "";
          } else {
            var invalidAndDuplicates = [].concat(_toConsumableArray$7(parsed.invalid), _toConsumableArray$7(parsed.duplicate));
            this.newTag = parsed.all.filter(function(tag) {
              return arrayIncludes(invalidAndDuplicates, tag);
            }).join(this.computedJoiner).concat(invalidAndDuplicates.length > 0 ? this.computedJoiner.charAt(0) : "");
          }
        }
        if (parsed.valid.length > 0) {
          this.tags = concat(this.tags, parsed.valid);
        }
        this.tagsState = parsed;
        this.focus();
      },
      removeTag: function removeTag(tag) {
        if (this.disabled) {
          return;
        }
        this.tags = this.tags.filter(function(t2) {
          return t2 !== tag;
        });
      },
      reset: function reset() {
        var _this2 = this;
        this.newTag = "";
        this.tags = [];
        this.$nextTick(function() {
          _this2.removedTags = [];
          _this2.tagsState = cleanTagsState();
        });
      },
      // --- Input element event handlers ---
      onInputInput: function onInputInput(event2) {
        if (this.disabled || isEvent(event2) && event2.target.composing) {
          return;
        }
        var newTag = processEventValue(event2);
        var separatorRe = this.computedSeparatorRegExp;
        if (this.newTag !== newTag) {
          this.newTag = newTag;
        }
        newTag = trimLeft(newTag);
        if (separatorRe && separatorRe.test(newTag.slice(-1))) {
          this.addTag();
        } else {
          this.tagsState = newTag === "" ? cleanTagsState() : this.parseTags(newTag);
        }
      },
      onInputChange: function onInputChange(event2) {
        if (!this.disabled && this.addOnChange) {
          var newTag = processEventValue(event2);
          if (this.newTag !== newTag) {
            this.newTag = newTag;
          }
          this.addTag();
        }
      },
      onInputKeydown: function onInputKeydown(event2) {
        if (this.disabled || !isEvent(event2)) {
          return;
        }
        var keyCode = event2.keyCode;
        var value = event2.target.value || "";
        if (!this.noAddOnEnter && keyCode === CODE_ENTER) {
          stopEvent(event2, {
            propagation: false
          });
          this.addTag();
        } else if (this.removeOnDelete && (keyCode === CODE_BACKSPACE || keyCode === CODE_DELETE) && value === "") {
          stopEvent(event2, {
            propagation: false
          });
          this.tags = this.tags.slice(0, -1);
        }
      },
      // --- Wrapper event handlers ---
      onClick: function onClick(event2) {
        var _this3 = this;
        var ignoreFocusSelector = this.computeIgnoreInputFocusSelector;
        if (!ignoreFocusSelector || !closest(ignoreFocusSelector, event2.target, true)) {
          this.$nextTick(function() {
            _this3.focus();
          });
        }
      },
      onInputFocus: function onInputFocus(event2) {
        var _this4 = this;
        if (this.focusState !== "out") {
          this.focusState = "in";
          this.$nextTick(function() {
            requestAF(function() {
              if (_this4.hasFocus) {
                _this4.$emit(EVENT_NAME_FOCUS, event2);
                _this4.focusState = null;
              }
            });
          });
        }
      },
      onInputBlur: function onInputBlur(event2) {
        var _this5 = this;
        if (this.focusState !== "in") {
          this.focusState = "out";
          this.$nextTick(function() {
            requestAF(function() {
              if (!_this5.hasFocus) {
                _this5.$emit(EVENT_NAME_BLUR, event2);
                _this5.focusState = null;
              }
            });
          });
        }
      },
      onFocusin: function onFocusin(event2) {
        this.hasFocus = true;
        this.$emit(EVENT_NAME_FOCUSIN, event2);
      },
      onFocusout: function onFocusout(event2) {
        this.hasFocus = false;
        this.$emit(EVENT_NAME_FOCUSOUT, event2);
      },
      handleAutofocus: function handleAutofocus() {
        var _this6 = this;
        this.$nextTick(function() {
          requestAF(function() {
            if (_this6.autofocus) {
              _this6.focus();
            }
          });
        });
      },
      // --- Public methods ---
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.getInput());
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.getInput());
        }
      },
      // --- Private methods ---
      splitTags: function splitTags(newTag) {
        newTag = toString(newTag);
        var separatorRe = this.computedSeparatorRegExp;
        return (separatorRe ? newTag.split(separatorRe) : [newTag]).map(trim).filter(identity);
      },
      parseTags: function parseTags(newTag) {
        var _this7 = this;
        var tags = this.splitTags(newTag);
        var parsed = {
          all: tags,
          valid: [],
          invalid: [],
          duplicate: []
        };
        tags.forEach(function(tag) {
          if (arrayIncludes(_this7.tags, tag) || arrayIncludes(parsed.valid, tag)) {
            if (!arrayIncludes(parsed.duplicate, tag)) {
              parsed.duplicate.push(tag);
            }
          } else if (_this7.validateTag(tag)) {
            parsed.valid.push(tag);
          } else {
            if (!arrayIncludes(parsed.invalid, tag)) {
              parsed.invalid.push(tag);
            }
          }
        });
        return parsed;
      },
      validateTag: function validateTag(tag) {
        var tagValidator = this.tagValidator;
        return hasPropFunction(tagValidator) ? tagValidator(tag) : true;
      },
      getInput: function getInput() {
        return select("#".concat(cssEscape(this.computedInputId)), this.$el);
      },
      // Default User Interface render
      defaultRender: function defaultRender(_ref) {
        var addButtonText = _ref.addButtonText, addButtonVariant = _ref.addButtonVariant, addTag = _ref.addTag, disableAddButton = _ref.disableAddButton, disabled = _ref.disabled, duplicateTagText = _ref.duplicateTagText, inputAttrs = _ref.inputAttrs, inputClass = _ref.inputClass, inputHandlers = _ref.inputHandlers, inputType = _ref.inputType, invalidTagText = _ref.invalidTagText, isDuplicate = _ref.isDuplicate, isInvalid = _ref.isInvalid, isLimitReached = _ref.isLimitReached, limitTagsText = _ref.limitTagsText, noTagRemove = _ref.noTagRemove, placeholder = _ref.placeholder, removeTag = _ref.removeTag, tagClass = _ref.tagClass, tagPills = _ref.tagPills, tagRemoveLabel = _ref.tagRemoveLabel, tagVariant = _ref.tagVariant, tags = _ref.tags;
        var h = this.$createElement;
        var $tags = tags.map(function(tag) {
          tag = toString(tag);
          return h(BFormTag, {
            class: tagClass,
            // `BFormTag` will auto generate an ID
            // so we do not need to set the ID prop
            props: {
              disabled,
              noRemove: noTagRemove,
              pill: tagPills,
              removeLabel: tagRemoveLabel,
              tag: "li",
              title: tag,
              variant: tagVariant
            },
            on: {
              remove: function remove() {
                return removeTag(tag);
              }
            },
            key: "tags_".concat(tag)
          }, tag);
        });
        var invalidFeedbackId = invalidTagText && isInvalid ? this.safeId("__invalid_feedback__") : null;
        var duplicateFeedbackId = duplicateTagText && isDuplicate ? this.safeId("__duplicate_feedback__") : null;
        var limitFeedbackId = limitTagsText && isLimitReached ? this.safeId("__limit_feedback__") : null;
        var ariaDescribedby = [inputAttrs["aria-describedby"], invalidFeedbackId, duplicateFeedbackId, limitFeedbackId].filter(identity).join(" ");
        var $input = h("input", {
          staticClass: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
          class: inputClass,
          style: {
            outline: 0,
            minWidth: "5rem"
          },
          attrs: _objectSpread$N(_objectSpread$N({}, inputAttrs), {}, {
            "aria-describedby": ariaDescribedby || null,
            type: inputType,
            placeholder: placeholder || null
          }),
          domProps: {
            value: inputAttrs.value
          },
          on: inputHandlers,
          // Directive needed to get `event.target.composing` set (if needed)
          directives: [{
            name: "model",
            value: inputAttrs.value
          }],
          ref: "input"
        });
        var $button = h(BButton, {
          staticClass: "b-form-tags-button py-0",
          class: {
            // Only show the button if the tag can be added
            // We use the `invisible` class instead of not rendering
            // the button, so that we maintain layout to prevent
            // the user input from jumping around
            invisible: disableAddButton
          },
          style: {
            fontSize: "90%"
          },
          props: {
            disabled: disableAddButton || isLimitReached,
            variant: addButtonVariant
          },
          on: {
            click: function click() {
              return addTag();
            }
          },
          ref: "button"
        }, [this.normalizeSlot(SLOT_NAME_ADD_BUTTON_TEXT) || addButtonText]);
        var tagListId = this.safeId("__tag_list__");
        var $field = h("li", {
          staticClass: "b-form-tags-field flex-grow-1",
          attrs: {
            role: "none",
            "aria-live": "off",
            "aria-controls": tagListId
          },
          key: "tags_field"
        }, [h("div", {
          staticClass: "d-flex",
          attrs: {
            role: "group"
          }
        }, [$input, $button])]);
        var $ul = h("ul", {
          staticClass: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center",
          attrs: {
            id: tagListId
          },
          key: "tags_list"
        }, [$tags, $field]);
        var $feedback = h();
        if (invalidTagText || duplicateTagText || limitTagsText) {
          var ariaLive = this.feedbackAriaLive, joiner = this.computedJoiner;
          var $invalid = h();
          if (invalidFeedbackId) {
            $invalid = h(BFormInvalidFeedback, {
              props: {
                id: invalidFeedbackId,
                ariaLive,
                forceShow: true
              },
              key: "tags_invalid_feedback"
            }, [this.invalidTagText, ": ", this.invalidTags.join(joiner)]);
          }
          var $duplicate = h();
          if (duplicateFeedbackId) {
            $duplicate = h(BFormText, {
              props: {
                id: duplicateFeedbackId,
                ariaLive
              },
              key: "tags_duplicate_feedback"
            }, [this.duplicateTagText, ": ", this.duplicateTags.join(joiner)]);
          }
          var $limit = h();
          if (limitFeedbackId) {
            $limit = h(BFormText, {
              props: {
                id: limitFeedbackId,
                ariaLive
              },
              key: "tags_limit_feedback"
            }, [limitTagsText]);
          }
          $feedback = h("div", {
            attrs: {
              "aria-live": "polite",
              "aria-atomic": "true"
            },
            key: "tags_feedback"
          }, [$invalid, $duplicate, $limit]);
        }
        return [$ul, $feedback];
      }
    },
    render: function render(h) {
      var name = this.name, disabled = this.disabled, required = this.required, form = this.form, tags = this.tags, computedInputId = this.computedInputId, hasFocus = this.hasFocus, noOuterFocus = this.noOuterFocus;
      var scope = _objectSpread$N({
        // Array of tags (shallow copy to prevent mutations)
        tags: tags.slice(),
        // <input> v-bind:inputAttrs
        inputAttrs: this.computedInputAttrs,
        // We don't include this in the attrs, as users may want to override this
        inputType: this.computedInputType,
        // <input> v-on:inputHandlers
        inputHandlers: this.computedInputHandlers,
        // Methods
        removeTag: this.removeTag,
        addTag: this.addTag,
        reset: this.reset,
        // <input> :id="inputId"
        inputId: computedInputId,
        // Invalid/Duplicate state information
        isInvalid: this.hasInvalidTags,
        invalidTags: this.invalidTags.slice(),
        isDuplicate: this.hasDuplicateTags,
        duplicateTags: this.duplicateTags.slice(),
        isLimitReached: this.isLimitReached,
        // If the 'Add' button should be disabled
        disableAddButton: this.disableAddButton
      }, pick$1(this.$props, ["addButtonText", "addButtonVariant", "disabled", "duplicateTagText", "form", "inputClass", "invalidTagText", "limit", "limitTagsText", "noTagRemove", "placeholder", "required", "separator", "size", "state", "tagClass", "tagPills", "tagRemoveLabel", "tagVariant"]));
      var $content = this.normalizeSlot(SLOT_NAME_DEFAULT, scope) || this.defaultRender(scope);
      var $output = h("output", {
        staticClass: "sr-only",
        attrs: {
          id: this.safeId("__selected_tags__"),
          role: "status",
          for: computedInputId,
          "aria-live": hasFocus ? "polite" : "off",
          "aria-atomic": "true",
          "aria-relevant": "additions text"
        }
      }, this.tags.join(", "));
      var $removed = h("div", {
        staticClass: "sr-only",
        attrs: {
          id: this.safeId("__removed_tags__"),
          role: "status",
          "aria-live": hasFocus ? "assertive" : "off",
          "aria-atomic": "true"
        }
      }, this.removedTags.length > 0 ? "(".concat(this.tagRemovedLabel, ") ").concat(this.removedTags.join(", ")) : "");
      var $hidden = h();
      if (name && !disabled) {
        var hasTags = tags.length > 0;
        $hidden = (hasTags ? tags : [""]).map(function(tag) {
          return h("input", {
            class: {
              "sr-only": !hasTags
            },
            attrs: {
              type: hasTags ? "hidden" : "text",
              value: tag,
              required,
              name,
              form
            },
            key: "tag_input_".concat(tag)
          });
        });
      }
      return h("div", {
        staticClass: "b-form-tags form-control h-auto",
        class: [{
          focus: hasFocus && !noOuterFocus && !disabled,
          disabled
        }, this.sizeFormClass, this.stateClass],
        attrs: {
          id: this.safeId(),
          role: "group",
          tabindex: disabled || noOuterFocus ? null : "-1",
          "aria-describedby": this.safeId("__selected_tags__")
        },
        on: {
          click: this.onClick,
          focusin: this.onFocusin,
          focusout: this.onFocusout
        }
      }, [$output, $removed, $content, $hidden]);
    }
  });
  var FormTagsPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormTags,
      BTags: BFormTags,
      BFormTag,
      BTag: BFormTag
    }
  });
  function ownKeys$M(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$M(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$M(Object(source), true).forEach(function(key) {
        _defineProperty$$(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$M(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$$(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$19 = makePropsConfigurable(sortKeys(_objectSpread$M(_objectSpread$M(_objectSpread$M(_objectSpread$M(_objectSpread$M(_objectSpread$M({}, props$25), props$1x), props$1v), props$1u), props$1l), {}, {
    maxRows: makeProp(PROP_TYPE_NUMBER_STRING),
    // When in auto resize mode, disable shrinking to content height
    noAutoShrink: makeProp(PROP_TYPE_BOOLEAN, false),
    // Disable the resize handle of textarea
    noResize: makeProp(PROP_TYPE_BOOLEAN, false),
    rows: makeProp(PROP_TYPE_NUMBER_STRING, 2),
    // 'soft', 'hard' or 'off'
    // Browser default is 'soft'
    wrap: makeProp(PROP_TYPE_STRING, "soft")
  })), NAME_FORM_TEXTAREA);
  var BFormTextarea = /* @__PURE__ */ extend({
    name: NAME_FORM_TEXTAREA,
    directives: {
      "b-visible": VBVisible
    },
    // Mixin order is important!
    mixins: [listenersMixin, idMixin, listenOnRootMixin, formControlMixin, formSizeMixin, formStateMixin, formTextMixin, formSelectionMixin, formValidityMixin],
    props: props$19,
    data: function data() {
      return {
        heightInPx: null
      };
    },
    computed: {
      type: function type() {
        return null;
      },
      computedStyle: function computedStyle() {
        var styles = {
          // Setting `noResize` to true will disable the ability for the user to
          // manually resize the textarea. We also disable when in auto height mode
          resize: !this.computedRows || this.noResize ? "none" : null
        };
        if (!this.computedRows) {
          styles.height = this.heightInPx;
          styles.overflowY = "scroll";
        }
        return styles;
      },
      computedMinRows: function computedMinRows() {
        return mathMax(toInteger(this.rows, 2), 2);
      },
      computedMaxRows: function computedMaxRows() {
        return mathMax(this.computedMinRows, toInteger(this.maxRows, 0));
      },
      computedRows: function computedRows() {
        return this.computedMinRows === this.computedMaxRows ? this.computedMinRows : null;
      },
      computedAttrs: function computedAttrs() {
        var disabled = this.disabled, required = this.required;
        return {
          id: this.safeId(),
          name: this.name || null,
          form: this.form || null,
          disabled,
          placeholder: this.placeholder || null,
          required,
          autocomplete: this.autocomplete || null,
          readonly: this.readonly || this.plaintext,
          rows: this.computedRows,
          wrap: this.wrap || null,
          "aria-required": this.required ? "true" : null,
          "aria-invalid": this.computedAriaInvalid
        };
      },
      computedListeners: function computedListeners() {
        return _objectSpread$M(_objectSpread$M({}, this.bvListeners), {}, {
          input: this.onInput,
          change: this.onChange,
          blur: this.onBlur
        });
      }
    },
    watch: {
      localValue: function localValue() {
        this.setHeight();
      }
    },
    mounted: function mounted() {
      this.setHeight();
    },
    methods: {
      // Called by intersection observer directive
      /* istanbul ignore next */
      visibleCallback: function visibleCallback(visible) {
        if (visible) {
          this.$nextTick(this.setHeight);
        }
      },
      setHeight: function setHeight() {
        var _this = this;
        this.$nextTick(function() {
          requestAF(function() {
            _this.heightInPx = _this.computeHeight();
          });
        });
      },
      /* istanbul ignore next: can't test getComputedStyle in JSDOM */
      computeHeight: function computeHeight() {
        if (this.$isServer || !isNull(this.computedRows)) {
          return null;
        }
        var el = this.$el;
        if (!isVisible(el)) {
          return null;
        }
        var computedStyle = getCS(el);
        var lineHeight = toFloat(computedStyle.lineHeight, 1);
        var border = toFloat(computedStyle.borderTopWidth, 0) + toFloat(computedStyle.borderBottomWidth, 0);
        var padding = toFloat(computedStyle.paddingTop, 0) + toFloat(computedStyle.paddingBottom, 0);
        var offset2 = border + padding;
        var minHeight = lineHeight * this.computedMinRows + offset2;
        var oldHeight = getStyle(el, "height") || computedStyle.height;
        setStyle(el, "height", "auto");
        var scrollHeight = el.scrollHeight;
        setStyle(el, "height", oldHeight);
        var contentRows = mathMax((scrollHeight - padding) / lineHeight, 2);
        var rows = mathMin(mathMax(contentRows, this.computedMinRows), this.computedMaxRows);
        var height = mathMax(mathCeil(rows * lineHeight + offset2), minHeight);
        if (this.noAutoShrink && toFloat(oldHeight, 0) > height) {
          return oldHeight;
        }
        return "".concat(height, "px");
      }
    },
    render: function render(h) {
      return h("textarea", {
        class: this.computedClass,
        style: this.computedStyle,
        directives: [{
          name: "b-visible",
          value: this.visibleCallback,
          // If textarea is within 640px of viewport, consider it visible
          modifiers: {
            "640": true
          }
        }],
        attrs: this.computedAttrs,
        domProps: {
          value: this.localValue
        },
        on: this.computedListeners,
        ref: "input"
      });
    }
  });
  var FormTextareaPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormTextarea,
      BTextarea: BFormTextarea
    }
  });
  var _watch$8;
  function ownKeys$L(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$L(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$L(Object(source), true).forEach(function(key) {
        _defineProperty$_(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$L(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$_(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$6(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$6(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$6(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen);
  }
  function _arrayLikeToArray$6(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  var _makeModelMixin$7 = makeModelMixin("value", {
    type: PROP_TYPE_STRING,
    defaultValue: ""
  }), modelMixin$7 = _makeModelMixin$7.mixin, modelProps$7 = _makeModelMixin$7.props, MODEL_PROP_NAME$7 = _makeModelMixin$7.prop, MODEL_EVENT_NAME$7 = _makeModelMixin$7.event;
  var NUMERIC = "numeric";
  var padLeftZeros = function padLeftZeros2(value) {
    return "00".concat(value || "").slice(-2);
  };
  var parseHMS = function parseHMS2(value) {
    value = toString(value);
    var hh = null, mm = null, ss = null;
    if (RX_TIME.test(value)) {
      var _value$split$map = value.split(":").map(function(v) {
        return toInteger(v, null);
      });
      var _value$split$map2 = _slicedToArray(_value$split$map, 3);
      hh = _value$split$map2[0];
      mm = _value$split$map2[1];
      ss = _value$split$map2[2];
    }
    return {
      hours: isUndefinedOrNull(hh) ? null : hh,
      minutes: isUndefinedOrNull(mm) ? null : mm,
      seconds: isUndefinedOrNull(ss) ? null : ss,
      ampm: isUndefinedOrNull(hh) || hh < 12 ? 0 : 1
    };
  };
  var formatHMS = function formatHMS2(_ref) {
    var hours = _ref.hours, minutes = _ref.minutes, seconds = _ref.seconds;
    var requireSeconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (isNull(hours) || isNull(minutes) || requireSeconds && isNull(seconds)) {
      return "";
    }
    var hms = [hours, minutes, requireSeconds ? seconds : 0];
    return hms.map(padLeftZeros).join(":");
  };
  var props$18 = makePropsConfigurable(sortKeys(_objectSpread$L(_objectSpread$L(_objectSpread$L(_objectSpread$L({}, props$25), modelProps$7), pick$1(props$1c, ["labelIncrement", "labelDecrement"])), {}, {
    // ID of label element
    ariaLabelledby: makeProp(PROP_TYPE_STRING),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    footerTag: makeProp(PROP_TYPE_STRING, "footer"),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    hidden: makeProp(PROP_TYPE_BOOLEAN, false),
    hideHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    // Explicitly force 12 or 24 hour time
    // Default is to use resolved locale for 12/24 hour display
    // Tri-state: `true` = 12, `false` = 24, `null` = auto
    hour12: makeProp(PROP_TYPE_BOOLEAN, null),
    labelAm: makeProp(PROP_TYPE_STRING, "AM"),
    labelAmpm: makeProp(PROP_TYPE_STRING, "AM/PM"),
    labelHours: makeProp(PROP_TYPE_STRING, "Hours"),
    labelMinutes: makeProp(PROP_TYPE_STRING, "Minutes"),
    labelNoTimeSelected: makeProp(PROP_TYPE_STRING, "No time selected"),
    labelPm: makeProp(PROP_TYPE_STRING, "PM"),
    labelSeconds: makeProp(PROP_TYPE_STRING, "Seconds"),
    labelSelected: makeProp(PROP_TYPE_STRING, "Selected time"),
    locale: makeProp(PROP_TYPE_ARRAY_STRING),
    minutesStep: makeProp(PROP_TYPE_NUMBER_STRING, 1),
    readonly: makeProp(PROP_TYPE_BOOLEAN, false),
    secondsStep: makeProp(PROP_TYPE_NUMBER_STRING, 1),
    // If `true`, show the second spinbutton
    showSeconds: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_TIME);
  var BTime = /* @__PURE__ */ extend({
    name: NAME_TIME,
    mixins: [idMixin, modelMixin$7, normalizeSlotMixin],
    props: props$18,
    data: function data() {
      var parsed = parseHMS(this[MODEL_PROP_NAME$7] || "");
      return {
        // Spin button models
        modelHours: parsed.hours,
        modelMinutes: parsed.minutes,
        modelSeconds: parsed.seconds,
        modelAmpm: parsed.ampm,
        // Internal flag to enable aria-live regions
        isLive: false
      };
    },
    computed: {
      computedHMS: function computedHMS() {
        var hours = this.modelHours;
        var minutes = this.modelMinutes;
        var seconds = this.modelSeconds;
        return formatHMS({
          hours,
          minutes,
          seconds
        }, this.showSeconds);
      },
      resolvedOptions: function resolvedOptions() {
        var locale = concat(this.locale).filter(identity);
        var options = {
          hour: NUMERIC,
          minute: NUMERIC,
          second: NUMERIC
        };
        if (!isUndefinedOrNull(this.hour12)) {
          options.hour12 = !!this.hour12;
        }
        var dtf = new Intl.DateTimeFormat(locale, options);
        var resolved = dtf.resolvedOptions();
        var hour12 = resolved.hour12 || false;
        var hourCycle = resolved.hourCycle || (hour12 ? "h12" : "h23");
        return {
          locale: resolved.locale,
          hour12,
          hourCycle
        };
      },
      computedLocale: function computedLocale() {
        return this.resolvedOptions.locale;
      },
      computedLang: function computedLang() {
        return (this.computedLocale || "").replace(/-u-.*$/, "");
      },
      computedRTL: function computedRTL() {
        return isLocaleRTL(this.computedLang);
      },
      computedHourCycle: function computedHourCycle() {
        return this.resolvedOptions.hourCycle;
      },
      is12Hour: function is12Hour() {
        return !!this.resolvedOptions.hour12;
      },
      context: function context() {
        return {
          locale: this.computedLocale,
          isRTL: this.computedRTL,
          hourCycle: this.computedHourCycle,
          hour12: this.is12Hour,
          hours: this.modelHours,
          minutes: this.modelMinutes,
          seconds: this.showSeconds ? this.modelSeconds : 0,
          value: this.computedHMS,
          formatted: this.formattedTimeString
        };
      },
      valueId: function valueId() {
        return this.safeId() || null;
      },
      computedAriaLabelledby: function computedAriaLabelledby() {
        return [this.ariaLabelledby, this.valueId].filter(identity).join(" ") || null;
      },
      timeFormatter: function timeFormatter() {
        var options = {
          hour12: this.is12Hour,
          hourCycle: this.computedHourCycle,
          hour: NUMERIC,
          minute: NUMERIC,
          timeZone: "UTC"
        };
        if (this.showSeconds) {
          options.second = NUMERIC;
        }
        return createDateFormatter(this.computedLocale, options);
      },
      numberFormatter: function numberFormatter() {
        var nf = new Intl.NumberFormat(this.computedLocale, {
          style: "decimal",
          minimumIntegerDigits: 2,
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
          notation: "standard"
        });
        return nf.format;
      },
      formattedTimeString: function formattedTimeString() {
        var hours = this.modelHours;
        var minutes = this.modelMinutes;
        var seconds = this.showSeconds ? this.modelSeconds || 0 : 0;
        if (this.computedHMS) {
          return this.timeFormatter(createDate(Date.UTC(0, 0, 1, hours, minutes, seconds)));
        }
        return this.labelNoTimeSelected || " ";
      },
      spinScopedSlots: function spinScopedSlots() {
        var h = this.$createElement;
        return {
          increment: function increment(_ref2) {
            var hasFocus = _ref2.hasFocus;
            return h(BIconChevronUp, {
              props: {
                scale: hasFocus ? 1.5 : 1.25
              },
              attrs: {
                "aria-hidden": "true"
              }
            });
          },
          decrement: function decrement(_ref3) {
            var hasFocus = _ref3.hasFocus;
            return h(BIconChevronUp, {
              props: {
                flipV: true,
                scale: hasFocus ? 1.5 : 1.25
              },
              attrs: {
                "aria-hidden": "true"
              }
            });
          }
        };
      }
    },
    watch: (_watch$8 = {}, _defineProperty$_(_watch$8, MODEL_PROP_NAME$7, function(newValue, oldValue) {
      if (newValue !== oldValue && !looseEqual(parseHMS(newValue), parseHMS(this.computedHMS))) {
        var _parseHMS = parseHMS(newValue), hours = _parseHMS.hours, minutes = _parseHMS.minutes, seconds = _parseHMS.seconds, ampm = _parseHMS.ampm;
        this.modelHours = hours;
        this.modelMinutes = minutes;
        this.modelSeconds = seconds;
        this.modelAmpm = ampm;
      }
    }), _defineProperty$_(_watch$8, "computedHMS", function computedHMS(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit(MODEL_EVENT_NAME$7, newValue);
      }
    }), _defineProperty$_(_watch$8, "context", function context(newValue, oldValue) {
      if (!looseEqual(newValue, oldValue)) {
        this.$emit(EVENT_NAME_CONTEXT, newValue);
      }
    }), _defineProperty$_(_watch$8, "modelAmpm", function modelAmpm(newValue, oldValue) {
      var _this = this;
      if (newValue !== oldValue) {
        var hours = isNull(this.modelHours) ? 0 : this.modelHours;
        this.$nextTick(function() {
          if (newValue === 0 && hours > 11) {
            _this.modelHours = hours - 12;
          } else if (newValue === 1 && hours < 12) {
            _this.modelHours = hours + 12;
          }
        });
      }
    }), _defineProperty$_(_watch$8, "modelHours", function modelHours(newHours, oldHours) {
      if (newHours !== oldHours) {
        this.modelAmpm = newHours > 11 ? 1 : 0;
      }
    }), _watch$8),
    created: function created() {
      var _this2 = this;
      this.$nextTick(function() {
        _this2.$emit(EVENT_NAME_CONTEXT, _this2.context);
      });
    },
    mounted: function mounted() {
      this.setLive(true);
    },
    /* istanbul ignore next */
    activated: function activated() {
      this.setLive(true);
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.setLive(false);
    },
    beforeDestroy: function beforeDestroy() {
      this.setLive(false);
    },
    methods: {
      // Public methods
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.spinners[0]);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          var activeElement = getActiveElement();
          if (contains(this.$el, activeElement)) {
            attemptBlur(activeElement);
          }
        }
      },
      // Formatters for the spin buttons
      formatHours: function formatHours(hh) {
        var hourCycle = this.computedHourCycle;
        hh = this.is12Hour && hh > 12 ? hh - 12 : hh;
        hh = hh === 0 && hourCycle === "h12" ? 12 : hh === 0 && hourCycle === "h24" ? (
          /* istanbul ignore next */
          24
        ) : hh === 12 && hourCycle === "h11" ? (
          /* istanbul ignore next */
          0
        ) : hh;
        return this.numberFormatter(hh);
      },
      formatMinutes: function formatMinutes(mm) {
        return this.numberFormatter(mm);
      },
      formatSeconds: function formatSeconds(ss) {
        return this.numberFormatter(ss);
      },
      formatAmpm: function formatAmpm(ampm) {
        return ampm === 0 ? this.labelAm : ampm === 1 ? this.labelPm : "";
      },
      // Spinbutton on change handlers
      setHours: function setHours(value) {
        this.modelHours = value;
      },
      setMinutes: function setMinutes(value) {
        this.modelMinutes = value;
      },
      setSeconds: function setSeconds(value) {
        this.modelSeconds = value;
      },
      setAmpm: function setAmpm(value) {
        this.modelAmpm = value;
      },
      onSpinLeftRight: function onSpinLeftRight() {
        var event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var type = event2.type, keyCode = event2.keyCode;
        if (!this.disabled && type === "keydown" && (keyCode === CODE_LEFT || keyCode === CODE_RIGHT)) {
          stopEvent(event2);
          var spinners = this.$refs.spinners || [];
          var index = spinners.map(function(cmp) {
            return !!cmp.hasFocus;
          }).indexOf(true);
          index = index + (keyCode === CODE_LEFT ? -1 : 1);
          index = index >= spinners.length ? 0 : index < 0 ? spinners.length - 1 : index;
          attemptFocus(spinners[index]);
        }
      },
      setLive: function setLive(on) {
        var _this3 = this;
        if (on) {
          this.$nextTick(function() {
            requestAF(function() {
              _this3.isLive = true;
            });
          });
        } else {
          this.isLive = false;
        }
      }
    },
    render: function render(h) {
      var _this4 = this;
      if (this.hidden) {
        return h();
      }
      var disabled = this.disabled, readonly = this.readonly, locale = this.computedLocale, ariaLabelledby = this.computedAriaLabelledby, labelIncrement = this.labelIncrement, labelDecrement = this.labelDecrement, valueId = this.valueId, focusHandler = this.focus;
      var spinIds = [];
      var makeSpinbutton = function makeSpinbutton2(handler, key, classes) {
        var spinbuttonProps = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
        var id = _this4.safeId("_spinbutton_".concat(key, "_")) || null;
        spinIds.push(id);
        return h(BFormSpinbutton, _defineProperty$_({
          class: classes,
          props: _objectSpread$L({
            id,
            placeholder: "--",
            vertical: true,
            required: true,
            disabled,
            readonly,
            locale,
            labelIncrement,
            labelDecrement,
            wrap: true,
            ariaControls: valueId,
            min: 0
          }, spinbuttonProps),
          scopedSlots: _this4.spinScopedSlots,
          on: {
            // We use `change` event to minimize SR verbosity
            // As the spinbutton will announce each value change
            // and we don't want the formatted time to be announced
            // on each value input if repeat is happening
            change: handler
          },
          key,
          ref: "spinners"
        }, REF_FOR_KEY, true));
      };
      var makeColon = function makeColon2() {
        return h("div", {
          staticClass: "d-flex flex-column",
          class: {
            "text-muted": disabled || readonly
          },
          attrs: {
            "aria-hidden": "true"
          }
        }, [h(BIconCircleFill, {
          props: {
            shiftV: 4,
            scale: 0.5
          }
        }), h(BIconCircleFill, {
          props: {
            shiftV: -4,
            scale: 0.5
          }
        })]);
      };
      var $spinners = [];
      $spinners.push(makeSpinbutton(this.setHours, "hours", "b-time-hours", {
        value: this.modelHours,
        max: 23,
        step: 1,
        formatterFn: this.formatHours,
        ariaLabel: this.labelHours
      }));
      $spinners.push(makeColon());
      $spinners.push(makeSpinbutton(this.setMinutes, "minutes", "b-time-minutes", {
        value: this.modelMinutes,
        max: 59,
        step: this.minutesStep || 1,
        formatterFn: this.formatMinutes,
        ariaLabel: this.labelMinutes
      }));
      if (this.showSeconds) {
        $spinners.push(makeColon());
        $spinners.push(makeSpinbutton(this.setSeconds, "seconds", "b-time-seconds", {
          value: this.modelSeconds,
          max: 59,
          step: this.secondsStep || 1,
          formatterFn: this.formatSeconds,
          ariaLabel: this.labelSeconds
        }));
      }
      if (this.isLive && this.is12Hour) {
        $spinners.push(makeSpinbutton(this.setAmpm, "ampm", "b-time-ampm", {
          value: this.modelAmpm,
          max: 1,
          formatterFn: this.formatAmpm,
          ariaLabel: this.labelAmpm,
          // We set `required` as `false`, since this always has a value
          required: false
        }));
      }
      $spinners = h("div", {
        staticClass: "d-flex align-items-center justify-content-center mx-auto",
        attrs: {
          role: "group",
          tabindex: disabled || readonly ? null : "-1",
          "aria-labelledby": ariaLabelledby
        },
        on: {
          keydown: this.onSpinLeftRight,
          click: (
            /* istanbul ignore next */
            function click(event2) {
              if (event2.target === event2.currentTarget) {
                focusHandler();
              }
            }
          )
        }
      }, $spinners);
      var $value = h("output", {
        staticClass: "form-control form-control-sm text-center",
        class: {
          disabled: disabled || readonly
        },
        attrs: {
          id: valueId,
          role: "status",
          for: spinIds.filter(identity).join(" ") || null,
          tabindex: disabled ? null : "-1",
          "aria-live": this.isLive ? "polite" : "off",
          "aria-atomic": "true"
        },
        on: {
          // Transfer focus/click to focus hours spinner
          click: focusHandler,
          focus: focusHandler
        }
      }, [h("bdi", this.formattedTimeString), this.computedHMS ? h("span", {
        staticClass: "sr-only"
      }, " (".concat(this.labelSelected, ") ")) : ""]);
      var $header = h(this.headerTag, {
        staticClass: "b-time-header",
        class: {
          "sr-only": this.hideHeader
        }
      }, [$value]);
      var $content = this.normalizeSlot();
      var $footer = $content ? h(this.footerTag, {
        staticClass: "b-time-footer"
      }, $content) : h();
      return h("div", {
        staticClass: "b-time d-inline-flex flex-column text-center",
        attrs: {
          role: "group",
          lang: this.computedLang || null,
          "aria-labelledby": ariaLabelledby || null,
          "aria-disabled": disabled ? "true" : null,
          "aria-readonly": readonly && !disabled ? "true" : null
        }
      }, [$header, $spinners, $footer]);
    }
  });
  var _watch$7;
  function ownKeys$K(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$K(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$K(Object(source), true).forEach(function(key) {
        _defineProperty$Z(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$K(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$Z(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$6 = makeModelMixin("value", {
    type: PROP_TYPE_STRING,
    defaultValue: ""
  }), modelMixin$6 = _makeModelMixin$6.mixin, modelProps$6 = _makeModelMixin$6.props, MODEL_PROP_NAME$6 = _makeModelMixin$6.prop, MODEL_EVENT_NAME$6 = _makeModelMixin$6.event;
  var timeProps = omit(props$18, ["hidden", "id", "value"]);
  var formBtnLabelControlProps = omit(props$1o, ["formattedValue", "id", "lang", "rtl", "value"]);
  var props$17 = makePropsConfigurable(sortKeys(_objectSpread$K(_objectSpread$K(_objectSpread$K(_objectSpread$K(_objectSpread$K({}, props$25), modelProps$6), timeProps), formBtnLabelControlProps), {}, {
    closeButtonVariant: makeProp(PROP_TYPE_STRING, "outline-secondary"),
    labelCloseButton: makeProp(PROP_TYPE_STRING, "Close"),
    labelNowButton: makeProp(PROP_TYPE_STRING, "Select now"),
    labelResetButton: makeProp(PROP_TYPE_STRING, "Reset"),
    noCloseButton: makeProp(PROP_TYPE_BOOLEAN, false),
    nowButton: makeProp(PROP_TYPE_BOOLEAN, false),
    nowButtonVariant: makeProp(PROP_TYPE_STRING, "outline-primary"),
    resetButton: makeProp(PROP_TYPE_BOOLEAN, false),
    resetButtonVariant: makeProp(PROP_TYPE_STRING, "outline-danger"),
    resetValue: makeProp(PROP_TYPE_DATE_STRING)
  })), NAME_FORM_TIMEPICKER);
  var BFormTimepicker = /* @__PURE__ */ extend({
    name: NAME_FORM_TIMEPICKER,
    mixins: [idMixin, modelMixin$6],
    props: props$17,
    data: function data() {
      return {
        // We always use `HH:mm:ss` value internally
        localHMS: this[MODEL_PROP_NAME$6] || "",
        // Context data from BTime
        localLocale: null,
        isRTL: false,
        formattedValue: "",
        // If the menu is opened
        isVisible: false
      };
    },
    computed: {
      computedLang: function computedLang() {
        return (this.localLocale || "").replace(/-u-.*$/i, "") || null;
      }
    },
    watch: (_watch$7 = {}, _defineProperty$Z(_watch$7, MODEL_PROP_NAME$6, function(newValue) {
      this.localHMS = newValue || "";
    }), _defineProperty$Z(_watch$7, "localHMS", function localHMS(newValue) {
      if (this.isVisible) {
        this.$emit(MODEL_EVENT_NAME$6, newValue || "");
      }
    }), _watch$7),
    methods: {
      // Public methods
      focus: function focus() {
        if (!this.disabled) {
          attemptFocus(this.$refs.control);
        }
      },
      blur: function blur() {
        if (!this.disabled) {
          attemptBlur(this.$refs.control);
        }
      },
      // Private methods
      setAndClose: function setAndClose(value) {
        var _this = this;
        this.localHMS = value;
        this.$nextTick(function() {
          _this.$refs.control.hide(true);
        });
      },
      onInput: function onInput(hms) {
        if (this.localHMS !== hms) {
          this.localHMS = hms;
        }
      },
      onContext: function onContext(ctx) {
        var isRTL = ctx.isRTL, locale = ctx.locale, value = ctx.value, formatted = ctx.formatted;
        this.isRTL = isRTL;
        this.localLocale = locale;
        this.formattedValue = formatted;
        this.localHMS = value || "";
        this.$emit(EVENT_NAME_CONTEXT, ctx);
      },
      onNowButton: function onNowButton() {
        var now = /* @__PURE__ */ new Date();
        var hours = now.getHours();
        var minutes = now.getMinutes();
        var seconds = this.showSeconds ? now.getSeconds() : 0;
        var value = [hours, minutes, seconds].map(function(v) {
          return "00".concat(v || "").slice(-2);
        }).join(":");
        this.setAndClose(value);
      },
      onResetButton: function onResetButton() {
        this.setAndClose(this.resetValue);
      },
      onCloseButton: function onCloseButton() {
        this.$refs.control.hide(true);
      },
      onShow: function onShow() {
        this.isVisible = true;
      },
      onShown: function onShown() {
        var _this2 = this;
        this.$nextTick(function() {
          attemptFocus(_this2.$refs.time);
          _this2.$emit(EVENT_NAME_SHOWN);
        });
      },
      onHidden: function onHidden() {
        this.isVisible = false;
        this.$emit(EVENT_NAME_HIDDEN);
      },
      // Render function helpers
      defaultButtonFn: function defaultButtonFn(_ref) {
        var isHovered = _ref.isHovered, hasFocus = _ref.hasFocus;
        return this.$createElement(isHovered || hasFocus ? BIconClockFill : BIconClock, {
          attrs: {
            "aria-hidden": "true"
          }
        });
      }
    },
    render: function render(h) {
      var localHMS = this.localHMS, disabled = this.disabled, readonly = this.readonly, $props = this.$props;
      var placeholder = isUndefinedOrNull(this.placeholder) ? this.labelNoTimeSelected : this.placeholder;
      var $footer = [];
      if (this.nowButton) {
        var label = this.labelNowButton;
        $footer.push(h(BButton, {
          props: {
            size: "sm",
            disabled: disabled || readonly,
            variant: this.nowButtonVariant
          },
          attrs: {
            "aria-label": label || null
          },
          on: {
            click: this.onNowButton
          },
          key: "now-btn"
        }, label));
      }
      if (this.resetButton) {
        if ($footer.length > 0) {
          $footer.push(h("span", " "));
        }
        var _label = this.labelResetButton;
        $footer.push(h(BButton, {
          props: {
            size: "sm",
            disabled: disabled || readonly,
            variant: this.resetButtonVariant
          },
          attrs: {
            "aria-label": _label || null
          },
          on: {
            click: this.onResetButton
          },
          key: "reset-btn"
        }, _label));
      }
      if (!this.noCloseButton) {
        if ($footer.length > 0) {
          $footer.push(h("span", " "));
        }
        var _label2 = this.labelCloseButton;
        $footer.push(h(BButton, {
          props: {
            size: "sm",
            disabled,
            variant: this.closeButtonVariant
          },
          attrs: {
            "aria-label": _label2 || null
          },
          on: {
            click: this.onCloseButton
          },
          key: "close-btn"
        }, _label2));
      }
      if ($footer.length > 0) {
        $footer = [h("div", {
          staticClass: "b-form-date-controls d-flex flex-wrap",
          class: {
            "justify-content-between": $footer.length > 1,
            "justify-content-end": $footer.length < 2
          }
        }, $footer)];
      }
      var $time = h(BTime, {
        staticClass: "b-form-time-control",
        props: _objectSpread$K(_objectSpread$K({}, pluckProps(timeProps, $props)), {}, {
          value: localHMS,
          hidden: !this.isVisible
        }),
        on: {
          input: this.onInput,
          context: this.onContext
        },
        ref: "time"
      }, $footer);
      return h(BVFormBtnLabelControl, {
        staticClass: "b-form-timepicker",
        props: _objectSpread$K(_objectSpread$K({}, pluckProps(formBtnLabelControlProps, $props)), {}, {
          id: this.safeId(),
          value: localHMS,
          formattedValue: localHMS ? this.formattedValue : "",
          placeholder,
          rtl: this.isRTL,
          lang: this.computedLang
        }),
        on: {
          show: this.onShow,
          shown: this.onShown,
          hidden: this.onHidden
        },
        scopedSlots: _defineProperty$Z({}, SLOT_NAME_BUTTON_CONTENT, this.$scopedSlots[SLOT_NAME_BUTTON_CONTENT] || this.defaultButtonFn),
        ref: "control"
      }, [$time]);
    }
  });
  var FormTimepickerPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BFormTimepicker,
      BTimepicker: BFormTimepicker
    }
  });
  var ImagePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BImg,
      BImgLazy
    }
  });
  var props$16 = makePropsConfigurable({
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_INPUT_GROUP_TEXT);
  var BInputGroupText = /* @__PURE__ */ extend({
    name: NAME_INPUT_GROUP_TEXT,
    functional: true,
    props: props$16,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        staticClass: "input-group-text"
      }), children);
    }
  });
  var props$15 = makePropsConfigurable({
    append: makeProp(PROP_TYPE_BOOLEAN, false),
    id: makeProp(PROP_TYPE_STRING),
    isText: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_INPUT_GROUP_ADDON);
  var BInputGroupAddon = /* @__PURE__ */ extend({
    name: NAME_INPUT_GROUP_ADDON,
    functional: true,
    props: props$15,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var append = props2.append;
      return h(props2.tag, a(data, {
        class: {
          "input-group-append": append,
          "input-group-prepend": !append
        },
        attrs: {
          id: props2.id
        }
      }), props2.isText ? [h(BInputGroupText, children)] : children);
    }
  });
  function ownKeys$J(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$J(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$J(Object(source), true).forEach(function(key) {
        _defineProperty$Y(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$J(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$Y(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$14 = makePropsConfigurable(omit(props$15, ["append"]), NAME_INPUT_GROUP_APPEND);
  var BInputGroupAppend = /* @__PURE__ */ extend({
    name: NAME_INPUT_GROUP_APPEND,
    functional: true,
    props: props$14,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(BInputGroupAddon, a(data, {
        props: _objectSpread$J(_objectSpread$J({}, props2), {}, {
          append: true
        })
      }), children);
    }
  });
  function ownKeys$I(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$I(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$I(Object(source), true).forEach(function(key) {
        _defineProperty$X(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$I(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$X(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$13 = makePropsConfigurable(omit(props$15, ["append"]), NAME_INPUT_GROUP_PREPEND);
  var BInputGroupPrepend = /* @__PURE__ */ extend({
    name: NAME_INPUT_GROUP_PREPEND,
    functional: true,
    props: props$13,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(BInputGroupAddon, a(data, {
        props: _objectSpread$I(_objectSpread$I({}, props2), {}, {
          append: false
        })
      }), children);
    }
  });
  function _defineProperty$W(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$12 = makePropsConfigurable({
    append: makeProp(PROP_TYPE_STRING),
    appendHtml: makeProp(PROP_TYPE_STRING),
    id: makeProp(PROP_TYPE_STRING),
    prepend: makeProp(PROP_TYPE_STRING),
    prependHtml: makeProp(PROP_TYPE_STRING),
    size: makeProp(PROP_TYPE_STRING),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_INPUT_GROUP);
  var BInputGroup = /* @__PURE__ */ extend({
    name: NAME_INPUT_GROUP,
    functional: true,
    props: props$12,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var prepend = props2.prepend, prependHtml = props2.prependHtml, append = props2.append, appendHtml = props2.appendHtml, size = props2.size;
      var $scopedSlots = scopedSlots || {};
      var $slots = slots();
      var slotScope = {};
      var $prepend = h();
      var hasPrependSlot = hasNormalizedSlot(SLOT_NAME_PREPEND, $scopedSlots, $slots);
      if (hasPrependSlot || prepend || prependHtml) {
        $prepend = h(BInputGroupPrepend, [hasPrependSlot ? normalizeSlot(SLOT_NAME_PREPEND, slotScope, $scopedSlots, $slots) : h(BInputGroupText, {
          domProps: htmlOrText(prependHtml, prepend)
        })]);
      }
      var $append = h();
      var hasAppendSlot = hasNormalizedSlot(SLOT_NAME_APPEND, $scopedSlots, $slots);
      if (hasAppendSlot || append || appendHtml) {
        $append = h(BInputGroupAppend, [hasAppendSlot ? normalizeSlot(SLOT_NAME_APPEND, slotScope, $scopedSlots, $slots) : h(BInputGroupText, {
          domProps: htmlOrText(appendHtml, append)
        })]);
      }
      return h(props2.tag, a(data, {
        staticClass: "input-group",
        class: _defineProperty$W({}, "input-group-".concat(size), size),
        attrs: {
          id: props2.id || null,
          role: "group"
        }
      }), [$prepend, normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots), $append]);
    }
  });
  var InputGroupPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BInputGroup,
      BInputGroupAddon,
      BInputGroupPrepend,
      BInputGroupAppend,
      BInputGroupText
    }
  });
  function _defineProperty$V(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$11 = makePropsConfigurable({
    // String breakpoint name new in Bootstrap v4.4.x
    fluid: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_CONTAINER);
  var BContainer = /* @__PURE__ */ extend({
    name: NAME_CONTAINER,
    functional: true,
    props: props$11,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var fluid = props2.fluid;
      return h(props2.tag, a(data, {
        class: _defineProperty$V({
          container: !(fluid || fluid === ""),
          "container-fluid": fluid === true || fluid === ""
        }, "container-".concat(fluid), fluid && fluid !== true)
      }), children);
    }
  });
  function _defineProperty$U(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$10 = makePropsConfigurable({
    bgVariant: makeProp(PROP_TYPE_STRING),
    borderVariant: makeProp(PROP_TYPE_STRING),
    containerFluid: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    fluid: makeProp(PROP_TYPE_BOOLEAN, false),
    header: makeProp(PROP_TYPE_STRING),
    headerHtml: makeProp(PROP_TYPE_STRING),
    headerLevel: makeProp(PROP_TYPE_NUMBER_STRING, 3),
    headerTag: makeProp(PROP_TYPE_STRING, "h1"),
    lead: makeProp(PROP_TYPE_STRING),
    leadHtml: makeProp(PROP_TYPE_STRING),
    leadTag: makeProp(PROP_TYPE_STRING, "p"),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    textVariant: makeProp(PROP_TYPE_STRING)
  }, NAME_JUMBOTRON);
  var BJumbotron = /* @__PURE__ */ extend({
    name: NAME_JUMBOTRON,
    functional: true,
    props: props$10,
    render: function render(h, _ref) {
      var _class2;
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var header = props2.header, headerHtml = props2.headerHtml, lead = props2.lead, leadHtml = props2.leadHtml, textVariant = props2.textVariant, bgVariant = props2.bgVariant, borderVariant = props2.borderVariant;
      var $scopedSlots = scopedSlots || {};
      var $slots = slots();
      var slotScope = {};
      var $header = h();
      var hasHeaderSlot = hasNormalizedSlot(SLOT_NAME_HEADER, $scopedSlots, $slots);
      if (hasHeaderSlot || header || headerHtml) {
        var headerLevel = props2.headerLevel;
        $header = h(props2.headerTag, {
          class: _defineProperty$U({}, "display-".concat(headerLevel), headerLevel),
          domProps: hasHeaderSlot ? {} : htmlOrText(headerHtml, header)
        }, normalizeSlot(SLOT_NAME_HEADER, slotScope, $scopedSlots, $slots));
      }
      var $lead = h();
      var hasLeadSlot = hasNormalizedSlot(SLOT_NAME_LEAD, $scopedSlots, $slots);
      if (hasLeadSlot || lead || leadHtml) {
        $lead = h(props2.leadTag, {
          staticClass: "lead",
          domProps: hasLeadSlot ? {} : htmlOrText(leadHtml, lead)
        }, normalizeSlot(SLOT_NAME_LEAD, slotScope, $scopedSlots, $slots));
      }
      var $children = [$header, $lead, normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots)];
      if (props2.fluid) {
        $children = [h(BContainer, {
          props: {
            fluid: props2.containerFluid
          }
        }, $children)];
      }
      return h(props2.tag, a(data, {
        staticClass: "jumbotron",
        class: (_class2 = {
          "jumbotron-fluid": props2.fluid
        }, _defineProperty$U(_class2, "text-".concat(textVariant), textVariant), _defineProperty$U(_class2, "bg-".concat(bgVariant), bgVariant), _defineProperty$U(_class2, "border-".concat(borderVariant), borderVariant), _defineProperty$U(_class2, "border", borderVariant), _class2)
      }), $children);
    }
  });
  var JumbotronPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BJumbotron
    }
  });
  function ownKeys$H(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$H(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$H(Object(source), true).forEach(function(key) {
        _defineProperty$T(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$H(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$T(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var COMMON_ALIGNMENT = ["start", "end", "center"];
  var computeRowColsClass = memoize(function(breakpoint, cols) {
    cols = trim(toString(cols));
    return cols ? lowerCase(["row-cols", breakpoint, cols].filter(identity).join("-")) : null;
  });
  var computeRowColsBreakpoint = memoize(function(prop2) {
    return lowerCase(prop2.replace("cols", ""));
  });
  var rowColsPropList = [];
  var generateProps = function generateProps2() {
    var rowColsProps = getBreakpointsUpCached().reduce(function(props2, breakpoint) {
      props2[suffixPropName(breakpoint, "cols")] = makeProp(PROP_TYPE_NUMBER_STRING);
      return props2;
    }, create(null));
    rowColsPropList = keys(rowColsProps);
    return makePropsConfigurable(sortKeys(_objectSpread$H(_objectSpread$H({}, rowColsProps), {}, {
      alignContent: makeProp(PROP_TYPE_STRING, null, function(value) {
        return arrayIncludes(concat(COMMON_ALIGNMENT, "between", "around", "stretch"), value);
      }),
      alignH: makeProp(PROP_TYPE_STRING, null, function(value) {
        return arrayIncludes(concat(COMMON_ALIGNMENT, "between", "around"), value);
      }),
      alignV: makeProp(PROP_TYPE_STRING, null, function(value) {
        return arrayIncludes(concat(COMMON_ALIGNMENT, "baseline", "stretch"), value);
      }),
      noGutters: makeProp(PROP_TYPE_BOOLEAN, false),
      tag: makeProp(PROP_TYPE_STRING, "div")
    })), NAME_ROW);
  };
  var BRow = {
    name: NAME_ROW,
    functional: true,
    get props() {
      delete this.props;
      this.props = generateProps();
      return this.props;
    },
    render: function render(h, _ref) {
      var _classList$push;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var alignV = props2.alignV, alignH = props2.alignH, alignContent = props2.alignContent;
      var classList = [];
      rowColsPropList.forEach(function(prop2) {
        var c = computeRowColsClass(computeRowColsBreakpoint(prop2), props2[prop2]);
        if (c) {
          classList.push(c);
        }
      });
      classList.push((_classList$push = {
        "no-gutters": props2.noGutters
      }, _defineProperty$T(_classList$push, "align-items-".concat(alignV), alignV), _defineProperty$T(_classList$push, "justify-content-".concat(alignH), alignH), _defineProperty$T(_classList$push, "align-content-".concat(alignContent), alignContent), _classList$push));
      return h(props2.tag, a(data, {
        staticClass: "row",
        class: classList
      }), children);
    }
  };
  var LayoutPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BContainer,
      BRow,
      BCol,
      BFormRow
    }
  });
  var LinkPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BLink
    }
  });
  function _defineProperty$S(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$$ = makePropsConfigurable({
    flush: makeProp(PROP_TYPE_BOOLEAN, false),
    horizontal: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_LIST_GROUP);
  var BListGroup = /* @__PURE__ */ extend({
    name: NAME_LIST_GROUP,
    functional: true,
    props: props$$,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var horizontal = props2.horizontal === "" ? true : props2.horizontal;
      horizontal = props2.flush ? false : horizontal;
      var componentData = {
        staticClass: "list-group",
        class: _defineProperty$S({
          "list-group-flush": props2.flush,
          "list-group-horizontal": horizontal === true
        }, "list-group-horizontal-".concat(horizontal), isString(horizontal))
      };
      return h(props2.tag, a(data, componentData), children);
    }
  });
  function ownKeys$G(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$G(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$G(Object(source), true).forEach(function(key) {
        _defineProperty$R(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$G(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$R(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var actionTags = ["a", "router-link", "button", "b-link"];
  var linkProps$3 = omit(props$2f, ["event", "routerTag"]);
  delete linkProps$3.href.default;
  delete linkProps$3.to.default;
  var props$_ = makePropsConfigurable(sortKeys(_objectSpread$G(_objectSpread$G({}, linkProps$3), {}, {
    action: makeProp(PROP_TYPE_BOOLEAN, false),
    button: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    variant: makeProp(PROP_TYPE_STRING)
  })), NAME_LIST_GROUP_ITEM);
  var BListGroupItem = /* @__PURE__ */ extend({
    name: NAME_LIST_GROUP_ITEM,
    functional: true,
    props: props$_,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var button = props2.button, variant = props2.variant, active = props2.active, disabled = props2.disabled;
      var link = isLink$1(props2);
      var tag = button ? "button" : !link ? props2.tag : BLink;
      var action = !!(props2.action || link || button || arrayIncludes(actionTags, props2.tag));
      var attrs = {};
      var itemProps = {};
      if (isTag(tag, "button")) {
        if (!data.attrs || !data.attrs.type) {
          attrs.type = "button";
        }
        if (props2.disabled) {
          attrs.disabled = true;
        }
      } else {
        itemProps = pluckProps(linkProps$3, props2);
      }
      return h(tag, a(data, {
        attrs,
        props: itemProps,
        staticClass: "list-group-item",
        class: (_class = {}, _defineProperty$R(_class, "list-group-item-".concat(variant), variant), _defineProperty$R(_class, "list-group-item-action", action), _defineProperty$R(_class, "active", active), _defineProperty$R(_class, "disabled", disabled), _class)
      }), children);
    }
  });
  var ListGroupPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BListGroup,
      BListGroupItem
    }
  });
  function _defineProperty$Q(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$Z = makePropsConfigurable({
    right: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    verticalAlign: makeProp(PROP_TYPE_STRING, "top")
  }, NAME_MEDIA_ASIDE);
  var BMediaAside = /* @__PURE__ */ extend({
    name: NAME_MEDIA_ASIDE,
    functional: true,
    props: props$Z,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var verticalAlign = props2.verticalAlign;
      var align = verticalAlign === "top" ? "start" : verticalAlign === "bottom" ? "end" : (
        /* istanbul ignore next */
        verticalAlign
      );
      return h(props2.tag, a(data, {
        staticClass: "media-aside",
        class: _defineProperty$Q({
          "media-aside-right": props2.right
        }, "align-self-".concat(align), align)
      }), children);
    }
  });
  var props$Y = makePropsConfigurable({
    tag: makeProp(PROP_TYPE_STRING, "div")
  }, NAME_MEDIA_BODY);
  var BMediaBody = /* @__PURE__ */ extend({
    name: NAME_MEDIA_BODY,
    functional: true,
    props: props$Y,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      return h(props2.tag, a(data, {
        staticClass: "media-body"
      }), children);
    }
  });
  var props$X = makePropsConfigurable({
    noBody: makeProp(PROP_TYPE_BOOLEAN, false),
    rightAlign: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    verticalAlign: makeProp(PROP_TYPE_STRING, "top")
  }, NAME_MEDIA);
  var BMedia = /* @__PURE__ */ extend({
    name: NAME_MEDIA,
    functional: true,
    props: props$X,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots, children = _ref.children;
      var noBody = props2.noBody, rightAlign = props2.rightAlign, verticalAlign = props2.verticalAlign;
      var $children = noBody ? children : [];
      if (!noBody) {
        var slotScope = {};
        var $slots = slots();
        var $scopedSlots = scopedSlots || {};
        $children.push(h(BMediaBody, normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots)));
        var $aside = normalizeSlot(SLOT_NAME_ASIDE, slotScope, $scopedSlots, $slots);
        if ($aside) {
          $children[rightAlign ? "push" : "unshift"](h(BMediaAside, {
            props: {
              right: rightAlign,
              verticalAlign
            }
          }, $aside));
        }
      }
      return h(props2.tag, a(data, {
        staticClass: "media"
      }), $children);
    }
  });
  var MediaPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BMedia,
      BMediaAside,
      BMediaBody
    }
  });
  var PROP$1 = "$_documentListeners";
  var listenOnDocumentMixin = extend({
    created: function created() {
      this[PROP$1] = {};
    },
    beforeDestroy: function beforeDestroy() {
      var _this = this;
      keys(this[PROP$1] || {}).forEach(function(event2) {
        _this[PROP$1][event2].forEach(function(callback) {
          _this.listenOffDocument(event2, callback);
        });
      });
      this[PROP$1] = null;
    },
    methods: {
      registerDocumentListener: function registerDocumentListener(event2, callback) {
        if (this[PROP$1]) {
          this[PROP$1][event2] = this[PROP$1][event2] || [];
          if (!arrayIncludes(this[PROP$1][event2], callback)) {
            this[PROP$1][event2].push(callback);
          }
        }
      },
      unregisterDocumentListener: function unregisterDocumentListener(event2, callback) {
        if (this[PROP$1] && this[PROP$1][event2]) {
          this[PROP$1][event2] = this[PROP$1][event2].filter(function(cb) {
            return cb !== callback;
          });
        }
      },
      listenDocument: function listenDocument(on, event2, callback) {
        on ? this.listenOnDocument(event2, callback) : this.listenOffDocument(event2, callback);
      },
      listenOnDocument: function listenOnDocument(event2, callback) {
        if (IS_BROWSER) {
          eventOn(document, event2, callback, EVENT_OPTIONS_NO_CAPTURE);
          this.registerDocumentListener(event2, callback);
        }
      },
      listenOffDocument: function listenOffDocument(event2, callback) {
        if (IS_BROWSER) {
          eventOff(document, event2, callback, EVENT_OPTIONS_NO_CAPTURE);
        }
        this.unregisterDocumentListener(event2, callback);
      }
    }
  });
  var PROP = "$_windowListeners";
  var listenOnWindowMixin = extend({
    created: function created() {
      this[PROP] = {};
    },
    beforeDestroy: function beforeDestroy() {
      var _this = this;
      keys(this[PROP] || {}).forEach(function(event2) {
        _this[PROP][event2].forEach(function(callback) {
          _this.listenOffWindow(event2, callback);
        });
      });
      this[PROP] = null;
    },
    methods: {
      registerWindowListener: function registerWindowListener(event2, callback) {
        if (this[PROP]) {
          this[PROP][event2] = this[PROP][event2] || [];
          if (!arrayIncludes(this[PROP][event2], callback)) {
            this[PROP][event2].push(callback);
          }
        }
      },
      unregisterWindowListener: function unregisterWindowListener(event2, callback) {
        if (this[PROP] && this[PROP][event2]) {
          this[PROP][event2] = this[PROP][event2].filter(function(cb) {
            return cb !== callback;
          });
        }
      },
      listenWindow: function listenWindow(on, event2, callback) {
        on ? this.listenOnWindow(event2, callback) : this.listenOffWindow(event2, callback);
      },
      listenOnWindow: function listenOnWindow(event2, callback) {
        if (IS_BROWSER) {
          eventOn(window, event2, callback, EVENT_OPTIONS_NO_CAPTURE);
          this.registerWindowListener(event2, callback);
        }
      },
      listenOffWindow: function listenOffWindow(event2, callback) {
        if (IS_BROWSER) {
          eventOff(window, event2, callback, EVENT_OPTIONS_NO_CAPTURE);
        }
        this.unregisterWindowListener(event2, callback);
      }
    }
  });
  var useParentMixin = extend({
    computed: {
      bvParent: function bvParent() {
        return this.$parent || this.$root === this && this.$options.bvParent;
      }
    }
  });
  var getScopeId = function getScopeId2(vm) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return vm ? vm.$options._scopeId || defaultValue : defaultValue;
  };
  function _defineProperty$P(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var scopedStyleMixin = extend({
    mixins: [useParentMixin],
    computed: {
      scopedStyleAttrs: function scopedStyleAttrs() {
        var scopeId = getScopeId(this.bvParent);
        return scopeId ? _defineProperty$P({}, scopeId, "") : {};
      }
    }
  });
  function ownKeys$F(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$F(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$F(Object(source), true).forEach(function(key) {
        _defineProperty$O(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$F(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$O(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var createNewChildComponent = function createNewChildComponent2(parent, Component) {
    var config = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var bvEventRoot = parent.$root ? parent.$root.$options.bvEventRoot || parent.$root : null;
    return new Component(_objectSpread$F(_objectSpread$F({}, config), {}, {
      parent,
      bvParent: parent,
      bvEventRoot
    }));
  };
  var BVTransporterTarget = /* @__PURE__ */ extend({
    // As an abstract component, it doesn't appear in the $parent chain of
    // components, which means the next parent of any component rendered inside
    // of this one will be the parent from which is was portal'd
    abstract: true,
    name: NAME_TRANSPORTER_TARGET,
    props: {
      // Even though we only support a single root element,
      // VNodes are always passed as an array
      nodes: makeProp(PROP_TYPE_ARRAY_FUNCTION)
    },
    data: function data(vm) {
      return {
        updatedNodes: vm.nodes
      };
    },
    destroyed: function destroyed() {
      removeNode(this.$el);
    },
    render: function render(h) {
      var updatedNodes = this.updatedNodes;
      var $nodes = isFunction$1(updatedNodes) ? updatedNodes({}) : updatedNodes;
      $nodes = concat($nodes).filter(identity);
      if ($nodes && $nodes.length > 0 && !$nodes[0].text) {
        return $nodes[0];
      }
      return h();
    }
  });
  var props$W = {
    // String: CSS selector,
    // HTMLElement: Element reference
    // Mainly needed for tooltips/popovers inside modals
    container: makeProp([HTMLElement, PROP_TYPE_STRING], "body"),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    // This should be set to match the root element type
    tag: makeProp(PROP_TYPE_STRING, "div")
  };
  var BVTransporterVue2 = /* @__PURE__ */ extend({
    name: NAME_TRANSPORTER,
    mixins: [normalizeSlotMixin],
    props: props$W,
    watch: {
      disabled: {
        immediate: true,
        handler: function handler(disabled) {
          disabled ? this.unmountTarget() : this.$nextTick(this.mountTarget);
        }
      }
    },
    created: function created() {
      this.$_defaultFn = null;
      this.$_target = null;
    },
    beforeMount: function beforeMount() {
      this.mountTarget();
    },
    updated: function updated2() {
      this.updateTarget();
    },
    beforeDestroy: function beforeDestroy() {
      this.unmountTarget();
      this.$_defaultFn = null;
    },
    methods: {
      // Get the element which the target should be appended to
      getContainer: function getContainer() {
        if (IS_BROWSER) {
          var container = this.container;
          return isString(container) ? select(container) : container;
        } else {
          return null;
        }
      },
      // Mount the target
      mountTarget: function mountTarget() {
        if (!this.$_target) {
          var $container = this.getContainer();
          if ($container) {
            var $el = document.createElement("div");
            $container.appendChild($el);
            this.$_target = createNewChildComponent(this, BVTransporterTarget, {
              el: $el,
              propsData: {
                // Initial nodes to be rendered
                nodes: concat(this.normalizeSlot())
              }
            });
          }
        }
      },
      // Update the content of the target
      updateTarget: function updateTarget() {
        if (IS_BROWSER && this.$_target) {
          var defaultFn = this.$scopedSlots.default;
          if (!this.disabled) {
            if (defaultFn && this.$_defaultFn !== defaultFn) {
              this.$_target.updatedNodes = defaultFn;
            } else if (!defaultFn) {
              this.$_target.updatedNodes = this.$slots.default;
            }
          }
          this.$_defaultFn = defaultFn;
        }
      },
      // Unmount the target
      unmountTarget: function unmountTarget() {
        this.$_target && this.$_target.$destroy();
        this.$_target = null;
      }
    },
    render: function render(h) {
      if (this.disabled) {
        var $nodes = concat(this.normalizeSlot()).filter(identity);
        if ($nodes.length > 0 && !$nodes[0].text) {
          return $nodes[0];
        }
      }
      return h();
    }
  });
  var BVTransporterVue3 = /* @__PURE__ */ extend({
    name: NAME_TRANSPORTER,
    mixins: [normalizeSlotMixin],
    props: props$W,
    render: function render(h) {
      if (this.disabled) {
        var $nodes = concat(this.normalizeSlot()).filter(identity);
        if ($nodes.length > 0) {
          return $nodes[0];
        }
      }
      return h(Vue2.Teleport, {
        to: this.container
      }, this.normalizeSlot());
    }
  });
  var BVTransporter = isVue3 ? BVTransporterVue3 : BVTransporterVue2;
  function _typeof$1(obj) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof$1(obj);
  }
  function ownKeys$E(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$E(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$E(Object(source), true).forEach(function(key) {
        _defineProperty$N(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$E(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$N(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck$3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$3(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$3(Constructor, protoProps, staticProps) {
    _defineProperties$3(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get2(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);
        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }
        return desc.value;
      };
    }
    return _get.apply(this, arguments);
  }
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }
    return object;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    Object.defineProperty(subClass, "prototype", { value: Object.create(superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }), writable: false });
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  var BvModalEvent = /* @__PURE__ */ function(_BvEvent) {
    _inherits(BvModalEvent2, _BvEvent);
    var _super = _createSuper(BvModalEvent2);
    function BvModalEvent2(type) {
      var _this;
      var eventInit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      _classCallCheck$3(this, BvModalEvent2);
      _this = _super.call(this, type, eventInit);
      defineProperties(_assertThisInitialized(_this), {
        trigger: readonlyDescriptor()
      });
      return _this;
    }
    _createClass$3(BvModalEvent2, null, [{
      key: "Defaults",
      get: function get2() {
        return _objectSpread$E(_objectSpread$E({}, _get(_getPrototypeOf(BvModalEvent2), "Defaults", this)), {}, {
          trigger: null
        });
      }
    }]);
    return BvModalEvent2;
  }(BvEvent);
  var DEFAULT_ZINDEX = 1040;
  var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
  var SELECTOR_STICKY_CONTENT = ".sticky-top";
  var SELECTOR_NAVBAR_TOGGLER = ".navbar-toggler";
  var ModalManager = /* @__PURE__ */ extend({
    data: function data() {
      return {
        modals: [],
        baseZIndex: null,
        scrollbarWidth: null,
        isBodyOverflowing: false
      };
    },
    computed: {
      modalCount: function modalCount() {
        return this.modals.length;
      },
      modalsAreOpen: function modalsAreOpen() {
        return this.modalCount > 0;
      }
    },
    watch: {
      modalCount: function modalCount(newCount, oldCount) {
        if (IS_BROWSER) {
          this.getScrollbarWidth();
          if (newCount > 0 && oldCount === 0) {
            this.checkScrollbar();
            this.setScrollbar();
            addClass(document.body, "modal-open");
          } else if (newCount === 0 && oldCount > 0) {
            this.resetScrollbar();
            removeClass(document.body, "modal-open");
          }
          setAttr(document.body, "data-modal-open-count", String(newCount));
        }
      },
      modals: function modals(newValue) {
        var _this = this;
        this.checkScrollbar();
        requestAF(function() {
          _this.updateModals(newValue || []);
        });
      }
    },
    methods: {
      // Public methods
      registerModal: function registerModal(modal) {
        if (modal && this.modals.indexOf(modal) === -1) {
          this.modals.push(modal);
        }
      },
      unregisterModal: function unregisterModal(modal) {
        var index = this.modals.indexOf(modal);
        if (index > -1) {
          this.modals.splice(index, 1);
          if (!modal._isBeingDestroyed && !modal._isDestroyed) {
            this.resetModal(modal);
          }
        }
      },
      getBaseZIndex: function getBaseZIndex() {
        if (IS_BROWSER && isNull(this.baseZIndex)) {
          var div = document.createElement("div");
          addClass(div, "modal-backdrop");
          addClass(div, "d-none");
          setStyle(div, "display", "none");
          document.body.appendChild(div);
          this.baseZIndex = toInteger(getCS(div).zIndex, DEFAULT_ZINDEX);
          document.body.removeChild(div);
        }
        return this.baseZIndex || DEFAULT_ZINDEX;
      },
      getScrollbarWidth: function getScrollbarWidth() {
        if (IS_BROWSER && isNull(this.scrollbarWidth)) {
          var div = document.createElement("div");
          addClass(div, "modal-scrollbar-measure");
          document.body.appendChild(div);
          this.scrollbarWidth = getBCR(div).width - div.clientWidth;
          document.body.removeChild(div);
        }
        return this.scrollbarWidth || 0;
      },
      // Private methods
      updateModals: function updateModals(modals) {
        var _this2 = this;
        var baseZIndex = this.getBaseZIndex();
        var scrollbarWidth = this.getScrollbarWidth();
        modals.forEach(function(modal, index) {
          modal.zIndex = baseZIndex + index;
          modal.scrollbarWidth = scrollbarWidth;
          modal.isTop = index === _this2.modals.length - 1;
          modal.isBodyOverflowing = _this2.isBodyOverflowing;
        });
      },
      resetModal: function resetModal(modal) {
        if (modal) {
          modal.zIndex = this.getBaseZIndex();
          modal.isTop = true;
          modal.isBodyOverflowing = false;
        }
      },
      checkScrollbar: function checkScrollbar() {
        var _getBCR = getBCR(document.body), left = _getBCR.left, right = _getBCR.right;
        this.isBodyOverflowing = left + right < window.innerWidth;
      },
      setScrollbar: function setScrollbar() {
        var body = document.body;
        body._paddingChangedForModal = body._paddingChangedForModal || [];
        body._marginChangedForModal = body._marginChangedForModal || [];
        if (this.isBodyOverflowing) {
          var scrollbarWidth = this.scrollbarWidth;
          selectAll(SELECTOR_FIXED_CONTENT).forEach(function(el) {
            var actualPadding2 = getStyle(el, "paddingRight") || "";
            setAttr(el, "data-padding-right", actualPadding2);
            setStyle(el, "paddingRight", "".concat(toFloat(getCS(el).paddingRight, 0) + scrollbarWidth, "px"));
            body._paddingChangedForModal.push(el);
          });
          selectAll(SELECTOR_STICKY_CONTENT).forEach(function(el) {
            var actualMargin = getStyle(el, "marginRight") || "";
            setAttr(el, "data-margin-right", actualMargin);
            setStyle(el, "marginRight", "".concat(toFloat(getCS(el).marginRight, 0) - scrollbarWidth, "px"));
            body._marginChangedForModal.push(el);
          });
          selectAll(SELECTOR_NAVBAR_TOGGLER).forEach(function(el) {
            var actualMargin = getStyle(el, "marginRight") || "";
            setAttr(el, "data-margin-right", actualMargin);
            setStyle(el, "marginRight", "".concat(toFloat(getCS(el).marginRight, 0) + scrollbarWidth, "px"));
            body._marginChangedForModal.push(el);
          });
          var actualPadding = getStyle(body, "paddingRight") || "";
          setAttr(body, "data-padding-right", actualPadding);
          setStyle(body, "paddingRight", "".concat(toFloat(getCS(body).paddingRight, 0) + scrollbarWidth, "px"));
        }
      },
      resetScrollbar: function resetScrollbar() {
        var body = document.body;
        if (body._paddingChangedForModal) {
          body._paddingChangedForModal.forEach(function(el) {
            if (hasAttr(el, "data-padding-right")) {
              setStyle(el, "paddingRight", getAttr(el, "data-padding-right") || "");
              removeAttr(el, "data-padding-right");
            }
          });
        }
        if (body._marginChangedForModal) {
          body._marginChangedForModal.forEach(function(el) {
            if (hasAttr(el, "data-margin-right")) {
              setStyle(el, "marginRight", getAttr(el, "data-margin-right") || "");
              removeAttr(el, "data-margin-right");
            }
          });
        }
        body._paddingChangedForModal = null;
        body._marginChangedForModal = null;
        if (hasAttr(body, "data-padding-right")) {
          setStyle(body, "paddingRight", getAttr(body, "data-padding-right") || "");
          removeAttr(body, "data-padding-right");
        }
      }
    }
  });
  var modalManager = new ModalManager();
  function ownKeys$D(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$D(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$D(Object(source), true).forEach(function(key) {
        _defineProperty$M(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$D(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$M(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$5 = makeModelMixin("visible", {
    type: PROP_TYPE_BOOLEAN,
    defaultValue: false,
    event: EVENT_NAME_CHANGE
  }), modelMixin$5 = _makeModelMixin$5.mixin, modelProps$5 = _makeModelMixin$5.props, MODEL_PROP_NAME$5 = _makeModelMixin$5.prop, MODEL_EVENT_NAME$5 = _makeModelMixin$5.event;
  var TRIGGER_BACKDROP = "backdrop";
  var TRIGGER_ESC = "esc";
  var TRIGGER_FORCE = "FORCE";
  var TRIGGER_TOGGLE = "toggle";
  var BUTTON_CANCEL = "cancel";
  var BUTTON_CLOSE = "headerclose";
  var BUTTON_OK = "ok";
  var BUTTONS = [BUTTON_CANCEL, BUTTON_CLOSE, BUTTON_OK];
  var OBSERVER_CONFIG = {
    subtree: true,
    childList: true,
    characterData: true,
    attributes: true,
    attributeFilter: ["style", "class"]
  };
  var props$V = makePropsConfigurable(sortKeys(_objectSpread$D(_objectSpread$D(_objectSpread$D({}, props$25), modelProps$5), {}, {
    ariaLabel: makeProp(PROP_TYPE_STRING),
    autoFocusButton: makeProp(
      PROP_TYPE_STRING,
      null,
      /* istanbul ignore next */
      function(value) {
        return isUndefinedOrNull(value) || arrayIncludes(BUTTONS, value);
      }
    ),
    bodyBgVariant: makeProp(PROP_TYPE_STRING),
    bodyClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    bodyTextVariant: makeProp(PROP_TYPE_STRING),
    busy: makeProp(PROP_TYPE_BOOLEAN, false),
    buttonSize: makeProp(PROP_TYPE_STRING),
    cancelDisabled: makeProp(PROP_TYPE_BOOLEAN, false),
    cancelTitle: makeProp(PROP_TYPE_STRING, "Cancel"),
    cancelTitleHtml: makeProp(PROP_TYPE_STRING),
    cancelVariant: makeProp(PROP_TYPE_STRING, "secondary"),
    centered: makeProp(PROP_TYPE_BOOLEAN, false),
    contentClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    dialogClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    footerBgVariant: makeProp(PROP_TYPE_STRING),
    footerBorderVariant: makeProp(PROP_TYPE_STRING),
    footerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    footerTag: makeProp(PROP_TYPE_STRING, "footer"),
    footerTextVariant: makeProp(PROP_TYPE_STRING),
    headerBgVariant: makeProp(PROP_TYPE_STRING),
    headerBorderVariant: makeProp(PROP_TYPE_STRING),
    headerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerCloseContent: makeProp(PROP_TYPE_STRING, "&times;"),
    headerCloseLabel: makeProp(PROP_TYPE_STRING, "Close"),
    headerCloseVariant: makeProp(PROP_TYPE_STRING),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    headerTextVariant: makeProp(PROP_TYPE_STRING),
    // TODO: Rename to `noBackdrop` and deprecate `hideBackdrop`
    hideBackdrop: makeProp(PROP_TYPE_BOOLEAN, false),
    // TODO: Rename to `noFooter` and deprecate `hideFooter`
    hideFooter: makeProp(PROP_TYPE_BOOLEAN, false),
    // TODO: Rename to `noHeader` and deprecate `hideHeader`
    hideHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    // TODO: Rename to `noHeaderClose` and deprecate `hideHeaderClose`
    hideHeaderClose: makeProp(PROP_TYPE_BOOLEAN, false),
    ignoreEnforceFocusSelector: makeProp(PROP_TYPE_ARRAY_STRING),
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    modalClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    noCloseOnBackdrop: makeProp(PROP_TYPE_BOOLEAN, false),
    noCloseOnEsc: makeProp(PROP_TYPE_BOOLEAN, false),
    noEnforceFocus: makeProp(PROP_TYPE_BOOLEAN, false),
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    noStacking: makeProp(PROP_TYPE_BOOLEAN, false),
    okDisabled: makeProp(PROP_TYPE_BOOLEAN, false),
    okOnly: makeProp(PROP_TYPE_BOOLEAN, false),
    okTitle: makeProp(PROP_TYPE_STRING, "OK"),
    okTitleHtml: makeProp(PROP_TYPE_STRING),
    okVariant: makeProp(PROP_TYPE_STRING, "primary"),
    // HTML Element, CSS selector string or Vue component instance
    returnFocus: makeProp([HTMLElement, PROP_TYPE_OBJECT, PROP_TYPE_STRING]),
    scrollable: makeProp(PROP_TYPE_BOOLEAN, false),
    size: makeProp(PROP_TYPE_STRING, "md"),
    static: makeProp(PROP_TYPE_BOOLEAN, false),
    title: makeProp(PROP_TYPE_STRING),
    titleClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    titleHtml: makeProp(PROP_TYPE_STRING),
    titleSrOnly: makeProp(PROP_TYPE_BOOLEAN, false),
    titleTag: makeProp(PROP_TYPE_STRING, "h5")
  })), NAME_MODAL);
  var BModal = /* @__PURE__ */ extend({
    name: NAME_MODAL,
    mixins: [attrsMixin, idMixin, modelMixin$5, listenOnDocumentMixin, listenOnRootMixin, listenOnWindowMixin, normalizeSlotMixin, scopedStyleMixin],
    inheritAttrs: false,
    props: props$V,
    data: function data() {
      return {
        isHidden: true,
        // If modal should not be in document
        isVisible: false,
        // Controls modal visible state
        isTransitioning: false,
        // Used for style control
        isShow: false,
        // Used for style control
        isBlock: false,
        // Used for style control
        isOpening: false,
        // To signal that the modal is in the process of opening
        isClosing: false,
        // To signal that the modal is in the process of closing
        ignoreBackdropClick: false,
        // Used to signify if click out listener should ignore the click
        isModalOverflowing: false,
        // The following items are controlled by the modalManager instance
        scrollbarWidth: 0,
        zIndex: modalManager.getBaseZIndex(),
        isTop: true,
        isBodyOverflowing: false
      };
    },
    computed: {
      modalId: function modalId() {
        return this.safeId();
      },
      modalOuterId: function modalOuterId() {
        return this.safeId("__BV_modal_outer_");
      },
      modalHeaderId: function modalHeaderId() {
        return this.safeId("__BV_modal_header_");
      },
      modalBodyId: function modalBodyId() {
        return this.safeId("__BV_modal_body_");
      },
      modalTitleId: function modalTitleId() {
        return this.safeId("__BV_modal_title_");
      },
      modalContentId: function modalContentId() {
        return this.safeId("__BV_modal_content_");
      },
      modalFooterId: function modalFooterId() {
        return this.safeId("__BV_modal_footer_");
      },
      modalBackdropId: function modalBackdropId() {
        return this.safeId("__BV_modal_backdrop_");
      },
      modalClasses: function modalClasses() {
        return [{
          fade: !this.noFade,
          show: this.isShow
        }, this.modalClass];
      },
      modalStyles: function modalStyles() {
        var sbWidth = "".concat(this.scrollbarWidth, "px");
        return {
          paddingLeft: !this.isBodyOverflowing && this.isModalOverflowing ? sbWidth : "",
          paddingRight: this.isBodyOverflowing && !this.isModalOverflowing ? sbWidth : "",
          // Needed to fix issue https://github.com/bootstrap-vue/bootstrap-vue/issues/3457
          // Even though we are using v-show, we must ensure 'none' is restored in the styles
          display: this.isBlock ? "block" : "none"
        };
      },
      dialogClasses: function dialogClasses() {
        var _ref;
        return [(_ref = {}, _defineProperty$M(_ref, "modal-".concat(this.size), this.size), _defineProperty$M(_ref, "modal-dialog-centered", this.centered), _defineProperty$M(_ref, "modal-dialog-scrollable", this.scrollable), _ref), this.dialogClass];
      },
      headerClasses: function headerClasses() {
        var _ref2;
        return [(_ref2 = {}, _defineProperty$M(_ref2, "bg-".concat(this.headerBgVariant), this.headerBgVariant), _defineProperty$M(_ref2, "text-".concat(this.headerTextVariant), this.headerTextVariant), _defineProperty$M(_ref2, "border-".concat(this.headerBorderVariant), this.headerBorderVariant), _ref2), this.headerClass];
      },
      titleClasses: function titleClasses() {
        return [{
          "sr-only": this.titleSrOnly
        }, this.titleClass];
      },
      bodyClasses: function bodyClasses() {
        var _ref3;
        return [(_ref3 = {}, _defineProperty$M(_ref3, "bg-".concat(this.bodyBgVariant), this.bodyBgVariant), _defineProperty$M(_ref3, "text-".concat(this.bodyTextVariant), this.bodyTextVariant), _ref3), this.bodyClass];
      },
      footerClasses: function footerClasses() {
        var _ref4;
        return [(_ref4 = {}, _defineProperty$M(_ref4, "bg-".concat(this.footerBgVariant), this.footerBgVariant), _defineProperty$M(_ref4, "text-".concat(this.footerTextVariant), this.footerTextVariant), _defineProperty$M(_ref4, "border-".concat(this.footerBorderVariant), this.footerBorderVariant), _ref4), this.footerClass];
      },
      modalOuterStyle: function modalOuterStyle() {
        return {
          position: "absolute",
          zIndex: this.zIndex
        };
      },
      slotScope: function slotScope() {
        return {
          cancel: this.onCancel,
          close: this.onClose,
          hide: this.hide,
          ok: this.onOk,
          visible: this.isVisible
        };
      },
      computeIgnoreEnforceFocusSelector: function computeIgnoreEnforceFocusSelector() {
        return concat(this.ignoreEnforceFocusSelector).filter(identity).join(",").trim();
      },
      computedAttrs: function computedAttrs() {
        var scopedStyleAttrs = !this.static ? this.scopedStyleAttrs : {};
        return _objectSpread$D(_objectSpread$D(_objectSpread$D({}, scopedStyleAttrs), this.bvAttrs), {}, {
          id: this.modalOuterId
        });
      },
      computedModalAttrs: function computedModalAttrs() {
        var isVisible2 = this.isVisible, ariaLabel = this.ariaLabel;
        return {
          id: this.modalId,
          role: "dialog",
          "aria-hidden": isVisible2 ? null : "true",
          "aria-modal": isVisible2 ? "true" : null,
          "aria-label": ariaLabel,
          "aria-labelledby": this.hideHeader || ariaLabel || // TODO: Rename slot to `title` and deprecate `modal-title`
          !(this.hasNormalizedSlot(SLOT_NAME_MODAL_TITLE) || this.titleHtml || this.title) ? null : this.modalTitleId,
          "aria-describedby": this.modalBodyId
        };
      }
    },
    watch: _defineProperty$M({}, MODEL_PROP_NAME$5, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        this[newValue ? "show" : "hide"]();
      }
    }),
    created: function created() {
      this.$_observer = null;
      this.$_returnFocus = this.returnFocus || null;
    },
    mounted: function mounted() {
      this.zIndex = modalManager.getBaseZIndex();
      this.listenOnRoot(getRootActionEventName(NAME_MODAL, EVENT_NAME_SHOW), this.showHandler);
      this.listenOnRoot(getRootActionEventName(NAME_MODAL, EVENT_NAME_HIDE), this.hideHandler);
      this.listenOnRoot(getRootActionEventName(NAME_MODAL, EVENT_NAME_TOGGLE), this.toggleHandler);
      this.listenOnRoot(getRootEventName(NAME_MODAL, EVENT_NAME_SHOW), this.modalListener);
      if (this[MODEL_PROP_NAME$5] === true) {
        this.$nextTick(this.show);
      }
    },
    beforeDestroy: function beforeDestroy() {
      modalManager.unregisterModal(this);
      this.setObserver(false);
      if (this.isVisible) {
        this.isVisible = false;
        this.isShow = false;
        this.isTransitioning = false;
      }
    },
    methods: {
      setObserver: function setObserver() {
        var on = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        this.$_observer && this.$_observer.disconnect();
        this.$_observer = null;
        if (on) {
          this.$_observer = observeDom(this.$refs.content, this.checkModalOverflow.bind(this), OBSERVER_CONFIG);
        }
      },
      // Private method to update the v-model
      updateModel: function updateModel(value) {
        if (value !== this[MODEL_PROP_NAME$5]) {
          this.$emit(MODEL_EVENT_NAME$5, value);
        }
      },
      // Private method to create a BvModalEvent object
      buildEvent: function buildEvent(type) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return new BvModalEvent(type, _objectSpread$D(_objectSpread$D({
          // Default options
          cancelable: false,
          target: this.$refs.modal || this.$el || null,
          relatedTarget: null,
          trigger: null
        }, options), {}, {
          // Options that can't be overridden
          vueTarget: this,
          componentId: this.modalId
        }));
      },
      // Public method to show modal
      show: function show() {
        if (this.isVisible || this.isOpening) {
          return;
        }
        if (this.isClosing) {
          this.$once(EVENT_NAME_HIDDEN, this.show);
          return;
        }
        this.isOpening = true;
        this.$_returnFocus = this.$_returnFocus || this.getActiveElement();
        var showEvent = this.buildEvent(EVENT_NAME_SHOW, {
          cancelable: true
        });
        this.emitEvent(showEvent);
        if (showEvent.defaultPrevented || this.isVisible) {
          this.isOpening = false;
          this.updateModel(false);
          return;
        }
        this.doShow();
      },
      // Public method to hide modal
      hide: function hide2() {
        var trigger = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        if (!this.isVisible || this.isClosing) {
          return;
        }
        this.isClosing = true;
        var hideEvent = this.buildEvent(EVENT_NAME_HIDE, {
          cancelable: trigger !== TRIGGER_FORCE,
          trigger: trigger || null
        });
        if (trigger === BUTTON_OK) {
          this.$emit(EVENT_NAME_OK, hideEvent);
        } else if (trigger === BUTTON_CANCEL) {
          this.$emit(EVENT_NAME_CANCEL, hideEvent);
        } else if (trigger === BUTTON_CLOSE) {
          this.$emit(EVENT_NAME_CLOSE, hideEvent);
        }
        this.emitEvent(hideEvent);
        if (hideEvent.defaultPrevented || !this.isVisible) {
          this.isClosing = false;
          this.updateModel(true);
          return;
        }
        this.setObserver(false);
        this.isVisible = false;
        this.updateModel(false);
      },
      // Public method to toggle modal visibility
      toggle: function toggle(triggerEl) {
        if (triggerEl) {
          this.$_returnFocus = triggerEl;
        }
        if (this.isVisible) {
          this.hide(TRIGGER_TOGGLE);
        } else {
          this.show();
        }
      },
      // Private method to get the current document active element
      getActiveElement: function getActiveElement$1() {
        var activeElement = getActiveElement(IS_BROWSER ? [document.body] : []);
        return activeElement && activeElement.focus ? activeElement : null;
      },
      // Private method to finish showing modal
      doShow: function doShow() {
        var _this = this;
        if (modalManager.modalsAreOpen && this.noStacking) {
          this.listenOnRootOnce(getRootEventName(NAME_MODAL, EVENT_NAME_HIDDEN), this.doShow);
          return;
        }
        modalManager.registerModal(this);
        this.isHidden = false;
        this.$nextTick(function() {
          _this.isVisible = true;
          _this.isOpening = false;
          _this.updateModel(true);
          _this.$nextTick(function() {
            _this.setObserver(true);
          });
        });
      },
      // Transition handlers
      onBeforeEnter: function onBeforeEnter() {
        this.isTransitioning = true;
        this.setResizeEvent(true);
      },
      onEnter: function onEnter2() {
        var _this2 = this;
        this.isBlock = true;
        requestAF(function() {
          requestAF(function() {
            _this2.isShow = true;
          });
        });
      },
      onAfterEnter: function onAfterEnter2() {
        var _this3 = this;
        this.checkModalOverflow();
        this.isTransitioning = false;
        requestAF(function() {
          _this3.emitEvent(_this3.buildEvent(EVENT_NAME_SHOWN));
          _this3.setEnforceFocus(true);
          _this3.$nextTick(function() {
            _this3.focusFirst();
          });
        });
      },
      onBeforeLeave: function onBeforeLeave() {
        this.isTransitioning = true;
        this.setResizeEvent(false);
        this.setEnforceFocus(false);
      },
      onLeave: function onLeave2() {
        this.isShow = false;
      },
      onAfterLeave: function onAfterLeave2() {
        var _this4 = this;
        this.isBlock = false;
        this.isTransitioning = false;
        this.isModalOverflowing = false;
        this.isHidden = true;
        this.$nextTick(function() {
          _this4.isClosing = false;
          modalManager.unregisterModal(_this4);
          _this4.returnFocusTo();
          _this4.emitEvent(_this4.buildEvent(EVENT_NAME_HIDDEN));
        });
      },
      emitEvent: function emitEvent(bvEvent) {
        var type = bvEvent.type;
        this.emitOnRoot(getRootEventName(NAME_MODAL, type), bvEvent, bvEvent.componentId);
        this.$emit(type, bvEvent);
      },
      // UI event handlers
      onDialogMousedown: function onDialogMousedown() {
        var _this5 = this;
        var modal = this.$refs.modal;
        var onceModalMouseup = function onceModalMouseup2(event2) {
          eventOff(modal, "mouseup", onceModalMouseup2, EVENT_OPTIONS_NO_CAPTURE);
          if (event2.target === modal) {
            _this5.ignoreBackdropClick = true;
          }
        };
        eventOn(modal, "mouseup", onceModalMouseup, EVENT_OPTIONS_NO_CAPTURE);
      },
      onClickOut: function onClickOut(event2) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }
        if (!this.isVisible || this.noCloseOnBackdrop || !contains(document.body, event2.target)) {
          return;
        }
        if (!contains(this.$refs.content, event2.target)) {
          this.hide(TRIGGER_BACKDROP);
        }
      },
      onOk: function onOk() {
        this.hide(BUTTON_OK);
      },
      onCancel: function onCancel() {
        this.hide(BUTTON_CANCEL);
      },
      onClose: function onClose() {
        this.hide(BUTTON_CLOSE);
      },
      onEsc: function onEsc(event2) {
        if (event2.keyCode === CODE_ESC && this.isVisible && !this.noCloseOnEsc) {
          this.hide(TRIGGER_ESC);
        }
      },
      // Document focusin listener
      focusHandler: function focusHandler(event2) {
        var content = this.$refs.content;
        var target = event2.target;
        if (this.noEnforceFocus || !this.isTop || !this.isVisible || !content || document === target || contains(content, target) || this.computeIgnoreEnforceFocusSelector && closest(this.computeIgnoreEnforceFocusSelector, target, true)) {
          return;
        }
        var tabables = getTabables(this.$refs.content);
        var bottomTrap = this.$refs["bottom-trap"];
        var topTrap = this.$refs["top-trap"];
        if (bottomTrap && target === bottomTrap) {
          if (attemptFocus(tabables[0])) {
            return;
          }
        } else if (topTrap && target === topTrap) {
          if (attemptFocus(tabables[tabables.length - 1])) {
            return;
          }
        }
        attemptFocus(content, {
          preventScroll: true
        });
      },
      // Turn on/off focusin listener
      setEnforceFocus: function setEnforceFocus(on) {
        this.listenDocument(on, "focusin", this.focusHandler);
      },
      // Resize listener
      setResizeEvent: function setResizeEvent(on) {
        this.listenWindow(on, "resize", this.checkModalOverflow);
        this.listenWindow(on, "orientationchange", this.checkModalOverflow);
      },
      // Root listener handlers
      showHandler: function showHandler(id, triggerEl) {
        if (id === this.modalId) {
          this.$_returnFocus = triggerEl || this.getActiveElement();
          this.show();
        }
      },
      hideHandler: function hideHandler(id) {
        if (id === this.modalId) {
          this.hide("event");
        }
      },
      toggleHandler: function toggleHandler(id, triggerEl) {
        if (id === this.modalId) {
          this.toggle(triggerEl);
        }
      },
      modalListener: function modalListener(bvEvent) {
        if (this.noStacking && bvEvent.vueTarget !== this) {
          this.hide();
        }
      },
      // Focus control handlers
      focusFirst: function focusFirst() {
        var _this6 = this;
        if (IS_BROWSER) {
          requestAF(function() {
            var modal = _this6.$refs.modal;
            var content = _this6.$refs.content;
            var activeElement = _this6.getActiveElement();
            if (modal && content && !(activeElement && contains(content, activeElement))) {
              var ok = _this6.$refs["ok-button"];
              var cancel = _this6.$refs["cancel-button"];
              var close = _this6.$refs["close-button"];
              var autoFocus = _this6.autoFocusButton;
              var el = autoFocus === BUTTON_OK && ok ? ok.$el || ok : autoFocus === BUTTON_CANCEL && cancel ? cancel.$el || cancel : autoFocus === BUTTON_CLOSE && close ? close.$el || close : content;
              attemptFocus(el);
              if (el === content) {
                _this6.$nextTick(function() {
                  modal.scrollTop = 0;
                });
              }
            }
          });
        }
      },
      returnFocusTo: function returnFocusTo() {
        var el = this.returnFocus || this.$_returnFocus || null;
        this.$_returnFocus = null;
        this.$nextTick(function() {
          el = isString(el) ? select(el) : el;
          if (el) {
            el = el.$el || el;
            attemptFocus(el);
          }
        });
      },
      checkModalOverflow: function checkModalOverflow() {
        if (this.isVisible) {
          var modal = this.$refs.modal;
          this.isModalOverflowing = modal.scrollHeight > document.documentElement.clientHeight;
        }
      },
      makeModal: function makeModal(h) {
        var $header = h();
        if (!this.hideHeader) {
          var $modalHeader = this.normalizeSlot(SLOT_NAME_MODAL_HEADER, this.slotScope);
          if (!$modalHeader) {
            var $closeButton = h();
            if (!this.hideHeaderClose) {
              $closeButton = h(
                BButtonClose,
                {
                  props: {
                    content: this.headerCloseContent,
                    disabled: this.isTransitioning,
                    ariaLabel: this.headerCloseLabel,
                    textVariant: this.headerCloseVariant || this.headerTextVariant
                  },
                  on: {
                    click: this.onClose
                  },
                  ref: "close-button"
                },
                // TODO: Rename slot to `header-close` and deprecate `modal-header-close`
                [this.normalizeSlot(SLOT_NAME_MODAL_HEADER_CLOSE)]
              );
            }
            $modalHeader = [h(
              this.titleTag,
              {
                staticClass: "modal-title",
                class: this.titleClasses,
                attrs: {
                  id: this.modalTitleId
                },
                // TODO: Rename slot to `title` and deprecate `modal-title`
                domProps: this.hasNormalizedSlot(SLOT_NAME_MODAL_TITLE) ? {} : htmlOrText(this.titleHtml, this.title)
              },
              // TODO: Rename slot to `title` and deprecate `modal-title`
              this.normalizeSlot(SLOT_NAME_MODAL_TITLE, this.slotScope)
            ), $closeButton];
          }
          $header = h(this.headerTag, {
            staticClass: "modal-header",
            class: this.headerClasses,
            attrs: {
              id: this.modalHeaderId
            },
            ref: "header"
          }, [$modalHeader]);
        }
        var $body = h("div", {
          staticClass: "modal-body",
          class: this.bodyClasses,
          attrs: {
            id: this.modalBodyId
          },
          ref: "body"
        }, this.normalizeSlot(SLOT_NAME_DEFAULT, this.slotScope));
        var $footer = h();
        if (!this.hideFooter) {
          var $modalFooter = this.normalizeSlot(SLOT_NAME_MODAL_FOOTER, this.slotScope);
          if (!$modalFooter) {
            var $cancelButton = h();
            if (!this.okOnly) {
              $cancelButton = h(
                BButton,
                {
                  props: {
                    variant: this.cancelVariant,
                    size: this.buttonSize,
                    disabled: this.cancelDisabled || this.busy || this.isTransitioning
                  },
                  // TODO: Rename slot to `cancel-button` and deprecate `modal-cancel`
                  domProps: this.hasNormalizedSlot(SLOT_NAME_MODAL_CANCEL) ? {} : htmlOrText(this.cancelTitleHtml, this.cancelTitle),
                  on: {
                    click: this.onCancel
                  },
                  ref: "cancel-button"
                },
                // TODO: Rename slot to `cancel-button` and deprecate `modal-cancel`
                this.normalizeSlot(SLOT_NAME_MODAL_CANCEL)
              );
            }
            var $okButton = h(
              BButton,
              {
                props: {
                  variant: this.okVariant,
                  size: this.buttonSize,
                  disabled: this.okDisabled || this.busy || this.isTransitioning
                },
                // TODO: Rename slot to `ok-button` and deprecate `modal-ok`
                domProps: this.hasNormalizedSlot(SLOT_NAME_MODAL_OK) ? {} : htmlOrText(this.okTitleHtml, this.okTitle),
                on: {
                  click: this.onOk
                },
                ref: "ok-button"
              },
              // TODO: Rename slot to `ok-button` and deprecate `modal-ok`
              this.normalizeSlot(SLOT_NAME_MODAL_OK)
            );
            $modalFooter = [$cancelButton, $okButton];
          }
          $footer = h(this.footerTag, {
            staticClass: "modal-footer",
            class: this.footerClasses,
            attrs: {
              id: this.modalFooterId
            },
            ref: "footer"
          }, [$modalFooter]);
        }
        var $modalContent = h("div", {
          staticClass: "modal-content",
          class: this.contentClass,
          attrs: {
            id: this.modalContentId,
            tabindex: "-1"
          },
          ref: "content"
        }, [$header, $body, $footer]);
        var $tabTrapTop = h();
        var $tabTrapBottom = h();
        if (this.isVisible && !this.noEnforceFocus) {
          $tabTrapTop = h("span", {
            attrs: {
              tabindex: "0"
            },
            ref: "top-trap"
          });
          $tabTrapBottom = h("span", {
            attrs: {
              tabindex: "0"
            },
            ref: "bottom-trap"
          });
        }
        var $modalDialog = h("div", {
          staticClass: "modal-dialog",
          class: this.dialogClasses,
          on: {
            mousedown: this.onDialogMousedown
          },
          ref: "dialog"
        }, [$tabTrapTop, $modalContent, $tabTrapBottom]);
        var $modal = h("div", {
          staticClass: "modal",
          class: this.modalClasses,
          style: this.modalStyles,
          attrs: this.computedModalAttrs,
          on: {
            keydown: this.onEsc,
            click: this.onClickOut
          },
          directives: [{
            name: "show",
            value: this.isVisible
          }],
          ref: "modal"
        }, [$modalDialog]);
        $modal = h("transition", {
          props: {
            enterClass: "",
            enterToClass: "",
            enterActiveClass: "",
            leaveClass: "",
            leaveActiveClass: "",
            leaveToClass: ""
          },
          on: {
            beforeEnter: this.onBeforeEnter,
            enter: this.onEnter,
            afterEnter: this.onAfterEnter,
            beforeLeave: this.onBeforeLeave,
            leave: this.onLeave,
            afterLeave: this.onAfterLeave
          }
        }, [$modal]);
        var $backdrop = h();
        if (!this.hideBackdrop && this.isVisible) {
          $backdrop = h(
            "div",
            {
              staticClass: "modal-backdrop",
              attrs: {
                id: this.modalBackdropId
              }
            },
            // TODO: Rename slot to `backdrop` and deprecate `modal-backdrop`
            this.normalizeSlot(SLOT_NAME_MODAL_BACKDROP)
          );
        }
        $backdrop = h(BVTransition, {
          props: {
            noFade: this.noFade
          }
        }, [$backdrop]);
        return h("div", {
          style: this.modalOuterStyle,
          attrs: this.computedAttrs,
          key: "modal-outer-".concat(this[COMPONENT_UID_KEY])
        }, [$modal, $backdrop]);
      }
    },
    render: function render(h) {
      if (this.static) {
        return this.lazy && this.isHidden ? h() : this.makeModal(h);
      } else {
        return this.isHidden ? h() : h(BVTransporter, [this.makeModal(h)]);
      }
    }
  });
  var ROOT_ACTION_EVENT_NAME_SHOW = getRootActionEventName(NAME_MODAL, EVENT_NAME_SHOW);
  var PROPERTY = "__bv_modal_directive__";
  var getTarget = function getTarget2(_ref) {
    var _ref$modifiers = _ref.modifiers, modifiers2 = _ref$modifiers === void 0 ? {} : _ref$modifiers, arg = _ref.arg, value = _ref.value;
    return isString(value) ? value : isString(arg) ? arg : keys(modifiers2).reverse()[0];
  };
  var getTriggerElement = function getTriggerElement2(el) {
    return el && matches(el, ".dropdown-menu > li, li.nav-item") ? select("a, button", el) || el : el;
  };
  var setRole = function setRole2(trigger) {
    if (trigger && trigger.tagName !== "BUTTON") {
      if (!hasAttr(trigger, "role")) {
        setAttr(trigger, "role", "button");
      }
      if (trigger.tagName !== "A" && !hasAttr(trigger, "tabindex")) {
        setAttr(trigger, "tabindex", "0");
      }
    }
  };
  var bind = function bind2(el, binding, vnode) {
    var target = getTarget(binding);
    var trigger = getTriggerElement(el);
    if (target && trigger) {
      var handler = function handler2(event2) {
        var currentTarget = event2.currentTarget;
        if (!isDisabled(currentTarget)) {
          var type = event2.type;
          var key = event2.keyCode;
          if (type === "click" || type === "keydown" && (key === CODE_ENTER || key === CODE_SPACE)) {
            getEventRoot(getInstanceFromDirective(vnode, binding)).$emit(ROOT_ACTION_EVENT_NAME_SHOW, target, currentTarget);
          }
        }
      };
      el[PROPERTY] = {
        handler,
        target,
        trigger
      };
      setRole(trigger);
      eventOn(trigger, "click", handler, EVENT_OPTIONS_PASSIVE);
      if (trigger.tagName !== "BUTTON" && getAttr(trigger, "role") === "button") {
        eventOn(trigger, "keydown", handler, EVENT_OPTIONS_PASSIVE);
      }
    }
  };
  var unbind = function unbind2(el) {
    var oldProp = el[PROPERTY] || {};
    var trigger = oldProp.trigger;
    var handler = oldProp.handler;
    if (trigger && handler) {
      eventOff(trigger, "click", handler, EVENT_OPTIONS_PASSIVE);
      eventOff(trigger, "keydown", handler, EVENT_OPTIONS_PASSIVE);
      eventOff(el, "click", handler, EVENT_OPTIONS_PASSIVE);
      eventOff(el, "keydown", handler, EVENT_OPTIONS_PASSIVE);
    }
    delete el[PROPERTY];
  };
  var componentUpdated = function componentUpdated2(el, binding, vnode) {
    var oldProp = el[PROPERTY] || {};
    var target = getTarget(binding);
    var trigger = getTriggerElement(el);
    if (target !== oldProp.target || trigger !== oldProp.trigger) {
      unbind(el);
      bind(el, binding, vnode);
    }
    setRole(trigger);
  };
  var updated = function updated2() {
  };
  var VBModal = {
    inserted: componentUpdated,
    updated,
    componentUpdated,
    unbind
  };
  function _classCallCheck$2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$2(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$2(Constructor, protoProps, staticProps) {
    _defineProperties$2(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function ownKeys$C(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$C(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$C(Object(source), true).forEach(function(key) {
        _defineProperty$L(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$C(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$L(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray$6(arr) {
    return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$6();
  }
  function _nonIterableSpread$6() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$5(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen);
  }
  function _iterableToArray$6(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$6(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$5(arr);
  }
  function _arrayLikeToArray$5(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var PROP_NAME$1 = "$bvModal";
  var PROP_NAME_PRIV$1 = "_bv__modal";
  var BASE_PROPS$1 = ["id"].concat(_toConsumableArray$6(keys(omit(props$V, ["busy", "lazy", "noStacking", "static", "visible"]))));
  var defaultResolver = function defaultResolver2() {
  };
  var propsToSlots$1 = {
    msgBoxContent: "default",
    title: "modal-title",
    okTitle: "modal-ok",
    cancelTitle: "modal-cancel"
  };
  var filterOptions$1 = function filterOptions2(options) {
    return BASE_PROPS$1.reduce(function(memo, key) {
      if (!isUndefined(options[key])) {
        memo[key] = options[key];
      }
      return memo;
    }, {});
  };
  var plugin$1 = function plugin2(Vue3) {
    var BMsgBox = Vue3.extend({
      name: NAME_MSG_BOX,
      extends: BModal,
      mixins: [useParentMixin],
      destroyed: function destroyed() {
        if (this.$el && this.$el.parentNode) {
          this.$el.parentNode.removeChild(this.$el);
        }
      },
      mounted: function mounted() {
        var _this = this;
        var handleDestroy = function handleDestroy2() {
          _this.$nextTick(function() {
            requestAF(function() {
              _this.$destroy();
            });
          });
        };
        this.bvParent.$once(HOOK_EVENT_NAME_DESTROYED, handleDestroy);
        this.$once(EVENT_NAME_HIDDEN, handleDestroy);
        if (this.$router && this.$route) {
          this.$once(HOOK_EVENT_NAME_BEFORE_DESTROY, this.$watch("$router", handleDestroy));
        }
        this.show();
      }
    });
    var asyncMsgBox = function asyncMsgBox2(parent, props2) {
      var resolver = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultResolver;
      if (warnNotClient(PROP_NAME$1) || warnNoPromiseSupport(PROP_NAME$1)) {
        return;
      }
      var msgBox = createNewChildComponent(parent, BMsgBox, {
        // Preset the prop values
        propsData: _objectSpread$C(_objectSpread$C(_objectSpread$C({}, filterOptions$1(getComponentConfig(NAME_MODAL))), {}, {
          // Defaults that user can override
          hideHeaderClose: true,
          hideHeader: !(props2.title || props2.titleHtml)
        }, omit(props2, keys(propsToSlots$1))), {}, {
          // Props that can't be overridden
          lazy: false,
          busy: false,
          visible: false,
          noStacking: false,
          noEnforceFocus: false
        })
      });
      keys(propsToSlots$1).forEach(function(prop2) {
        if (!isUndefined(props2[prop2])) {
          msgBox.$slots[propsToSlots$1[prop2]] = concat(props2[prop2]);
        }
      });
      return new Promise(function(resolve, reject) {
        var resolved = false;
        msgBox.$once(HOOK_EVENT_NAME_DESTROYED, function() {
          if (!resolved) {
            reject(new Error("BootstrapVue MsgBox destroyed before resolve"));
          }
        });
        msgBox.$on(EVENT_NAME_HIDE, function(bvModalEvent) {
          if (!bvModalEvent.defaultPrevented) {
            var result = resolver(bvModalEvent);
            if (!bvModalEvent.defaultPrevented) {
              resolved = true;
              resolve(result);
            }
          }
        });
        var div = document.createElement("div");
        document.body.appendChild(div);
        msgBox.$mount(div);
      });
    };
    var makeMsgBox = function makeMsgBox2(parent, content) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var resolver = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      if (!content || warnNoPromiseSupport(PROP_NAME$1) || warnNotClient(PROP_NAME$1) || !isFunction$1(resolver)) {
        return;
      }
      return asyncMsgBox(parent, _objectSpread$C(_objectSpread$C({}, filterOptions$1(options)), {}, {
        msgBoxContent: content
      }), resolver);
    };
    var BvModal = /* @__PURE__ */ function() {
      function BvModal2(vm) {
        _classCallCheck$2(this, BvModal2);
        assign(this, {
          _vm: vm,
          _root: getEventRoot(vm)
        });
        defineProperties(this, {
          _vm: readonlyDescriptor(),
          _root: readonlyDescriptor()
        });
      }
      _createClass$2(BvModal2, [{
        key: "show",
        value: function show(id) {
          if (id && this._root) {
            var _this$_root;
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            (_this$_root = this._root).$emit.apply(_this$_root, [getRootActionEventName(NAME_MODAL, "show"), id].concat(args));
          }
        }
        // Hide modal with the specified ID args are for future use
      }, {
        key: "hide",
        value: function hide2(id) {
          if (id && this._root) {
            var _this$_root2;
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            (_this$_root2 = this._root).$emit.apply(_this$_root2, [getRootActionEventName(NAME_MODAL, "hide"), id].concat(args));
          }
        }
        // The following methods require Promise support!
        // IE 11 and others do not support Promise natively, so users
        // should have a Polyfill loaded (which they need anyways for IE 11 support)
        // Open a message box with OK button only and returns a promise
      }, {
        key: "msgBoxOk",
        value: function msgBoxOk(message) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var props2 = _objectSpread$C(_objectSpread$C({}, options), {}, {
            // Add in overrides and our content prop
            okOnly: true,
            okDisabled: false,
            hideFooter: false,
            msgBoxContent: message
          });
          return makeMsgBox(this._vm, message, props2, function() {
            return true;
          });
        }
        // Open a message box modal with OK and CANCEL buttons
        // and returns a promise
      }, {
        key: "msgBoxConfirm",
        value: function msgBoxConfirm(message) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var props2 = _objectSpread$C(_objectSpread$C({}, options), {}, {
            // Add in overrides and our content prop
            okOnly: false,
            okDisabled: false,
            cancelDisabled: false,
            hideFooter: false
          });
          return makeMsgBox(this._vm, message, props2, function(bvModalEvent) {
            var trigger = bvModalEvent.trigger;
            return trigger === "ok" ? true : trigger === "cancel" ? false : null;
          });
        }
      }]);
      return BvModal2;
    }();
    Vue3.mixin({
      beforeCreate: function beforeCreate() {
        this[PROP_NAME_PRIV$1] = new BvModal(this);
      }
    });
    if (!hasOwnProperty(Vue3.prototype, PROP_NAME$1)) {
      defineProperty$1(Vue3.prototype, PROP_NAME$1, {
        get: function get2() {
          if (!this || !this[PROP_NAME_PRIV$1]) {
            warn('"'.concat(PROP_NAME$1, '" must be accessed from a Vue instance "this" context.'), NAME_MODAL);
          }
          return this[PROP_NAME_PRIV$1];
        }
      });
    }
  };
  var BVModalPlugin = /* @__PURE__ */ pluginFactory({
    plugins: {
      plugin: plugin$1
    }
  });
  var ModalPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BModal
    },
    directives: {
      VBModal
    },
    // $bvModal injection
    plugins: {
      BVModalPlugin
    }
  });
  function _defineProperty$K(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var computeJustifyContent$1 = function computeJustifyContent2(value) {
    value = value === "left" ? "start" : value === "right" ? "end" : value;
    return "justify-content-".concat(value);
  };
  var props$U = makePropsConfigurable({
    align: makeProp(PROP_TYPE_STRING),
    // Set to `true` if placing in a card header
    cardHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    fill: makeProp(PROP_TYPE_BOOLEAN, false),
    justified: makeProp(PROP_TYPE_BOOLEAN, false),
    pills: makeProp(PROP_TYPE_BOOLEAN, false),
    small: makeProp(PROP_TYPE_BOOLEAN, false),
    tabs: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "ul"),
    vertical: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_NAV);
  var BNav = /* @__PURE__ */ extend({
    name: NAME_NAV,
    functional: true,
    props: props$U,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var tabs = props2.tabs, pills = props2.pills, vertical = props2.vertical, align = props2.align, cardHeader = props2.cardHeader;
      return h(props2.tag, a(data, {
        staticClass: "nav",
        class: (_class = {
          "nav-tabs": tabs,
          "nav-pills": pills && !tabs,
          "card-header-tabs": !vertical && cardHeader && tabs,
          "card-header-pills": !vertical && cardHeader && pills && !tabs,
          "flex-column": vertical,
          "nav-fill": !vertical && props2.fill,
          "nav-justified": !vertical && props2.justified
        }, _defineProperty$K(_class, computeJustifyContent$1(align), !vertical && align), _defineProperty$K(_class, "small", props2.small), _class)
      }), children);
    }
  });
  function ownKeys$B(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$B(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$B(Object(source), true).forEach(function(key) {
        _defineProperty$J(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$B(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$J(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var linkProps$2 = omit(props$2f, ["event", "routerTag"]);
  var props$T = makePropsConfigurable(sortKeys(_objectSpread$B(_objectSpread$B({}, linkProps$2), {}, {
    linkAttrs: makeProp(PROP_TYPE_OBJECT, {}),
    linkClasses: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  })), NAME_NAV_ITEM);
  var BNavItem = /* @__PURE__ */ extend({
    name: NAME_NAV_ITEM,
    functional: true,
    props: props$T,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, listeners = _ref.listeners, children = _ref.children;
      return h("li", a(omit(data, ["on"]), {
        staticClass: "nav-item"
      }), [h(BLink, {
        staticClass: "nav-link",
        class: props2.linkClasses,
        attrs: props2.linkAttrs,
        props: pluckProps(linkProps$2, props2),
        on: listeners
      }, children)]);
    }
  });
  var props$S = {};
  var BNavText = /* @__PURE__ */ extend({
    name: NAME_NAV_TEXT,
    functional: true,
    props: props$S,
    render: function render(h, _ref) {
      var data = _ref.data, children = _ref.children;
      return h("li", a(data, {
        staticClass: "navbar-text"
      }), children);
    }
  });
  function ownKeys$A(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$A(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$A(Object(source), true).forEach(function(key) {
        _defineProperty$I(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$A(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$I(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var formProps = omit(props$1I, ["inline"]);
  var props$R = makePropsConfigurable(sortKeys(_objectSpread$A(_objectSpread$A({}, formProps), {}, {
    formClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  })), NAME_NAV_FORM);
  var BNavForm = /* @__PURE__ */ extend({
    name: NAME_NAV_FORM,
    functional: true,
    props: props$R,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children, listeners = _ref.listeners;
      var $form = h(BForm, {
        class: props2.formClass,
        props: _objectSpread$A(_objectSpread$A({}, pluckProps(formProps, props2)), {}, {
          inline: true
        }),
        attrs: data.attrs,
        on: listeners
      }, children);
      return h("li", a(omit(data, ["attrs", "on"]), {
        staticClass: "form-inline"
      }), [$form]);
    }
  });
  function _toConsumableArray$5(arr) {
    return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$5();
  }
  function _nonIterableSpread$5() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$4(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen);
  }
  function _iterableToArray$5(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$5(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$4(arr);
  }
  function _arrayLikeToArray$4(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys$z(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$z(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$z(Object(source), true).forEach(function(key) {
        _defineProperty$H(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$z(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$H(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$Q = makePropsConfigurable(sortKeys(_objectSpread$z(_objectSpread$z({}, props$25), pick$1(props$1N, [].concat(_toConsumableArray$5(keys(props$1O)), ["html", "lazy", "menuClass", "noCaret", "role", "text", "toggleClass"])))), NAME_NAV_ITEM_DROPDOWN);
  var BNavItemDropdown = /* @__PURE__ */ extend({
    name: NAME_NAV_ITEM_DROPDOWN,
    mixins: [idMixin, dropdownMixin, normalizeSlotMixin],
    props: props$Q,
    computed: {
      toggleId: function toggleId() {
        return this.safeId("_BV_toggle_");
      },
      menuId: function menuId() {
        return this.safeId("_BV_toggle_menu_");
      },
      dropdownClasses: function dropdownClasses() {
        return [this.directionClass, this.boundaryClass, {
          show: this.visible
        }];
      },
      menuClasses: function menuClasses() {
        return [this.menuClass, {
          "dropdown-menu-right": this.right,
          show: this.visible
        }];
      },
      toggleClasses: function toggleClasses() {
        return [this.toggleClass, {
          "dropdown-toggle-no-caret": this.noCaret
        }];
      }
    },
    render: function render(h) {
      var toggleId = this.toggleId, menuId = this.menuId, visible = this.visible, hide2 = this.hide;
      var $toggle = h(BLink, {
        staticClass: "nav-link dropdown-toggle",
        class: this.toggleClasses,
        props: {
          href: "#".concat(this.id || ""),
          disabled: this.disabled
        },
        attrs: {
          id: toggleId,
          role: "button",
          "aria-haspopup": "true",
          "aria-expanded": visible ? "true" : "false",
          "aria-controls": menuId
        },
        on: {
          mousedown: this.onMousedown,
          click: this.toggle,
          keydown: this.toggle
          // Handle ENTER, SPACE and DOWN
        },
        ref: "toggle"
      }, [
        // TODO: The `text` slot is deprecated in favor of the `button-content` slot
        this.normalizeSlot([SLOT_NAME_BUTTON_CONTENT, SLOT_NAME_TEXT]) || h("span", {
          domProps: htmlOrText(this.html, this.text)
        })
      ]);
      var $menu = h("ul", {
        staticClass: "dropdown-menu",
        class: this.menuClasses,
        attrs: {
          tabindex: "-1",
          "aria-labelledby": toggleId,
          id: menuId
        },
        on: {
          keydown: this.onKeydown
          // Handle UP, DOWN and ESC
        },
        ref: "menu"
      }, !this.lazy || visible ? this.normalizeSlot(SLOT_NAME_DEFAULT, {
        hide: hide2
      }) : [h()]);
      return h("li", {
        staticClass: "nav-item b-nav-dropdown dropdown",
        class: this.dropdownClasses,
        attrs: {
          id: this.safeId()
        }
      }, [$toggle, $menu]);
    }
  });
  var NavPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BNav,
      BNavItem,
      BNavText,
      BNavForm,
      BNavItemDropdown,
      BNavItemDd: BNavItemDropdown,
      BNavDropdown: BNavItemDropdown,
      BNavDd: BNavItemDropdown
    },
    plugins: {
      DropdownPlugin
    }
  });
  function _defineProperty$G(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$P = makePropsConfigurable({
    fixed: makeProp(PROP_TYPE_STRING),
    print: makeProp(PROP_TYPE_BOOLEAN, false),
    sticky: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "nav"),
    toggleable: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    type: makeProp(PROP_TYPE_STRING, "light"),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_NAVBAR);
  var BNavbar = /* @__PURE__ */ extend({
    name: NAME_NAVBAR,
    mixins: [normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvNavbar: function getBvNavbar() {
          return _this;
        }
      };
    },
    props: props$P,
    computed: {
      breakpointClass: function breakpointClass() {
        var toggleable = this.toggleable;
        var xs = getBreakpoints()[0];
        var breakpoint = null;
        if (toggleable && isString(toggleable) && toggleable !== xs) {
          breakpoint = "navbar-expand-".concat(toggleable);
        } else if (toggleable === false) {
          breakpoint = "navbar-expand";
        }
        return breakpoint;
      }
    },
    render: function render(h) {
      var _ref;
      var tag = this.tag, type = this.type, variant = this.variant, fixed = this.fixed;
      return h(tag, {
        staticClass: "navbar",
        class: [(_ref = {
          "d-print": this.print,
          "sticky-top": this.sticky
        }, _defineProperty$G(_ref, "navbar-".concat(type), type), _defineProperty$G(_ref, "bg-".concat(variant), variant), _defineProperty$G(_ref, "fixed-".concat(fixed), fixed), _ref), this.breakpointClass],
        attrs: {
          role: isTag(tag, "nav") ? null : "navigation"
        }
      }, [this.normalizeSlot()]);
    }
  });
  function _defineProperty$F(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var computeJustifyContent = function computeJustifyContent2(value) {
    value = value === "left" ? "start" : value === "right" ? "end" : value;
    return "justify-content-".concat(value);
  };
  var props$O = makePropsConfigurable(pick$1(props$U, ["tag", "fill", "justified", "align", "small"]), NAME_NAVBAR_NAV);
  var BNavbarNav = /* @__PURE__ */ extend({
    name: NAME_NAVBAR_NAV,
    functional: true,
    props: props$O,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var align = props2.align;
      return h(props2.tag, a(data, {
        staticClass: "navbar-nav",
        class: (_class = {
          "nav-fill": props2.fill,
          "nav-justified": props2.justified
        }, _defineProperty$F(_class, computeJustifyContent(align), align), _defineProperty$F(_class, "small", props2.small), _class)
      }), children);
    }
  });
  function ownKeys$y(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$y(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$y(Object(source), true).forEach(function(key) {
        _defineProperty$E(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$y(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$E(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var linkProps$1 = omit(props$2f, ["event", "routerTag"]);
  linkProps$1.href.default = void 0;
  linkProps$1.to.default = void 0;
  var props$N = makePropsConfigurable(sortKeys(_objectSpread$y(_objectSpread$y({}, linkProps$1), {}, {
    tag: makeProp(PROP_TYPE_STRING, "div")
  })), NAME_NAVBAR_BRAND);
  var BNavbarBrand = /* @__PURE__ */ extend({
    name: NAME_NAVBAR_BRAND,
    functional: true,
    props: props$N,
    render: function render(h, _ref) {
      var props2 = _ref.props, data = _ref.data, children = _ref.children;
      var isLink2 = props2.to || props2.href;
      var tag = isLink2 ? BLink : props2.tag;
      return h(tag, a(data, {
        staticClass: "navbar-brand",
        props: isLink2 ? pluckProps(linkProps$1, props2) : {}
      }), children);
    }
  });
  var CLASS_NAME$1 = "navbar-toggler";
  var ROOT_EVENT_NAME_STATE$1 = getRootEventName(NAME_COLLAPSE, "state");
  var ROOT_EVENT_NAME_SYNC_STATE$1 = getRootEventName(NAME_COLLAPSE, "sync-state");
  var props$M = makePropsConfigurable({
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    label: makeProp(PROP_TYPE_STRING, "Toggle navigation"),
    target: makeProp(PROP_TYPE_ARRAY_STRING, void 0, true)
    // Required
  }, NAME_NAVBAR_TOGGLE);
  var BNavbarToggle = /* @__PURE__ */ extend({
    name: NAME_NAVBAR_TOGGLE,
    directives: {
      VBToggle
    },
    mixins: [listenOnRootMixin, normalizeSlotMixin],
    props: props$M,
    data: function data() {
      return {
        toggleState: false
      };
    },
    created: function created() {
      this.listenOnRoot(ROOT_EVENT_NAME_STATE$1, this.handleStateEvent);
      this.listenOnRoot(ROOT_EVENT_NAME_SYNC_STATE$1, this.handleStateEvent);
    },
    methods: {
      onClick: function onClick(event2) {
        if (!this.disabled) {
          this.$emit(EVENT_NAME_CLICK, event2);
        }
      },
      handleStateEvent: function handleStateEvent(id, state) {
        if (id === this.target) {
          this.toggleState = state;
        }
      }
    },
    render: function render(h) {
      var disabled = this.disabled;
      return h("button", {
        staticClass: CLASS_NAME$1,
        class: {
          disabled
        },
        directives: [{
          name: "VBToggle",
          value: this.target
        }],
        attrs: {
          type: "button",
          disabled,
          "aria-label": this.label
        },
        on: {
          click: this.onClick
        }
      }, [this.normalizeSlot(SLOT_NAME_DEFAULT, {
        expanded: this.toggleState
      }) || h("span", {
        staticClass: "".concat(CLASS_NAME$1, "-icon")
      })]);
    }
  });
  var NavbarPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BNavbar,
      BNavbarNav,
      BNavbarBrand,
      BNavbarToggle,
      BNavToggle: BNavbarToggle
    },
    plugins: {
      NavPlugin,
      CollapsePlugin,
      DropdownPlugin
    }
  });
  function _defineProperty$D(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$L = makePropsConfigurable({
    label: makeProp(PROP_TYPE_STRING),
    role: makeProp(PROP_TYPE_STRING, "status"),
    small: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "span"),
    type: makeProp(PROP_TYPE_STRING, "border"),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_SPINNER);
  var BSpinner = /* @__PURE__ */ extend({
    name: NAME_SPINNER,
    functional: true,
    props: props$L,
    render: function render(h, _ref) {
      var _class;
      var props2 = _ref.props, data = _ref.data, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var $slots = slots();
      var $scopedSlots = scopedSlots || {};
      var $label = normalizeSlot(SLOT_NAME_LABEL, {}, $scopedSlots, $slots) || props2.label;
      if ($label) {
        $label = h("span", {
          staticClass: "sr-only"
        }, $label);
      }
      return h(props2.tag, a(data, {
        attrs: {
          role: $label ? props2.role || "status" : null,
          "aria-hidden": $label ? null : "true"
        },
        class: (_class = {}, _defineProperty$D(_class, "spinner-".concat(props2.type), props2.type), _defineProperty$D(_class, "spinner-".concat(props2.type, "-sm"), props2.small), _defineProperty$D(_class, "text-".concat(props2.variant), props2.variant), _class)
      }), [$label || h()]);
    }
  });
  function ownKeys$x(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$x(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$x(Object(source), true).forEach(function(key) {
        _defineProperty$C(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$x(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$C(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var POSITION_COVER = {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  };
  var props$K = makePropsConfigurable({
    // Alternative to variant, allowing a specific
    // CSS color to be applied to the overlay
    bgColor: makeProp(PROP_TYPE_STRING),
    blur: makeProp(PROP_TYPE_STRING, "2px"),
    fixed: makeProp(PROP_TYPE_BOOLEAN, false),
    noCenter: makeProp(PROP_TYPE_BOOLEAN, false),
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    // If `true, does not render the default slot
    // and switches to absolute positioning
    noWrap: makeProp(PROP_TYPE_BOOLEAN, false),
    opacity: makeProp(PROP_TYPE_NUMBER_STRING, 0.85, function(value) {
      var number = toFloat(value, 0);
      return number >= 0 && number <= 1;
    }),
    overlayTag: makeProp(PROP_TYPE_STRING, "div"),
    rounded: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    show: makeProp(PROP_TYPE_BOOLEAN, false),
    spinnerSmall: makeProp(PROP_TYPE_BOOLEAN, false),
    spinnerType: makeProp(PROP_TYPE_STRING, "border"),
    spinnerVariant: makeProp(PROP_TYPE_STRING),
    variant: makeProp(PROP_TYPE_STRING, "light"),
    wrapTag: makeProp(PROP_TYPE_STRING, "div"),
    zIndex: makeProp(PROP_TYPE_NUMBER_STRING, 10)
  }, NAME_OVERLAY);
  var BOverlay = /* @__PURE__ */ extend({
    name: NAME_OVERLAY,
    mixins: [normalizeSlotMixin],
    props: props$K,
    computed: {
      computedRounded: function computedRounded() {
        var rounded = this.rounded;
        return rounded === true || rounded === "" ? "rounded" : !rounded ? "" : "rounded-".concat(rounded);
      },
      computedVariant: function computedVariant() {
        var variant = this.variant;
        return variant && !this.bgColor ? "bg-".concat(variant) : "";
      },
      slotScope: function slotScope() {
        return {
          spinnerType: this.spinnerType || null,
          spinnerVariant: this.spinnerVariant || null,
          spinnerSmall: this.spinnerSmall
        };
      }
    },
    methods: {
      defaultOverlayFn: function defaultOverlayFn(_ref) {
        var spinnerType = _ref.spinnerType, spinnerVariant = _ref.spinnerVariant, spinnerSmall = _ref.spinnerSmall;
        return this.$createElement(BSpinner, {
          props: {
            type: spinnerType,
            variant: spinnerVariant,
            small: spinnerSmall
          }
        });
      }
    },
    render: function render(h) {
      var _this = this;
      var show = this.show, fixed = this.fixed, noFade = this.noFade, noWrap = this.noWrap, slotScope = this.slotScope;
      var $overlay = h();
      if (show) {
        var $background = h("div", {
          staticClass: "position-absolute",
          class: [this.computedVariant, this.computedRounded],
          style: _objectSpread$x(_objectSpread$x({}, POSITION_COVER), {}, {
            opacity: this.opacity,
            backgroundColor: this.bgColor || null,
            backdropFilter: this.blur ? "blur(".concat(this.blur, ")") : null
          })
        });
        var $content = h("div", {
          staticClass: "position-absolute",
          style: this.noCenter ? (
            /* istanbul ignore next */
            _objectSpread$x({}, POSITION_COVER)
          ) : {
            top: "50%",
            left: "50%",
            transform: "translateX(-50%) translateY(-50%)"
          }
        }, [this.normalizeSlot(SLOT_NAME_OVERLAY, slotScope) || this.defaultOverlayFn(slotScope)]);
        $overlay = h(this.overlayTag, {
          staticClass: "b-overlay",
          class: {
            "position-absolute": !noWrap || noWrap && !fixed,
            "position-fixed": noWrap && fixed
          },
          style: _objectSpread$x(_objectSpread$x({}, POSITION_COVER), {}, {
            zIndex: this.zIndex || 10
          }),
          on: {
            click: function click(event2) {
              return _this.$emit(EVENT_NAME_CLICK, event2);
            }
          },
          key: "overlay"
        }, [$background, $content]);
      }
      $overlay = h(BVTransition, {
        props: {
          noFade,
          appear: true
        },
        on: {
          "after-enter": function afterEnter() {
            return _this.$emit(EVENT_NAME_SHOWN);
          },
          "after-leave": function afterLeave() {
            return _this.$emit(EVENT_NAME_HIDDEN);
          }
        }
      }, [$overlay]);
      if (noWrap) {
        return $overlay;
      }
      return h(this.wrapTag, {
        staticClass: "b-overlay-wrap position-relative",
        attrs: {
          "aria-busy": show ? "true" : null
        }
      }, noWrap ? [$overlay] : [this.normalizeSlot(), $overlay]);
    }
  });
  var OverlayPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BOverlay
    }
  });
  var _watch$6;
  function ownKeys$w(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$w(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$w(Object(source), true).forEach(function(key) {
        _defineProperty$B(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$w(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$B(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$4 = makeModelMixin("value", {
    type: PROP_TYPE_BOOLEAN_NUMBER_STRING,
    defaultValue: null,
    /* istanbul ignore next */
    validator: function validator(value) {
      if (!isNull(value) && toInteger(value, 0) < 1) {
        warn('"v-model" value must be a number greater than "0"', NAME_PAGINATION);
        return false;
      }
      return true;
    }
  }), modelMixin$4 = _makeModelMixin$4.mixin, modelProps$4 = _makeModelMixin$4.props, MODEL_PROP_NAME$4 = _makeModelMixin$4.prop, MODEL_EVENT_NAME$4 = _makeModelMixin$4.event;
  var ELLIPSIS_THRESHOLD = 3;
  var DEFAULT_LIMIT = 5;
  var makePageArray = function makePageArray2(startNumber, numberOfPages) {
    return createArray(numberOfPages, function(_, i) {
      return {
        number: startNumber + i,
        classes: null
      };
    });
  };
  var sanitizeLimit = function sanitizeLimit2(value) {
    var limit = toInteger(value) || 1;
    return limit < 1 ? DEFAULT_LIMIT : limit;
  };
  var sanitizeCurrentPage = function sanitizeCurrentPage2(val, numberOfPages) {
    var page = toInteger(val) || 1;
    return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page;
  };
  var onSpaceKey = function onSpaceKey2(event2) {
    if (event2.keyCode === CODE_SPACE) {
      stopEvent(event2, {
        immediatePropagation: true
      });
      event2.currentTarget.click();
      return false;
    }
  };
  var props$J = makePropsConfigurable(sortKeys(_objectSpread$w(_objectSpread$w({}, modelProps$4), {}, {
    align: makeProp(PROP_TYPE_STRING, "left"),
    ariaLabel: makeProp(PROP_TYPE_STRING, "Pagination"),
    disabled: makeProp(PROP_TYPE_BOOLEAN, false),
    ellipsisClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    ellipsisText: makeProp(PROP_TYPE_STRING, "…"),
    // '…'
    firstClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    firstNumber: makeProp(PROP_TYPE_BOOLEAN, false),
    firstText: makeProp(PROP_TYPE_STRING, "«"),
    // '«'
    hideEllipsis: makeProp(PROP_TYPE_BOOLEAN, false),
    hideGotoEndButtons: makeProp(PROP_TYPE_BOOLEAN, false),
    labelFirstPage: makeProp(PROP_TYPE_STRING, "Go to first page"),
    labelLastPage: makeProp(PROP_TYPE_STRING, "Go to last page"),
    labelNextPage: makeProp(PROP_TYPE_STRING, "Go to next page"),
    labelPage: makeProp(PROP_TYPE_FUNCTION_STRING, "Go to page"),
    labelPrevPage: makeProp(PROP_TYPE_STRING, "Go to previous page"),
    lastClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    lastNumber: makeProp(PROP_TYPE_BOOLEAN, false),
    lastText: makeProp(PROP_TYPE_STRING, "»"),
    // '»'
    limit: makeProp(
      PROP_TYPE_NUMBER_STRING,
      DEFAULT_LIMIT,
      /* istanbul ignore next */
      function(value) {
        if (toInteger(value, 0) < 1) {
          warn('Prop "limit" must be a number greater than "0"', NAME_PAGINATION);
          return false;
        }
        return true;
      }
    ),
    nextClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    nextText: makeProp(PROP_TYPE_STRING, "›"),
    // '›'
    pageClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    pills: makeProp(PROP_TYPE_BOOLEAN, false),
    prevClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    prevText: makeProp(PROP_TYPE_STRING, "‹"),
    // '‹'
    size: makeProp(PROP_TYPE_STRING)
  })), "pagination");
  var paginationMixin$1 = extend({
    mixins: [modelMixin$4, normalizeSlotMixin],
    props: props$J,
    data: function data() {
      var currentPage = toInteger(this[MODEL_PROP_NAME$4], 0);
      currentPage = currentPage > 0 ? currentPage : -1;
      return {
        currentPage,
        localNumberOfPages: 1,
        localLimit: DEFAULT_LIMIT
      };
    },
    computed: {
      btnSize: function btnSize() {
        var size = this.size;
        return size ? "pagination-".concat(size) : "";
      },
      alignment: function alignment() {
        var align = this.align;
        if (align === "center") {
          return "justify-content-center";
        } else if (align === "end" || align === "right") {
          return "justify-content-end";
        } else if (align === "fill") {
          return "text-center";
        }
        return "";
      },
      styleClass: function styleClass() {
        return this.pills ? "b-pagination-pills" : "";
      },
      computedCurrentPage: function computedCurrentPage() {
        return sanitizeCurrentPage(this.currentPage, this.localNumberOfPages);
      },
      paginationParams: function paginationParams() {
        var limit = this.localLimit, numberOfPages = this.localNumberOfPages, currentPage = this.computedCurrentPage, hideEllipsis = this.hideEllipsis, firstNumber = this.firstNumber, lastNumber = this.lastNumber;
        var showFirstDots = false;
        var showLastDots = false;
        var numberOfLinks = limit;
        var startNumber = 1;
        if (numberOfPages <= limit) {
          numberOfLinks = numberOfPages;
        } else if (currentPage < limit - 1 && limit > ELLIPSIS_THRESHOLD) {
          if (!hideEllipsis || lastNumber) {
            showLastDots = true;
            numberOfLinks = limit - (firstNumber ? 0 : 1);
          }
          numberOfLinks = mathMin(numberOfLinks, limit);
        } else if (numberOfPages - currentPage + 2 < limit && limit > ELLIPSIS_THRESHOLD) {
          if (!hideEllipsis || firstNumber) {
            showFirstDots = true;
            numberOfLinks = limit - (lastNumber ? 0 : 1);
          }
          startNumber = numberOfPages - numberOfLinks + 1;
        } else {
          if (limit > ELLIPSIS_THRESHOLD) {
            numberOfLinks = limit - (hideEllipsis ? 0 : 2);
            showFirstDots = !!(!hideEllipsis || firstNumber);
            showLastDots = !!(!hideEllipsis || lastNumber);
          }
          startNumber = currentPage - mathFloor(numberOfLinks / 2);
        }
        if (startNumber < 1) {
          startNumber = 1;
          showFirstDots = false;
        } else if (startNumber > numberOfPages - numberOfLinks) {
          startNumber = numberOfPages - numberOfLinks + 1;
          showLastDots = false;
        }
        if (showFirstDots && firstNumber && startNumber < 4) {
          numberOfLinks = numberOfLinks + 2;
          startNumber = 1;
          showFirstDots = false;
        }
        var lastPageNumber = startNumber + numberOfLinks - 1;
        if (showLastDots && lastNumber && lastPageNumber > numberOfPages - 3) {
          numberOfLinks = numberOfLinks + (lastPageNumber === numberOfPages - 2 ? 2 : 3);
          showLastDots = false;
        }
        if (limit <= ELLIPSIS_THRESHOLD) {
          if (firstNumber && startNumber === 1) {
            numberOfLinks = mathMin(numberOfLinks + 1, numberOfPages, limit + 1);
          } else if (lastNumber && numberOfPages === startNumber + numberOfLinks - 1) {
            startNumber = mathMax(startNumber - 1, 1);
            numberOfLinks = mathMin(numberOfPages - startNumber + 1, numberOfPages, limit + 1);
          }
        }
        numberOfLinks = mathMin(numberOfLinks, numberOfPages - startNumber + 1);
        return {
          showFirstDots,
          showLastDots,
          numberOfLinks,
          startNumber
        };
      },
      pageList: function pageList() {
        var _this$paginationParam = this.paginationParams, numberOfLinks = _this$paginationParam.numberOfLinks, startNumber = _this$paginationParam.startNumber;
        var currentPage = this.computedCurrentPage;
        var pages = makePageArray(startNumber, numberOfLinks);
        if (pages.length > 3) {
          var idx = currentPage - startNumber;
          var classes = "bv-d-xs-down-none";
          if (idx === 0) {
            for (var i = 3; i < pages.length; i++) {
              pages[i].classes = classes;
            }
          } else if (idx === pages.length - 1) {
            for (var _i = 0; _i < pages.length - 3; _i++) {
              pages[_i].classes = classes;
            }
          } else {
            for (var _i2 = 0; _i2 < idx - 1; _i2++) {
              pages[_i2].classes = classes;
            }
            for (var _i3 = pages.length - 1; _i3 > idx + 1; _i3--) {
              pages[_i3].classes = classes;
            }
          }
        }
        return pages;
      }
    },
    watch: (_watch$6 = {}, _defineProperty$B(_watch$6, MODEL_PROP_NAME$4, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.currentPage = sanitizeCurrentPage(newValue, this.localNumberOfPages);
      }
    }), _defineProperty$B(_watch$6, "currentPage", function currentPage(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit(MODEL_EVENT_NAME$4, newValue > 0 ? newValue : null);
      }
    }), _defineProperty$B(_watch$6, "limit", function limit(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.localLimit = sanitizeLimit(newValue);
      }
    }), _watch$6),
    created: function created() {
      var _this = this;
      this.localLimit = sanitizeLimit(this.limit);
      this.$nextTick(function() {
        _this.currentPage = _this.currentPage > _this.localNumberOfPages ? _this.localNumberOfPages : _this.currentPage;
      });
    },
    methods: {
      handleKeyNav: function handleKeyNav(event2) {
        var keyCode = event2.keyCode, shiftKey = event2.shiftKey;
        if (this.isNav) {
          return;
        }
        if (keyCode === CODE_LEFT || keyCode === CODE_UP) {
          stopEvent(event2, {
            propagation: false
          });
          shiftKey ? this.focusFirst() : this.focusPrev();
        } else if (keyCode === CODE_RIGHT || keyCode === CODE_DOWN) {
          stopEvent(event2, {
            propagation: false
          });
          shiftKey ? this.focusLast() : this.focusNext();
        }
      },
      getButtons: function getButtons() {
        return selectAll("button.page-link, a.page-link", this.$el).filter(function(btn) {
          return isVisible(btn);
        });
      },
      focusCurrent: function focusCurrent() {
        var _this2 = this;
        this.$nextTick(function() {
          var btn = _this2.getButtons().find(function(el) {
            return toInteger(getAttr(el, "aria-posinset"), 0) === _this2.computedCurrentPage;
          });
          if (!attemptFocus(btn)) {
            _this2.focusFirst();
          }
        });
      },
      focusFirst: function focusFirst() {
        var _this3 = this;
        this.$nextTick(function() {
          var btn = _this3.getButtons().find(function(el) {
            return !isDisabled(el);
          });
          attemptFocus(btn);
        });
      },
      focusLast: function focusLast() {
        var _this4 = this;
        this.$nextTick(function() {
          var btn = _this4.getButtons().reverse().find(function(el) {
            return !isDisabled(el);
          });
          attemptFocus(btn);
        });
      },
      focusPrev: function focusPrev() {
        var _this5 = this;
        this.$nextTick(function() {
          var buttons = _this5.getButtons();
          var index = buttons.indexOf(getActiveElement());
          if (index > 0 && !isDisabled(buttons[index - 1])) {
            attemptFocus(buttons[index - 1]);
          }
        });
      },
      focusNext: function focusNext() {
        var _this6 = this;
        this.$nextTick(function() {
          var buttons = _this6.getButtons();
          var index = buttons.indexOf(getActiveElement());
          if (index < buttons.length - 1 && !isDisabled(buttons[index + 1])) {
            attemptFocus(buttons[index + 1]);
          }
        });
      }
    },
    render: function render(h) {
      var _this7 = this;
      var _safeVueInstance = safeVueInstance(this), disabled = _safeVueInstance.disabled, labelPage = _safeVueInstance.labelPage, ariaLabel = _safeVueInstance.ariaLabel, isNav = _safeVueInstance.isNav, numberOfPages = _safeVueInstance.localNumberOfPages, currentPage = _safeVueInstance.computedCurrentPage;
      var pageNumbers = this.pageList.map(function(p) {
        return p.number;
      });
      var _this$paginationParam2 = this.paginationParams, showFirstDots = _this$paginationParam2.showFirstDots, showLastDots = _this$paginationParam2.showLastDots;
      var fill = this.align === "fill";
      var $buttons = [];
      var isActivePage = function isActivePage2(pageNumber) {
        return pageNumber === currentPage;
      };
      var noCurrentPage = this.currentPage < 1;
      var makeEndBtn = function makeEndBtn2(linkTo, ariaLabel2, btnSlot, btnText, btnClass, pageTest, key) {
        var isDisabled2 = disabled || isActivePage(pageTest) || noCurrentPage || linkTo < 1 || linkTo > numberOfPages;
        var pageNumber = linkTo < 1 ? 1 : linkTo > numberOfPages ? numberOfPages : linkTo;
        var scope = {
          disabled: isDisabled2,
          page: pageNumber,
          index: pageNumber - 1
        };
        var $btnContent = _this7.normalizeSlot(btnSlot, scope) || toString(btnText) || h();
        var $inner = h(isDisabled2 ? "span" : isNav ? BLink : "button", {
          staticClass: "page-link",
          class: {
            "flex-grow-1": !isNav && !isDisabled2 && fill
          },
          props: isDisabled2 || !isNav ? {} : _this7.linkProps(linkTo),
          attrs: {
            role: isNav ? null : "menuitem",
            type: isNav || isDisabled2 ? null : "button",
            tabindex: isDisabled2 || isNav ? null : "-1",
            "aria-label": ariaLabel2,
            "aria-controls": safeVueInstance(_this7).ariaControls || null,
            "aria-disabled": isDisabled2 ? "true" : null
          },
          on: isDisabled2 ? {} : {
            "!click": function click(event2) {
              _this7.onClick(event2, linkTo);
            },
            keydown: onSpaceKey
          }
        }, [$btnContent]);
        return h("li", {
          key,
          staticClass: "page-item",
          class: [{
            disabled: isDisabled2,
            "flex-fill": fill,
            "d-flex": fill && !isNav && !isDisabled2
          }, btnClass],
          attrs: {
            role: isNav ? null : "presentation",
            "aria-hidden": isDisabled2 ? "true" : null
          }
        }, [$inner]);
      };
      var makeEllipsis = function makeEllipsis2(isLast) {
        return h("li", {
          staticClass: "page-item",
          class: ["disabled", "bv-d-xs-down-none", fill ? "flex-fill" : "", _this7.ellipsisClass],
          attrs: {
            role: "separator"
          },
          key: "ellipsis-".concat(isLast ? "last" : "first")
        }, [h("span", {
          staticClass: "page-link"
        }, [_this7.normalizeSlot(SLOT_NAME_ELLIPSIS_TEXT) || toString(_this7.ellipsisText) || h()])]);
      };
      var makePageButton = function makePageButton2(page, idx) {
        var pageNumber = page.number;
        var active = isActivePage(pageNumber) && !noCurrentPage;
        var tabIndex = disabled ? null : active || noCurrentPage && idx === 0 ? "0" : "-1";
        var attrs = {
          role: isNav ? null : "menuitemradio",
          type: isNav || disabled ? null : "button",
          "aria-disabled": disabled ? "true" : null,
          "aria-controls": safeVueInstance(_this7).ariaControls || null,
          "aria-label": hasPropFunction(labelPage) ? (
            /* istanbul ignore next */
            labelPage(pageNumber)
          ) : "".concat(isFunction$1(labelPage) ? labelPage() : labelPage, " ").concat(pageNumber),
          "aria-checked": isNav ? null : active ? "true" : "false",
          "aria-current": isNav && active ? "page" : null,
          "aria-posinset": isNav ? null : pageNumber,
          "aria-setsize": isNav ? null : numberOfPages,
          // ARIA "roving tabindex" method (except in `isNav` mode)
          tabindex: isNav ? null : tabIndex
        };
        var btnContent = toString(_this7.makePage(pageNumber));
        var scope = {
          page: pageNumber,
          index: pageNumber - 1,
          content: btnContent,
          active,
          disabled
        };
        var $inner = h(disabled ? "span" : isNav ? BLink : "button", {
          props: disabled || !isNav ? {} : _this7.linkProps(pageNumber),
          staticClass: "page-link",
          class: {
            "flex-grow-1": !isNav && !disabled && fill
          },
          attrs,
          on: disabled ? {} : {
            "!click": function click(event2) {
              _this7.onClick(event2, pageNumber);
            },
            keydown: onSpaceKey
          }
        }, [_this7.normalizeSlot(SLOT_NAME_PAGE, scope) || btnContent]);
        return h("li", {
          staticClass: "page-item",
          class: [{
            disabled,
            active,
            "flex-fill": fill,
            "d-flex": fill && !isNav && !disabled
          }, page.classes, _this7.pageClass],
          attrs: {
            role: isNav ? null : "presentation"
          },
          key: "page-".concat(pageNumber)
        }, [$inner]);
      };
      var $firstPageBtn = h();
      if (!this.firstNumber && !this.hideGotoEndButtons) {
        $firstPageBtn = makeEndBtn(1, this.labelFirstPage, SLOT_NAME_FIRST_TEXT, this.firstText, this.firstClass, 1, "pagination-goto-first");
      }
      $buttons.push($firstPageBtn);
      $buttons.push(makeEndBtn(currentPage - 1, this.labelPrevPage, SLOT_NAME_PREV_TEXT, this.prevText, this.prevClass, 1, "pagination-goto-prev"));
      $buttons.push(this.firstNumber && pageNumbers[0] !== 1 ? makePageButton({
        number: 1
      }, 0) : h());
      $buttons.push(showFirstDots ? makeEllipsis(false) : h());
      this.pageList.forEach(function(page, idx) {
        var offset2 = showFirstDots && _this7.firstNumber && pageNumbers[0] !== 1 ? 1 : 0;
        $buttons.push(makePageButton(page, idx + offset2));
      });
      $buttons.push(showLastDots ? makeEllipsis(true) : h());
      $buttons.push(this.lastNumber && pageNumbers[pageNumbers.length - 1] !== numberOfPages ? makePageButton({
        number: numberOfPages
      }, -1) : h());
      $buttons.push(makeEndBtn(currentPage + 1, this.labelNextPage, SLOT_NAME_NEXT_TEXT, this.nextText, this.nextClass, numberOfPages, "pagination-goto-next"));
      var $lastPageBtn = h();
      if (!this.lastNumber && !this.hideGotoEndButtons) {
        $lastPageBtn = makeEndBtn(numberOfPages, this.labelLastPage, SLOT_NAME_LAST_TEXT, this.lastText, this.lastClass, numberOfPages, "pagination-goto-last");
      }
      $buttons.push($lastPageBtn);
      var $pagination = h("ul", {
        staticClass: "pagination",
        class: ["b-pagination", this.btnSize, this.alignment, this.styleClass],
        attrs: {
          role: isNav ? null : "menubar",
          "aria-disabled": disabled ? "true" : "false",
          "aria-label": isNav ? null : ariaLabel || null
        },
        // We disable keyboard left/right nav when `<b-pagination-nav>`
        on: isNav ? {} : {
          keydown: this.handleKeyNav
        },
        ref: "ul"
      }, $buttons);
      if (isNav) {
        return h("nav", {
          attrs: {
            "aria-disabled": disabled ? "true" : null,
            "aria-hidden": disabled ? "true" : "false",
            "aria-label": isNav ? ariaLabel || null : null
          }
        }, [$pagination]);
      }
      return $pagination;
    }
  });
  function ownKeys$v(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$v(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$v(Object(source), true).forEach(function(key) {
        _defineProperty$A(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$v(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$A(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var DEFAULT_PER_PAGE = 20;
  var DEFAULT_TOTAL_ROWS = 0;
  var sanitizePerPage = function sanitizePerPage2(value) {
    return mathMax(toInteger(value) || DEFAULT_PER_PAGE, 1);
  };
  var sanitizeTotalRows = function sanitizeTotalRows2(value) {
    return mathMax(toInteger(value) || DEFAULT_TOTAL_ROWS, 0);
  };
  var props$I = makePropsConfigurable(sortKeys(_objectSpread$v(_objectSpread$v({}, props$J), {}, {
    ariaControls: makeProp(PROP_TYPE_STRING),
    perPage: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_PER_PAGE),
    totalRows: makeProp(PROP_TYPE_NUMBER_STRING, DEFAULT_TOTAL_ROWS)
  })), NAME_PAGINATION);
  var BPagination = /* @__PURE__ */ extend({
    name: NAME_PAGINATION,
    // The render function is brought in via the `paginationMixin`
    mixins: [paginationMixin$1],
    props: props$I,
    computed: {
      numberOfPages: function numberOfPages() {
        var result = mathCeil(sanitizeTotalRows(this.totalRows) / sanitizePerPage(this.perPage));
        return result < 1 ? 1 : result;
      },
      // Used for watching changes to `perPage` and `numberOfPages`
      pageSizeNumberOfPages: function pageSizeNumberOfPages() {
        return {
          perPage: sanitizePerPage(this.perPage),
          totalRows: sanitizeTotalRows(this.totalRows),
          numberOfPages: this.numberOfPages
        };
      }
    },
    watch: {
      pageSizeNumberOfPages: function pageSizeNumberOfPages(newValue, oldValue) {
        if (!isUndefinedOrNull(oldValue)) {
          if (newValue.perPage !== oldValue.perPage && newValue.totalRows === oldValue.totalRows) {
            this.currentPage = 1;
          } else if (newValue.numberOfPages !== oldValue.numberOfPages && this.currentPage > newValue.numberOfPages) {
            this.currentPage = 1;
          }
        }
        this.localNumberOfPages = newValue.numberOfPages;
      }
    },
    created: function created() {
      var _this = this;
      this.localNumberOfPages = this.numberOfPages;
      var currentPage = toInteger(this[MODEL_PROP_NAME$4], 0);
      if (currentPage > 0) {
        this.currentPage = currentPage;
      } else {
        this.$nextTick(function() {
          _this.currentPage = 0;
        });
      }
    },
    methods: {
      // These methods are used by the render function
      onClick: function onClick(event2, pageNumber) {
        var _this2 = this;
        if (pageNumber === this.currentPage) {
          return;
        }
        var target = event2.target;
        var clickEvent = new BvEvent(EVENT_NAME_PAGE_CLICK, {
          cancelable: true,
          vueTarget: this,
          target
        });
        this.$emit(clickEvent.type, clickEvent, pageNumber);
        if (clickEvent.defaultPrevented) {
          return;
        }
        this.currentPage = pageNumber;
        this.$emit(EVENT_NAME_CHANGE, this.currentPage);
        this.$nextTick(function() {
          if (isVisible(target) && _this2.$el.contains(target)) {
            attemptFocus(target);
          } else {
            _this2.focusCurrent();
          }
        });
      },
      makePage: function makePage(pageNum) {
        return pageNum;
      },
      /* istanbul ignore next */
      linkProps: function linkProps2() {
        return {};
      }
    }
  });
  var PaginationPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BPagination
    }
  });
  function ownKeys$u(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$u(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$u(Object(source), true).forEach(function(key) {
        _defineProperty$z(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$u(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$z(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var sanitizeNumberOfPages = function sanitizeNumberOfPages2(value) {
    return mathMax(toInteger(value, 0), 1);
  };
  var _linkProps = omit(props$2f, ["event", "routerTag"]);
  var props$H = makePropsConfigurable(sortKeys(_objectSpread$u(_objectSpread$u(_objectSpread$u({}, props$J), _linkProps), {}, {
    baseUrl: makeProp(PROP_TYPE_STRING, "/"),
    linkGen: makeProp(PROP_TYPE_FUNCTION),
    // Disable auto page number detection if `true`
    noPageDetect: makeProp(PROP_TYPE_BOOLEAN, false),
    numberOfPages: makeProp(
      PROP_TYPE_NUMBER_STRING,
      1,
      /* istanbul ignore next */
      function(value) {
        var number = toInteger(value, 0);
        if (number < 1) {
          warn('Prop "number-of-pages" must be a number greater than "0"', NAME_PAGINATION_NAV);
          return false;
        }
        return true;
      }
    ),
    pageGen: makeProp(PROP_TYPE_FUNCTION),
    // Optional array of page links
    pages: makeProp(PROP_TYPE_ARRAY),
    useRouter: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_PAGINATION_NAV);
  var BPaginationNav = /* @__PURE__ */ extend({
    name: NAME_PAGINATION_NAV,
    // The render function is brought in via the pagination mixin
    mixins: [paginationMixin$1],
    props: props$H,
    computed: {
      // Used by render function to trigger wrapping in '<nav>' element
      isNav: function isNav() {
        return true;
      },
      computedValue: function computedValue() {
        var value = toInteger(this.value, 0);
        return value < 1 ? null : value;
      }
    },
    watch: {
      numberOfPages: function numberOfPages() {
        var _this = this;
        this.$nextTick(function() {
          _this.setNumberOfPages();
        });
      },
      pages: function pages() {
        var _this2 = this;
        this.$nextTick(function() {
          _this2.setNumberOfPages();
        });
      }
    },
    created: function created() {
      this.setNumberOfPages();
    },
    mounted: function mounted() {
      var _this3 = this;
      if (this.$router) {
        this.$watch("$route", function() {
          _this3.$nextTick(function() {
            requestAF(function() {
              _this3.guessCurrentPage();
            });
          });
        });
      }
    },
    methods: {
      setNumberOfPages: function setNumberOfPages() {
        var _this4 = this;
        if (isArray(this.pages) && this.pages.length > 0) {
          this.localNumberOfPages = this.pages.length;
        } else {
          this.localNumberOfPages = sanitizeNumberOfPages(this.numberOfPages);
        }
        this.$nextTick(function() {
          _this4.guessCurrentPage();
        });
      },
      onClick: function onClick(event2, pageNumber) {
        var _this5 = this;
        if (pageNumber === this.currentPage) {
          return;
        }
        var target = event2.currentTarget || event2.target;
        var clickEvent = new BvEvent(EVENT_NAME_PAGE_CLICK, {
          cancelable: true,
          vueTarget: this,
          target
        });
        this.$emit(clickEvent.type, clickEvent, pageNumber);
        if (clickEvent.defaultPrevented) {
          return;
        }
        requestAF(function() {
          _this5.currentPage = pageNumber;
          _this5.$emit(EVENT_NAME_CHANGE, pageNumber);
        });
        this.$nextTick(function() {
          attemptBlur(target);
        });
      },
      getPageInfo: function getPageInfo(pageNumber) {
        if (!isArray(this.pages) || this.pages.length === 0 || isUndefined(this.pages[pageNumber - 1])) {
          var link = "".concat(this.baseUrl).concat(pageNumber);
          return {
            link: this.useRouter ? {
              path: link
            } : link,
            text: toString(pageNumber)
          };
        }
        var info = this.pages[pageNumber - 1];
        if (isObject(info)) {
          var _link = info.link;
          return {
            // Normalize link for router use
            link: isObject(_link) ? _link : this.useRouter ? {
              path: _link
            } : _link,
            // Make sure text has a value
            text: toString(info.text || pageNumber)
          };
        } else {
          return {
            link: toString(info),
            text: toString(pageNumber)
          };
        }
      },
      makePage: function makePage(pageNumber) {
        var pageGen = this.pageGen;
        var info = this.getPageInfo(pageNumber);
        if (hasPropFunction(pageGen)) {
          return pageGen(pageNumber, info);
        }
        return info.text;
      },
      makeLink: function makeLink(pageNumber) {
        var linkGen = this.linkGen;
        var info = this.getPageInfo(pageNumber);
        if (hasPropFunction(linkGen)) {
          return linkGen(pageNumber, info);
        }
        return info.link;
      },
      linkProps: function linkProps2(pageNumber) {
        var props2 = pluckProps(_linkProps, this);
        var link = this.makeLink(pageNumber);
        if (this.useRouter || isObject(link)) {
          props2.to = link;
        } else {
          props2.href = link;
        }
        return props2;
      },
      resolveLink: function resolveLink() {
        var to = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        var link;
        try {
          link = document.createElement("a");
          link.href = computeHref({
            to
          }, "a", "/", "/");
          document.body.appendChild(link);
          var _link2 = link, pathname = _link2.pathname, hash = _link2.hash, search = _link2.search;
          document.body.removeChild(link);
          return {
            path: pathname,
            hash,
            query: parseQuery(search)
          };
        } catch (e2) {
          try {
            link && link.parentNode && link.parentNode.removeChild(link);
          } catch (_unused) {
          }
          return {};
        }
      },
      resolveRoute: function resolveRoute() {
        var to = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        try {
          var route = this.$router.resolve(to, this.$route).route;
          return {
            path: route.path,
            hash: route.hash,
            query: route.query
          };
        } catch (e2) {
          return {};
        }
      },
      guessCurrentPage: function guessCurrentPage() {
        var $router = this.$router, $route = this.$route;
        var guess = this.computedValue;
        if (!this.noPageDetect && !guess && (IS_BROWSER || !IS_BROWSER && $router)) {
          var currentRoute = $router && $route ? {
            path: $route.path,
            hash: $route.hash,
            query: $route.query
          } : {};
          var loc = IS_BROWSER ? window.location || document.location : null;
          var currentLink = loc ? {
            path: loc.pathname,
            hash: loc.hash,
            query: parseQuery(loc.search)
          } : (
            /* istanbul ignore next */
            {}
          );
          for (var pageNumber = 1; !guess && pageNumber <= this.localNumberOfPages; pageNumber++) {
            var to = this.makeLink(pageNumber);
            if ($router && (isObject(to) || this.useRouter)) {
              guess = looseEqual(this.resolveRoute(to), currentRoute) ? pageNumber : null;
            } else if (IS_BROWSER) {
              guess = looseEqual(this.resolveLink(to), currentLink) ? pageNumber : null;
            } else {
              guess = -1;
            }
          }
        }
        this.currentPage = guess > 0 ? guess : 0;
      }
    }
  });
  var PaginationNavPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BPaginationNav
    }
  });
  var AttachmentMap = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: "right",
    BOTTOM: "bottom",
    LEFT: "left",
    TOPLEFT: "top",
    TOPRIGHT: "top",
    RIGHTTOP: "right",
    RIGHTBOTTOM: "right",
    BOTTOMLEFT: "bottom",
    BOTTOMRIGHT: "bottom",
    LEFTTOP: "left",
    LEFTBOTTOM: "left"
  };
  var OffsetMap = {
    AUTO: 0,
    TOPLEFT: -1,
    TOP: 0,
    TOPRIGHT: 1,
    RIGHTTOP: -1,
    RIGHT: 0,
    RIGHTBOTTOM: 1,
    BOTTOMLEFT: -1,
    BOTTOM: 0,
    BOTTOMRIGHT: 1,
    LEFTTOP: -1,
    LEFT: 0,
    LEFTBOTTOM: 1
  };
  var props$G = {
    // The minimum distance (in `px`) from the edge of the
    // tooltip/popover that the arrow can be positioned
    arrowPadding: makeProp(PROP_TYPE_NUMBER_STRING, 6),
    // 'scrollParent', 'viewport', 'window', or `Element`
    boundary: makeProp([HTMLElement, PROP_TYPE_STRING], "scrollParent"),
    // Tooltip/popover will try and stay away from
    // boundary edge by this many pixels
    boundaryPadding: makeProp(PROP_TYPE_NUMBER_STRING, 5),
    fallbackPlacement: makeProp(PROP_TYPE_ARRAY_STRING, "flip"),
    offset: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    placement: makeProp(PROP_TYPE_STRING, "top"),
    // Element that the tooltip/popover is positioned relative to
    target: makeProp([HTMLElement, SVGElement])
  };
  var BVPopper = /* @__PURE__ */ extend({
    name: NAME_POPPER,
    mixins: [useParentMixin],
    props: props$G,
    data: function data() {
      return {
        // reactive props set by parent
        noFade: false,
        // State related data
        localShow: true,
        attachment: this.getAttachment(this.placement)
      };
    },
    computed: {
      /* istanbul ignore next */
      templateType: function templateType() {
        return "unknown";
      },
      popperConfig: function popperConfig() {
        var _this = this;
        var placement = this.placement;
        return {
          placement: this.getAttachment(placement),
          modifiers: {
            offset: {
              offset: this.getOffset(placement)
            },
            flip: {
              behavior: this.fallbackPlacement
            },
            // `arrow.element` can also be a reference to an HTML Element
            // maybe we should make this a `$ref` in the templates?
            arrow: {
              element: ".arrow"
            },
            preventOverflow: {
              padding: this.boundaryPadding,
              boundariesElement: this.boundary
            }
          },
          onCreate: function onCreate(data) {
            if (data.originalPlacement !== data.placement) {
              _this.popperPlacementChange(data);
            }
          },
          onUpdate: function onUpdate(data) {
            _this.popperPlacementChange(data);
          }
        };
      }
    },
    created: function created() {
      var _this2 = this;
      this.$_popper = null;
      this.localShow = true;
      this.$on(EVENT_NAME_SHOW, function(el) {
        _this2.popperCreate(el);
      });
      var handleDestroy = function handleDestroy2() {
        _this2.$nextTick(function() {
          requestAF(function() {
            _this2.$destroy();
          });
        });
      };
      this.bvParent.$once(HOOK_EVENT_NAME_DESTROYED, handleDestroy);
      this.$once(EVENT_NAME_HIDDEN, handleDestroy);
    },
    beforeMount: function beforeMount() {
      this.attachment = this.getAttachment(this.placement);
    },
    updated: function updated2() {
      this.updatePopper();
    },
    beforeDestroy: function beforeDestroy() {
      this.destroyPopper();
    },
    destroyed: function destroyed() {
      var el = this.$el;
      el && el.parentNode && el.parentNode.removeChild(el);
    },
    methods: {
      // "Public" method to trigger hide template
      hide: function hide2() {
        this.localShow = false;
      },
      // Private
      getAttachment: function getAttachment(placement) {
        return AttachmentMap[String(placement).toUpperCase()] || "auto";
      },
      getOffset: function getOffset(placement) {
        if (!this.offset) {
          var arrow2 = this.$refs.arrow || select(".arrow", this.$el);
          var arrowOffset = toFloat(getCS(arrow2).width, 0) + toFloat(this.arrowPadding, 0);
          switch (OffsetMap[String(placement).toUpperCase()] || 0) {
            /* istanbul ignore next: can't test in JSDOM */
            case 1:
              return "+50%p - ".concat(arrowOffset, "px");
            /* istanbul ignore next: can't test in JSDOM */
            case -1:
              return "-50%p + ".concat(arrowOffset, "px");
            default:
              return 0;
          }
        }
        return this.offset;
      },
      popperCreate: function popperCreate(el) {
        this.destroyPopper();
        this.$_popper = new Popper(this.target, el, this.popperConfig);
      },
      destroyPopper: function destroyPopper() {
        this.$_popper && this.$_popper.destroy();
        this.$_popper = null;
      },
      updatePopper: function updatePopper() {
        this.$_popper && this.$_popper.scheduleUpdate();
      },
      popperPlacementChange: function popperPlacementChange(data) {
        this.attachment = this.getAttachment(data.placement);
      },
      /* istanbul ignore next */
      renderTemplate: function renderTemplate(h) {
        return h("div");
      }
    },
    render: function render(h) {
      var _this3 = this;
      var noFade = this.noFade;
      return h(BVTransition, {
        // Transitions as soon as mounted
        props: {
          appear: true,
          noFade
        },
        on: {
          // Events used by parent component/instance
          beforeEnter: function beforeEnter(el) {
            return _this3.$emit(EVENT_NAME_SHOW, el);
          },
          afterEnter: function afterEnter(el) {
            return _this3.$emit(EVENT_NAME_SHOWN, el);
          },
          beforeLeave: function beforeLeave(el) {
            return _this3.$emit(EVENT_NAME_HIDE, el);
          },
          afterLeave: function afterLeave(el) {
            return _this3.$emit(EVENT_NAME_HIDDEN, el);
          }
        }
      }, [this.localShow ? this.renderTemplate(h) : h()]);
    }
  });
  function ownKeys$t(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$t(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$t(Object(source), true).forEach(function(key) {
        _defineProperty$y(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$y(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$F = {
    // Used only by the directive versions
    html: makeProp(PROP_TYPE_BOOLEAN, false),
    // Other non-reactive (while open) props are pulled in from BVPopper
    id: makeProp(PROP_TYPE_STRING)
  };
  var BVTooltipTemplate = /* @__PURE__ */ extend({
    name: NAME_TOOLTIP_TEMPLATE,
    extends: BVPopper,
    mixins: [scopedStyleMixin],
    props: props$F,
    data: function data() {
      return {
        title: "",
        content: "",
        variant: null,
        customClass: null,
        interactive: true
      };
    },
    computed: {
      templateType: function templateType() {
        return "tooltip";
      },
      templateClasses: function templateClasses() {
        var _ref;
        var variant = this.variant, attachment = this.attachment, templateType = this.templateType;
        return [(_ref = {
          // Disables pointer events to hide the tooltip when the user
          // hovers over its content
          noninteractive: !this.interactive
        }, _defineProperty$y(_ref, "b-".concat(templateType, "-").concat(variant), variant), _defineProperty$y(_ref, "bs-".concat(templateType, "-").concat(attachment), attachment), _ref), this.customClass];
      },
      templateAttributes: function templateAttributes() {
        var id = this.id;
        return _objectSpread$t(_objectSpread$t({}, this.bvParent.bvParent.$attrs), {}, {
          id,
          role: "tooltip",
          tabindex: "-1"
        }, this.scopedStyleAttrs);
      },
      templateListeners: function templateListeners() {
        var _this = this;
        return {
          mouseenter: (
            /* istanbul ignore next */
            function mouseenter(event2) {
              _this.$emit(EVENT_NAME_MOUSEENTER, event2);
            }
          ),
          mouseleave: (
            /* istanbul ignore next */
            function mouseleave(event2) {
              _this.$emit(EVENT_NAME_MOUSELEAVE, event2);
            }
          ),
          focusin: (
            /* istanbul ignore next */
            function focusin(event2) {
              _this.$emit(EVENT_NAME_FOCUSIN, event2);
            }
          ),
          focusout: (
            /* istanbul ignore next */
            function focusout(event2) {
              _this.$emit(EVENT_NAME_FOCUSOUT, event2);
            }
          )
        };
      }
    },
    methods: {
      renderTemplate: function renderTemplate(h) {
        var title = this.title;
        var $title = isFunction$1(title) ? title({}) : title;
        var domProps = this.html && !isFunction$1(title) ? {
          innerHTML: title
        } : {};
        return h("div", {
          staticClass: "tooltip b-tooltip",
          class: this.templateClasses,
          attrs: this.templateAttributes,
          on: this.templateListeners
        }, [h("div", {
          staticClass: "arrow",
          ref: "arrow"
        }), h("div", {
          staticClass: "tooltip-inner",
          domProps
        }, [$title])]);
      }
    }
  });
  function ownKeys$s(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$s(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$s(Object(source), true).forEach(function(key) {
        _defineProperty$x(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$x(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODAL_SELECTOR = ".modal-content";
  var ROOT_EVENT_NAME_MODAL_HIDDEN = getRootEventName(NAME_MODAL, EVENT_NAME_HIDDEN);
  var SIDEBAR_SELECTOR = ".b-sidebar";
  var CONTAINER_SELECTOR = [MODAL_SELECTOR, SIDEBAR_SELECTOR].join(", ");
  var DROPDOWN_CLASS = "dropdown";
  var DROPDOWN_OPEN_SELECTOR = ".dropdown-menu.show";
  var DATA_TITLE_ATTR = "data-original-title";
  var templateData = {
    // Text string or Scoped slot function
    title: "",
    // Text string or Scoped slot function
    content: "",
    // String
    variant: null,
    // String, Array, Object
    customClass: null,
    // String or array of Strings (overwritten by BVPopper)
    triggers: "",
    // String (overwritten by BVPopper)
    placement: "auto",
    // String or array of strings
    fallbackPlacement: "flip",
    // Element or Component reference (or function that returns element) of
    // the element that will have the trigger events bound, and is also
    // default element for positioning
    target: null,
    // HTML ID, Element or Component reference
    container: null,
    // 'body'
    // Boolean
    noFade: false,
    // 'scrollParent', 'viewport', 'window', Element, or Component reference
    boundary: "scrollParent",
    // Tooltip/popover will try and stay away from
    // boundary edge by this many pixels (Number)
    boundaryPadding: 5,
    // Arrow offset (Number)
    offset: 0,
    // Hover/focus delay (Number or Object)
    delay: 0,
    // Arrow of Tooltip/popover will try and stay away from
    // the edge of tooltip/popover edge by this many pixels
    arrowPadding: 6,
    // Interactive state (Boolean)
    interactive: true,
    // Disabled state (Boolean)
    disabled: false,
    // ID to use for tooltip/popover
    id: null,
    // Flag used by directives only, for HTML content
    html: false
  };
  var BVTooltip = /* @__PURE__ */ extend({
    name: NAME_TOOLTIP_HELPER,
    mixins: [listenOnRootMixin, useParentMixin],
    data: function data() {
      return _objectSpread$s(_objectSpread$s({}, templateData), {}, {
        // State management data
        activeTrigger: {
          // manual: false,
          hover: false,
          click: false,
          focus: false
        },
        localShow: false
      });
    },
    computed: {
      templateType: function templateType() {
        return "tooltip";
      },
      computedId: function computedId() {
        return this.id || "__bv_".concat(this.templateType, "_").concat(this[COMPONENT_UID_KEY], "__");
      },
      computedDelay: function computedDelay() {
        var delay = {
          show: 0,
          hide: 0
        };
        if (isPlainObject(this.delay)) {
          delay.show = mathMax(toInteger(this.delay.show, 0), 0);
          delay.hide = mathMax(toInteger(this.delay.hide, 0), 0);
        } else if (isNumber(this.delay) || isString(this.delay)) {
          delay.show = delay.hide = mathMax(toInteger(this.delay, 0), 0);
        }
        return delay;
      },
      computedTriggers: function computedTriggers() {
        return concat(this.triggers).filter(identity).join(" ").trim().toLowerCase().split(/\s+/).sort();
      },
      isWithActiveTrigger: function isWithActiveTrigger() {
        for (var trigger in this.activeTrigger) {
          if (this.activeTrigger[trigger]) {
            return true;
          }
        }
        return false;
      },
      computedTemplateData: function computedTemplateData() {
        var title = this.title, content = this.content, variant = this.variant, customClass = this.customClass, noFade = this.noFade, interactive = this.interactive;
        return {
          title,
          content,
          variant,
          customClass,
          noFade,
          interactive
        };
      }
    },
    watch: {
      computedTriggers: function computedTriggers(newTriggers, oldTriggers) {
        var _this = this;
        if (!looseEqual(newTriggers, oldTriggers)) {
          this.$nextTick(function() {
            _this.unListen();
            oldTriggers.forEach(function(trigger) {
              if (!arrayIncludes(newTriggers, trigger)) {
                if (_this.activeTrigger[trigger]) {
                  _this.activeTrigger[trigger] = false;
                }
              }
            });
            _this.listen();
          });
        }
      },
      computedTemplateData: function computedTemplateData() {
        this.handleTemplateUpdate();
      },
      title: function title(newValue, oldValue) {
        if (newValue !== oldValue && !newValue) {
          this.hide();
        }
      },
      disabled: function disabled(newValue) {
        if (newValue) {
          this.disable();
        } else {
          this.enable();
        }
      }
    },
    created: function created() {
      var _this2 = this;
      this.$_tip = null;
      this.$_hoverTimeout = null;
      this.$_hoverState = "";
      this.$_visibleInterval = null;
      this.$_enabled = !this.disabled;
      this.$_noop = noop.bind(this);
      if (this.bvParent) {
        this.bvParent.$once(HOOK_EVENT_NAME_BEFORE_DESTROY, function() {
          _this2.$nextTick(function() {
            requestAF(function() {
              _this2.$destroy();
            });
          });
        });
      }
      this.$nextTick(function() {
        var target = _this2.getTarget();
        if (target && contains(document.body, target)) {
          _this2.scopeId = getScopeId(_this2.bvParent);
          _this2.listen();
        } else {
          warn(isString(_this2.target) ? 'Unable to find target element by ID "#'.concat(_this2.target, '" in document.') : "The provided target is no valid HTML element.", _this2.templateType);
        }
      });
    },
    /* istanbul ignore next */
    updated: function updated2() {
      this.$nextTick(this.handleTemplateUpdate);
    },
    /* istanbul ignore next */
    deactivated: function deactivated() {
      this.forceHide();
    },
    beforeDestroy: function beforeDestroy() {
      this.unListen();
      this.setWhileOpenListeners(false);
      this.clearHoverTimeout();
      this.clearVisibilityInterval();
      this.destroyTemplate();
      this.$_noop = null;
    },
    methods: {
      // --- Methods for creating and destroying the template ---
      getTemplate: function getTemplate() {
        return BVTooltipTemplate;
      },
      updateData: function updateData() {
        var _this3 = this;
        var data = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var titleUpdated = false;
        keys(templateData).forEach(function(prop2) {
          if (!isUndefined(data[prop2]) && _this3[prop2] !== data[prop2]) {
            _this3[prop2] = data[prop2];
            if (prop2 === "title") {
              titleUpdated = true;
            }
          }
        });
        if (titleUpdated && this.localShow) {
          this.fixTitle();
        }
      },
      createTemplateAndShow: function createTemplateAndShow() {
        var container = this.getContainer();
        var Template = this.getTemplate();
        var $tip = this.$_tip = createNewChildComponent(this, Template, {
          // The following is not reactive to changes in the props data
          propsData: {
            // These values cannot be changed while template is showing
            id: this.computedId,
            html: this.html,
            placement: this.placement,
            fallbackPlacement: this.fallbackPlacement,
            target: this.getPlacementTarget(),
            boundary: this.getBoundary(),
            // Ensure the following are integers
            offset: toInteger(this.offset, 0),
            arrowPadding: toInteger(this.arrowPadding, 0),
            boundaryPadding: toInteger(this.boundaryPadding, 0)
          }
        });
        this.handleTemplateUpdate();
        $tip.$once(EVENT_NAME_SHOW, this.onTemplateShow);
        $tip.$once(EVENT_NAME_SHOWN, this.onTemplateShown);
        $tip.$once(EVENT_NAME_HIDE, this.onTemplateHide);
        $tip.$once(EVENT_NAME_HIDDEN, this.onTemplateHidden);
        $tip.$once(HOOK_EVENT_NAME_DESTROYED, this.destroyTemplate);
        $tip.$on(EVENT_NAME_FOCUSIN, this.handleEvent);
        $tip.$on(EVENT_NAME_FOCUSOUT, this.handleEvent);
        $tip.$on(EVENT_NAME_MOUSEENTER, this.handleEvent);
        $tip.$on(EVENT_NAME_MOUSELEAVE, this.handleEvent);
        $tip.$mount(container.appendChild(document.createElement("div")));
      },
      hideTemplate: function hideTemplate() {
        this.$_tip && this.$_tip.hide();
        this.clearActiveTriggers();
        this.$_hoverState = "";
      },
      // Destroy the template instance and reset state
      destroyTemplate: function destroyTemplate() {
        this.setWhileOpenListeners(false);
        this.clearHoverTimeout();
        this.$_hoverState = "";
        this.clearActiveTriggers();
        this.localPlacementTarget = null;
        try {
          this.$_tip.$destroy();
        } catch (_unused) {
        }
        this.$_tip = null;
        this.removeAriaDescribedby();
        this.restoreTitle();
        this.localShow = false;
      },
      getTemplateElement: function getTemplateElement() {
        return this.$_tip ? this.$_tip.$el : null;
      },
      handleTemplateUpdate: function handleTemplateUpdate() {
        var _this4 = this;
        var $tip = this.$_tip;
        if ($tip) {
          var props2 = ["title", "content", "variant", "customClass", "noFade", "interactive"];
          props2.forEach(function(prop2) {
            if ($tip[prop2] !== _this4[prop2]) {
              $tip[prop2] = _this4[prop2];
            }
          });
        }
      },
      // --- Show/Hide handlers ---
      // Show the tooltip
      show: function show() {
        var target = this.getTarget();
        if (!target || !contains(document.body, target) || !isVisible(target) || this.dropdownOpen() || (isUndefinedOrNull(this.title) || this.title === "") && (isUndefinedOrNull(this.content) || this.content === "")) {
          return;
        }
        if (this.$_tip || this.localShow) {
          return;
        }
        this.localShow = true;
        var showEvent = this.buildEvent(EVENT_NAME_SHOW, {
          cancelable: true
        });
        this.emitEvent(showEvent);
        if (showEvent.defaultPrevented) {
          this.destroyTemplate();
          return;
        }
        this.fixTitle();
        this.addAriaDescribedby();
        this.createTemplateAndShow();
      },
      hide: function hide2() {
        var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var tip = this.getTemplateElement();
        if (!tip || !this.localShow) {
          this.restoreTitle();
          return;
        }
        var hideEvent = this.buildEvent(EVENT_NAME_HIDE, {
          cancelable: !force
        });
        this.emitEvent(hideEvent);
        if (hideEvent.defaultPrevented) {
          return;
        }
        this.hideTemplate();
      },
      forceHide: function forceHide() {
        var tip = this.getTemplateElement();
        if (!tip || !this.localShow) {
          return;
        }
        this.setWhileOpenListeners(false);
        this.clearHoverTimeout();
        this.$_hoverState = "";
        this.clearActiveTriggers();
        if (this.$_tip) {
          this.$_tip.noFade = true;
        }
        this.hide(true);
      },
      enable: function enable() {
        this.$_enabled = true;
        this.emitEvent(this.buildEvent(EVENT_NAME_ENABLED));
      },
      disable: function disable() {
        this.$_enabled = false;
        this.emitEvent(this.buildEvent(EVENT_NAME_DISABLED));
      },
      // --- Handlers for template events ---
      // When template is inserted into DOM, but not yet shown
      onTemplateShow: function onTemplateShow() {
        this.setWhileOpenListeners(true);
      },
      // When template show transition completes
      onTemplateShown: function onTemplateShown() {
        var prevHoverState = this.$_hoverState;
        this.$_hoverState = "";
        if (prevHoverState === "out") {
          this.leave(null);
        }
        this.emitEvent(this.buildEvent(EVENT_NAME_SHOWN));
      },
      // When template is starting to hide
      onTemplateHide: function onTemplateHide() {
        this.setWhileOpenListeners(false);
      },
      // When template has completed closing (just before it self destructs)
      onTemplateHidden: function onTemplateHidden() {
        this.destroyTemplate();
        this.emitEvent(this.buildEvent(EVENT_NAME_HIDDEN));
      },
      // --- Helper methods ---
      getTarget: function getTarget2() {
        var target = this.target;
        if (isString(target)) {
          target = getById(target.replace(/^#/, ""));
        } else if (isFunction$1(target)) {
          target = target();
        } else if (target) {
          target = target.$el || target;
        }
        return isElement(target) ? target : null;
      },
      getPlacementTarget: function getPlacementTarget() {
        return this.getTarget();
      },
      getTargetId: function getTargetId() {
        var target = this.getTarget();
        return target && target.id ? target.id : null;
      },
      getContainer: function getContainer() {
        var container = this.container ? this.container.$el || this.container : false;
        var body = document.body;
        var target = this.getTarget();
        return container === false ? closest(CONTAINER_SELECTOR, target) || body : (
          /*istanbul ignore next */
          isString(container) ? (
            /*istanbul ignore next */
            getById(container.replace(/^#/, "")) || body
          ) : (
            /*istanbul ignore next */
            body
          )
        );
      },
      getBoundary: function getBoundary() {
        return this.boundary ? this.boundary.$el || this.boundary : "scrollParent";
      },
      isInModal: function isInModal() {
        var target = this.getTarget();
        return target && closest(MODAL_SELECTOR, target);
      },
      isDropdown: function isDropdown() {
        var target = this.getTarget();
        return target && hasClass(target, DROPDOWN_CLASS);
      },
      dropdownOpen: function dropdownOpen() {
        var target = this.getTarget();
        return this.isDropdown() && target && select(DROPDOWN_OPEN_SELECTOR, target);
      },
      clearHoverTimeout: function clearHoverTimeout() {
        clearTimeout(this.$_hoverTimeout);
        this.$_hoverTimeout = null;
      },
      clearVisibilityInterval: function clearVisibilityInterval() {
        clearInterval(this.$_visibleInterval);
        this.$_visibleInterval = null;
      },
      clearActiveTriggers: function clearActiveTriggers() {
        for (var trigger in this.activeTrigger) {
          this.activeTrigger[trigger] = false;
        }
      },
      addAriaDescribedby: function addAriaDescribedby() {
        var target = this.getTarget();
        var desc = getAttr(target, "aria-describedby") || "";
        desc = desc.split(/\s+/).concat(this.computedId).join(" ").trim();
        setAttr(target, "aria-describedby", desc);
      },
      removeAriaDescribedby: function removeAriaDescribedby() {
        var _this5 = this;
        var target = this.getTarget();
        var desc = getAttr(target, "aria-describedby") || "";
        desc = desc.split(/\s+/).filter(function(d) {
          return d !== _this5.computedId;
        }).join(" ").trim();
        if (desc) {
          setAttr(target, "aria-describedby", desc);
        } else {
          removeAttr(target, "aria-describedby");
        }
      },
      fixTitle: function fixTitle() {
        var target = this.getTarget();
        if (hasAttr(target, "title")) {
          var title = getAttr(target, "title");
          setAttr(target, "title", "");
          if (title) {
            setAttr(target, DATA_TITLE_ATTR, title);
          }
        }
      },
      restoreTitle: function restoreTitle() {
        var target = this.getTarget();
        if (hasAttr(target, DATA_TITLE_ATTR)) {
          var title = getAttr(target, DATA_TITLE_ATTR);
          removeAttr(target, DATA_TITLE_ATTR);
          if (title) {
            setAttr(target, "title", title);
          }
        }
      },
      // --- BvEvent helpers ---
      buildEvent: function buildEvent(type) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return new BvEvent(type, _objectSpread$s({
          cancelable: false,
          target: this.getTarget(),
          relatedTarget: this.getTemplateElement() || null,
          componentId: this.computedId,
          vueTarget: this
        }, options));
      },
      emitEvent: function emitEvent(bvEvent) {
        var type = bvEvent.type;
        this.emitOnRoot(getRootEventName(this.templateType, type), bvEvent);
        this.$emit(type, bvEvent);
      },
      // --- Event handler setup methods ---
      listen: function listen() {
        var _this6 = this;
        var el = this.getTarget();
        if (!el) {
          return;
        }
        this.setRootListener(true);
        this.computedTriggers.forEach(function(trigger) {
          if (trigger === "click") {
            eventOn(el, "click", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          } else if (trigger === "focus") {
            eventOn(el, "focusin", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
            eventOn(el, "focusout", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          } else if (trigger === "blur") {
            eventOn(el, "focusout", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          } else if (trigger === "hover") {
            eventOn(el, "mouseenter", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
            eventOn(el, "mouseleave", _this6.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
          }
        }, this);
      },
      /* istanbul ignore next */
      unListen: function unListen() {
        var _this7 = this;
        var events = ["click", "focusin", "focusout", "mouseenter", "mouseleave"];
        var target = this.getTarget();
        this.setRootListener(false);
        events.forEach(function(event2) {
          target && eventOff(target, event2, _this7.handleEvent, EVENT_OPTIONS_NO_CAPTURE);
        }, this);
      },
      setRootListener: function setRootListener(on) {
        var method = on ? "listenOnRoot" : "listenOffRoot";
        var type = this.templateType;
        this[method](getRootActionEventName(type, EVENT_NAME_HIDE), this.doHide);
        this[method](getRootActionEventName(type, EVENT_NAME_SHOW), this.doShow);
        this[method](getRootActionEventName(type, EVENT_NAME_DISABLE), this.doDisable);
        this[method](getRootActionEventName(type, EVENT_NAME_ENABLE), this.doEnable);
      },
      setWhileOpenListeners: function setWhileOpenListeners(on) {
        this.setModalListener(on);
        this.setDropdownListener(on);
        this.visibleCheck(on);
        this.setOnTouchStartListener(on);
      },
      // Handler for periodic visibility check
      visibleCheck: function visibleCheck(on) {
        var _this8 = this;
        this.clearVisibilityInterval();
        var target = this.getTarget();
        if (on) {
          this.$_visibleInterval = setInterval(function() {
            var tip = _this8.getTemplateElement();
            if (tip && _this8.localShow && (!target.parentNode || !isVisible(target))) {
              _this8.forceHide();
            }
          }, 100);
        }
      },
      setModalListener: function setModalListener(on) {
        if (this.isInModal()) {
          this[on ? "listenOnRoot" : "listenOffRoot"](ROOT_EVENT_NAME_MODAL_HIDDEN, this.forceHide);
        }
      },
      /* istanbul ignore next: JSDOM doesn't support `ontouchstart` */
      setOnTouchStartListener: function setOnTouchStartListener(on) {
        var _this9 = this;
        if ("ontouchstart" in document.documentElement) {
          from(document.body.children).forEach(function(el) {
            eventOnOff(on, el, "mouseover", _this9.$_noop);
          });
        }
      },
      setDropdownListener: function setDropdownListener(on) {
        var target = this.getTarget();
        if (!target || !this.bvEventRoot || !this.isDropdown) {
          return;
        }
        var instance = getInstanceFromElement(target);
        if (instance) {
          instance[on ? "$on" : "$off"](EVENT_NAME_SHOWN, this.forceHide);
        }
      },
      // --- Event handlers ---
      handleEvent: function handleEvent(event2) {
        var target = this.getTarget();
        if (!target || isDisabled(target) || !this.$_enabled || this.dropdownOpen()) {
          return;
        }
        var type = event2.type;
        var triggers = this.computedTriggers;
        if (type === "click" && arrayIncludes(triggers, "click")) {
          this.click(event2);
        } else if (type === "mouseenter" && arrayIncludes(triggers, "hover")) {
          this.enter(event2);
        } else if (type === "focusin" && arrayIncludes(triggers, "focus")) {
          this.enter(event2);
        } else if (type === "focusout" && (arrayIncludes(triggers, "focus") || arrayIncludes(triggers, "blur")) || type === "mouseleave" && arrayIncludes(triggers, "hover")) {
          var tip = this.getTemplateElement();
          var eventTarget = event2.target;
          var relatedTarget = event2.relatedTarget;
          if (
            // From tip to target
            tip && contains(tip, eventTarget) && contains(target, relatedTarget) || // From target to tip
            tip && contains(target, eventTarget) && contains(tip, relatedTarget) || // Within tip
            tip && contains(tip, eventTarget) && contains(tip, relatedTarget) || // Within target
            contains(target, eventTarget) && contains(target, relatedTarget)
          ) {
            return;
          }
          this.leave(event2);
        }
      },
      doHide: function doHide(id) {
        if (!id || this.getTargetId() === id || this.computedId === id) {
          this.forceHide();
        }
      },
      doShow: function doShow(id) {
        if (!id || this.getTargetId() === id || this.computedId === id) {
          this.show();
        }
      },
      /*istanbul ignore next: ignore for now */
      doDisable: function doDisable(id) {
        if (!id || this.getTargetId() === id || this.computedId === id) {
          this.disable();
        }
      },
      /*istanbul ignore next: ignore for now */
      doEnable: function doEnable(id) {
        if (!id || this.getTargetId() === id || this.computedId === id) {
          this.enable();
        }
      },
      click: function click(event2) {
        if (!this.$_enabled || this.dropdownOpen()) {
          return;
        }
        attemptFocus(event2.currentTarget);
        this.activeTrigger.click = !this.activeTrigger.click;
        if (this.isWithActiveTrigger) {
          this.enter(null);
        } else {
          this.leave(null);
        }
      },
      /* istanbul ignore next */
      toggle: function toggle() {
        if (!this.$_enabled || this.dropdownOpen()) {
          return;
        }
        if (this.localShow) {
          this.leave(null);
        } else {
          this.enter(null);
        }
      },
      enter: function enter() {
        var _this10 = this;
        var event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        if (event2) {
          this.activeTrigger[event2.type === "focusin" ? "focus" : "hover"] = true;
        }
        if (this.localShow || this.$_hoverState === "in") {
          this.$_hoverState = "in";
          return;
        }
        this.clearHoverTimeout();
        this.$_hoverState = "in";
        if (!this.computedDelay.show) {
          this.show();
        } else {
          this.fixTitle();
          this.$_hoverTimeout = setTimeout(function() {
            if (_this10.$_hoverState === "in") {
              _this10.show();
            } else if (!_this10.localShow) {
              _this10.restoreTitle();
            }
          }, this.computedDelay.show);
        }
      },
      leave: function leave() {
        var _this11 = this;
        var event2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        if (event2) {
          this.activeTrigger[event2.type === "focusout" ? "focus" : "hover"] = false;
          if (event2.type === "focusout" && arrayIncludes(this.computedTriggers, "blur")) {
            this.activeTrigger.click = false;
            this.activeTrigger.hover = false;
          }
        }
        if (this.isWithActiveTrigger) {
          return;
        }
        this.clearHoverTimeout();
        this.$_hoverState = "out";
        if (!this.computedDelay.hide) {
          this.hide();
        } else {
          this.$_hoverTimeout = setTimeout(function() {
            if (_this11.$_hoverState === "out") {
              _this11.hide();
            }
          }, this.computedDelay.hide);
        }
      }
    }
  });
  var _makePropsConfigurabl, _watch$5;
  function ownKeys$r(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$r(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$r(Object(source), true).forEach(function(key) {
        _defineProperty$w(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$w(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_ENABLED = "disabled";
  var MODEL_EVENT_NAME_ENABLED = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_ENABLED;
  var MODEL_PROP_NAME_SHOW = "show";
  var MODEL_EVENT_NAME_SHOW = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_SHOW;
  var props$E = makePropsConfigurable((_makePropsConfigurabl = {
    // String: scrollParent, window, or viewport
    // Element: element reference
    // Object: Vue component
    boundary: makeProp([HTMLElement, PROP_TYPE_OBJECT, PROP_TYPE_STRING], "scrollParent"),
    boundaryPadding: makeProp(PROP_TYPE_NUMBER_STRING, 50),
    // String: HTML ID of container, if null body is used (default)
    // HTMLElement: element reference reference
    // Object: Vue Component
    container: makeProp([HTMLElement, PROP_TYPE_OBJECT, PROP_TYPE_STRING]),
    customClass: makeProp(PROP_TYPE_STRING),
    delay: makeProp(PROP_TYPE_NUMBER_OBJECT_STRING, 50)
  }, _defineProperty$w(_makePropsConfigurabl, MODEL_PROP_NAME_ENABLED, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$w(_makePropsConfigurabl, "fallbackPlacement", makeProp(PROP_TYPE_ARRAY_STRING, "flip")), _defineProperty$w(_makePropsConfigurabl, "id", makeProp(PROP_TYPE_STRING)), _defineProperty$w(_makePropsConfigurabl, "noFade", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$w(_makePropsConfigurabl, "noninteractive", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$w(_makePropsConfigurabl, "offset", makeProp(PROP_TYPE_NUMBER_STRING, 0)), _defineProperty$w(_makePropsConfigurabl, "placement", makeProp(PROP_TYPE_STRING, "top")), _defineProperty$w(_makePropsConfigurabl, MODEL_PROP_NAME_SHOW, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$w(_makePropsConfigurabl, "target", makeProp([HTMLElement, SVGElement, PROP_TYPE_FUNCTION, PROP_TYPE_OBJECT, PROP_TYPE_STRING], void 0, true)), _defineProperty$w(_makePropsConfigurabl, "title", makeProp(PROP_TYPE_STRING)), _defineProperty$w(_makePropsConfigurabl, "triggers", makeProp(PROP_TYPE_ARRAY_STRING, "hover focus")), _defineProperty$w(_makePropsConfigurabl, "variant", makeProp(PROP_TYPE_STRING)), _makePropsConfigurabl), NAME_TOOLTIP);
  var BTooltip = /* @__PURE__ */ extend({
    name: NAME_TOOLTIP,
    mixins: [normalizeSlotMixin, useParentMixin],
    inheritAttrs: false,
    props: props$E,
    data: function data() {
      return {
        localShow: this[MODEL_PROP_NAME_SHOW],
        localTitle: "",
        localContent: ""
      };
    },
    computed: {
      // Data that will be passed to the template and popper
      templateData: function templateData2() {
        return _objectSpread$r({
          title: this.localTitle,
          content: this.localContent,
          interactive: !this.noninteractive
        }, pick$1(this.$props, ["boundary", "boundaryPadding", "container", "customClass", "delay", "fallbackPlacement", "id", "noFade", "offset", "placement", "target", "target", "triggers", "variant", MODEL_PROP_NAME_ENABLED]));
      },
      // Used to watch for changes to the title and content props
      templateTitleContent: function templateTitleContent() {
        var title = this.title, content = this.content;
        return {
          title,
          content
        };
      }
    },
    watch: (_watch$5 = {}, _defineProperty$w(_watch$5, MODEL_PROP_NAME_SHOW, function(newValue, oldValue) {
      if (newValue !== oldValue && newValue !== this.localShow && this.$_toolpop) {
        if (newValue) {
          this.$_toolpop.show();
        } else {
          this.$_toolpop.forceHide();
        }
      }
    }), _defineProperty$w(_watch$5, MODEL_PROP_NAME_ENABLED, function(newValue) {
      if (newValue) {
        this.doDisable();
      } else {
        this.doEnable();
      }
    }), _defineProperty$w(_watch$5, "localShow", function localShow(newValue) {
      this.$emit(MODEL_EVENT_NAME_SHOW, newValue);
    }), _defineProperty$w(_watch$5, "templateData", function templateData2() {
      var _this = this;
      this.$nextTick(function() {
        if (_this.$_toolpop) {
          _this.$_toolpop.updateData(_this.templateData);
        }
      });
    }), _defineProperty$w(_watch$5, "templateTitleContent", function templateTitleContent() {
      this.$nextTick(this.updateContent);
    }), _watch$5),
    created: function created() {
      this.$_toolpop = null;
    },
    updated: function updated2() {
      this.$nextTick(this.updateContent);
    },
    beforeDestroy: function beforeDestroy() {
      this.$off(EVENT_NAME_OPEN, this.doOpen);
      this.$off(EVENT_NAME_CLOSE, this.doClose);
      this.$off(EVENT_NAME_DISABLE, this.doDisable);
      this.$off(EVENT_NAME_ENABLE, this.doEnable);
      if (this.$_toolpop) {
        this.$_toolpop.$destroy();
        this.$_toolpop = null;
      }
    },
    mounted: function mounted() {
      var _this2 = this;
      this.$nextTick(function() {
        var Component = _this2.getComponent();
        _this2.updateContent();
        var scopeId = getScopeId(_this2) || getScopeId(_this2.bvParent);
        var $toolpop = _this2.$_toolpop = createNewChildComponent(_this2, Component, {
          // Pass down the scoped style ID
          _scopeId: scopeId || void 0
        });
        $toolpop.updateData(_this2.templateData);
        $toolpop.$on(EVENT_NAME_SHOW, _this2.onShow);
        $toolpop.$on(EVENT_NAME_SHOWN, _this2.onShown);
        $toolpop.$on(EVENT_NAME_HIDE, _this2.onHide);
        $toolpop.$on(EVENT_NAME_HIDDEN, _this2.onHidden);
        $toolpop.$on(EVENT_NAME_DISABLED, _this2.onDisabled);
        $toolpop.$on(EVENT_NAME_ENABLED, _this2.onEnabled);
        if (_this2[MODEL_PROP_NAME_ENABLED]) {
          _this2.doDisable();
        }
        _this2.$on(EVENT_NAME_OPEN, _this2.doOpen);
        _this2.$on(EVENT_NAME_CLOSE, _this2.doClose);
        _this2.$on(EVENT_NAME_DISABLE, _this2.doDisable);
        _this2.$on(EVENT_NAME_ENABLE, _this2.doEnable);
        if (_this2.localShow) {
          $toolpop.show();
        }
      });
    },
    methods: {
      getComponent: function getComponent() {
        return BVTooltip;
      },
      updateContent: function updateContent() {
        this.setTitle(this.normalizeSlot() || this.title);
      },
      // Helper methods for `updateContent()`
      setTitle: function setTitle(value) {
        value = isUndefinedOrNull(value) ? "" : value;
        if (this.localTitle !== value) {
          this.localTitle = value;
        }
      },
      setContent: function setContent(value) {
        value = isUndefinedOrNull(value) ? "" : value;
        if (this.localContent !== value) {
          this.localContent = value;
        }
      },
      // --- Template event handlers ---
      onShow: function onShow(bvEvent) {
        this.$emit(EVENT_NAME_SHOW, bvEvent);
        if (bvEvent) {
          this.localShow = !bvEvent.defaultPrevented;
        }
      },
      onShown: function onShown(bvEvent) {
        this.localShow = true;
        this.$emit(EVENT_NAME_SHOWN, bvEvent);
      },
      onHide: function onHide2(bvEvent) {
        this.$emit(EVENT_NAME_HIDE, bvEvent);
      },
      onHidden: function onHidden(bvEvent) {
        this.$emit(EVENT_NAME_HIDDEN, bvEvent);
        this.localShow = false;
      },
      onDisabled: function onDisabled(bvEvent) {
        if (bvEvent && bvEvent.type === EVENT_NAME_DISABLED) {
          this.$emit(MODEL_EVENT_NAME_ENABLED, true);
          this.$emit(EVENT_NAME_DISABLED, bvEvent);
        }
      },
      onEnabled: function onEnabled(bvEvent) {
        if (bvEvent && bvEvent.type === EVENT_NAME_ENABLED) {
          this.$emit(MODEL_EVENT_NAME_ENABLED, false);
          this.$emit(EVENT_NAME_ENABLED, bvEvent);
        }
      },
      // --- Local event listeners ---
      doOpen: function doOpen() {
        !this.localShow && this.$_toolpop && this.$_toolpop.show();
      },
      doClose: function doClose() {
        this.localShow && this.$_toolpop && this.$_toolpop.hide();
      },
      doDisable: function doDisable() {
        this.$_toolpop && this.$_toolpop.disable();
      },
      doEnable: function doEnable() {
        this.$_toolpop && this.$_toolpop.enable();
      }
    },
    render: function render(h) {
      return h();
    }
  });
  var BVPopoverTemplate = /* @__PURE__ */ extend({
    name: NAME_POPOVER_TEMPLATE,
    extends: BVTooltipTemplate,
    computed: {
      templateType: function templateType() {
        return "popover";
      }
    },
    methods: {
      renderTemplate: function renderTemplate(h) {
        var title = this.title, content = this.content;
        var $title = isFunction$1(title) ? title({}) : title;
        var $content = isFunction$1(content) ? content({}) : content;
        var titleDomProps = this.html && !isFunction$1(title) ? {
          innerHTML: title
        } : {};
        var contentDomProps = this.html && !isFunction$1(content) ? {
          innerHTML: content
        } : {};
        return h("div", {
          staticClass: "popover b-popover",
          class: this.templateClasses,
          attrs: this.templateAttributes,
          on: this.templateListeners
        }, [h("div", {
          staticClass: "arrow",
          ref: "arrow"
        }), isUndefinedOrNull($title) || $title === "" ? (
          /* istanbul ignore next */
          h()
        ) : h("h3", {
          staticClass: "popover-header",
          domProps: titleDomProps
        }, [$title]), isUndefinedOrNull($content) || $content === "" ? (
          /* istanbul ignore next */
          h()
        ) : h("div", {
          staticClass: "popover-body",
          domProps: contentDomProps
        }, [$content])]);
      }
    }
  });
  var BVPopover = /* @__PURE__ */ extend({
    name: NAME_POPOVER_HELPER,
    extends: BVTooltip,
    computed: {
      // Overwrites BVTooltip
      templateType: function templateType() {
        return "popover";
      }
    },
    methods: {
      getTemplate: function getTemplate() {
        return BVPopoverTemplate;
      }
    }
  });
  function ownKeys$q(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$q(Object(source), true).forEach(function(key) {
        _defineProperty$v(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$v(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$D = makePropsConfigurable(sortKeys(_objectSpread$q(_objectSpread$q({}, props$E), {}, {
    content: makeProp(PROP_TYPE_STRING),
    placement: makeProp(PROP_TYPE_STRING, "right"),
    triggers: makeProp(PROP_TYPE_ARRAY_STRING, EVENT_NAME_CLICK)
  })), NAME_POPOVER);
  var BPopover = /* @__PURE__ */ extend({
    name: NAME_POPOVER,
    extends: BTooltip,
    inheritAttrs: false,
    props: props$D,
    methods: {
      getComponent: function getComponent() {
        return BVPopover;
      },
      updateContent: function updateContent() {
        this.setContent(this.normalizeSlot() || this.content);
        this.setTitle(this.normalizeSlot(SLOT_NAME_TITLE) || this.title);
      }
    }
    // Render function provided by BTooltip
  });
  function ownKeys$p(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$p(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$p(Object(source), true).forEach(function(key) {
        _defineProperty$u(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$u(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BV_POPOVER = "__BV_Popover__";
  var DefaultTrigger$1 = "click";
  var validTriggers$1 = {
    focus: true,
    hover: true,
    click: true,
    blur: true,
    manual: true
  };
  var htmlRE$1 = /^html$/i;
  var noFadeRE$1 = /^nofade$/i;
  var placementRE$1 = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
  var boundaryRE$1 = /^(window|viewport|scrollParent)$/i;
  var delayRE$1 = /^d\d+$/i;
  var delayShowRE$1 = /^ds\d+$/i;
  var delayHideRE$1 = /^dh\d+$/i;
  var offsetRE$2 = /^o-?\d+$/i;
  var variantRE$1 = /^v-.+$/i;
  var spacesRE$1 = /\s+/;
  var parseBindings$2 = function parseBindings2(bindings, vnode) {
    var config = {
      title: void 0,
      content: void 0,
      trigger: "",
      // Default set below if needed
      placement: "right",
      fallbackPlacement: "flip",
      container: false,
      // Default of body
      animation: true,
      offset: 0,
      disabled: false,
      id: null,
      html: false,
      delay: getComponentConfig(NAME_POPOVER, "delay", 50),
      boundary: String(getComponentConfig(NAME_POPOVER, "boundary", "scrollParent")),
      boundaryPadding: toInteger(getComponentConfig(NAME_POPOVER, "boundaryPadding", 5), 0),
      variant: getComponentConfig(NAME_POPOVER, "variant"),
      customClass: getComponentConfig(NAME_POPOVER, "customClass")
    };
    if (isString(bindings.value) || isNumber(bindings.value)) {
      config.content = bindings.value;
    } else if (isFunction$1(bindings.value)) {
      config.content = bindings.value;
    } else if (isPlainObject(bindings.value)) {
      config = _objectSpread$p(_objectSpread$p({}, config), bindings.value);
    }
    if (bindings.arg) {
      config.container = "#".concat(bindings.arg);
    }
    if (isUndefined(config.title)) {
      var data = vnode.data || {};
      config.title = data.attrs && !isUndefinedOrNull(data.attrs.title) ? data.attrs.title : void 0;
    }
    if (!isPlainObject(config.delay)) {
      config.delay = {
        show: toInteger(config.delay, 0),
        hide: toInteger(config.delay, 0)
      };
    }
    keys(bindings.modifiers).forEach(function(mod) {
      if (htmlRE$1.test(mod)) {
        config.html = true;
      } else if (noFadeRE$1.test(mod)) {
        config.animation = false;
      } else if (placementRE$1.test(mod)) {
        config.placement = mod;
      } else if (boundaryRE$1.test(mod)) {
        mod = mod === "scrollparent" ? "scrollParent" : mod;
        config.boundary = mod;
      } else if (delayRE$1.test(mod)) {
        var delay = toInteger(mod.slice(1), 0);
        config.delay.show = delay;
        config.delay.hide = delay;
      } else if (delayShowRE$1.test(mod)) {
        config.delay.show = toInteger(mod.slice(2), 0);
      } else if (delayHideRE$1.test(mod)) {
        config.delay.hide = toInteger(mod.slice(2), 0);
      } else if (offsetRE$2.test(mod)) {
        config.offset = toInteger(mod.slice(1), 0);
      } else if (variantRE$1.test(mod)) {
        config.variant = mod.slice(2) || null;
      }
    });
    var selectedTriggers = {};
    concat(config.trigger || "").filter(identity).join(" ").trim().toLowerCase().split(spacesRE$1).forEach(function(trigger) {
      if (validTriggers$1[trigger]) {
        selectedTriggers[trigger] = true;
      }
    });
    keys(bindings.modifiers).forEach(function(mod) {
      mod = mod.toLowerCase();
      if (validTriggers$1[mod]) {
        selectedTriggers[mod] = true;
      }
    });
    config.trigger = keys(selectedTriggers).join(" ");
    if (config.trigger === "blur") {
      config.trigger = "focus";
    }
    if (!config.trigger) {
      config.trigger = DefaultTrigger$1;
    }
    return config;
  };
  var applyPopover = function applyPopover2(el, bindings, vnode) {
    if (!IS_BROWSER) {
      return;
    }
    var config = parseBindings$2(bindings, vnode);
    if (!el[BV_POPOVER]) {
      var parent = getInstanceFromDirective(vnode, bindings);
      el[BV_POPOVER] = createNewChildComponent(parent, BVPopover, {
        // Add the parent's scoped style attribute data
        _scopeId: getScopeId(parent, void 0)
      });
      el[BV_POPOVER].__bv_prev_data__ = {};
      el[BV_POPOVER].$on(EVENT_NAME_SHOW, function() {
        var data2 = {};
        if (isFunction$1(config.title)) {
          data2.title = config.title(el);
        }
        if (isFunction$1(config.content)) {
          data2.content = config.content(el);
        }
        if (keys(data2).length > 0) {
          el[BV_POPOVER].updateData(data2);
        }
      });
    }
    var data = {
      title: config.title,
      content: config.content,
      triggers: config.trigger,
      placement: config.placement,
      fallbackPlacement: config.fallbackPlacement,
      variant: config.variant,
      customClass: config.customClass,
      container: config.container,
      boundary: config.boundary,
      delay: config.delay,
      offset: config.offset,
      noFade: !config.animation,
      id: config.id,
      disabled: config.disabled,
      html: config.html
    };
    var oldData = el[BV_POPOVER].__bv_prev_data__;
    el[BV_POPOVER].__bv_prev_data__ = data;
    if (!looseEqual(data, oldData)) {
      var newData = {
        target: el
      };
      keys(data).forEach(function(prop2) {
        if (data[prop2] !== oldData[prop2]) {
          newData[prop2] = (prop2 === "title" || prop2 === "content") && isFunction$1(data[prop2]) ? (
            /* istanbul ignore next */
            data[prop2](el)
          ) : data[prop2];
        }
      });
      el[BV_POPOVER].updateData(newData);
    }
  };
  var removePopover = function removePopover2(el) {
    if (el[BV_POPOVER]) {
      el[BV_POPOVER].$destroy();
      el[BV_POPOVER] = null;
    }
    delete el[BV_POPOVER];
  };
  var VBPopover = {
    bind: function bind2(el, bindings, vnode) {
      applyPopover(el, bindings, vnode);
    },
    // We use `componentUpdated` here instead of `update`, as the former
    // waits until the containing component and children have finished updating
    componentUpdated: function componentUpdated2(el, bindings, vnode) {
      nextTick(function() {
        applyPopover(el, bindings, vnode);
      });
    },
    unbind: function unbind2(el) {
      removePopover(el);
    }
  };
  var VBPopoverPlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBPopover
    }
  });
  var PopoverPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BPopover
    },
    plugins: {
      VBPopoverPlugin
    }
  });
  var props$C = makePropsConfigurable({
    animated: makeProp(PROP_TYPE_BOOLEAN, null),
    label: makeProp(PROP_TYPE_STRING),
    labelHtml: makeProp(PROP_TYPE_STRING),
    max: makeProp(PROP_TYPE_NUMBER_STRING, null),
    precision: makeProp(PROP_TYPE_NUMBER_STRING, null),
    showProgress: makeProp(PROP_TYPE_BOOLEAN, null),
    showValue: makeProp(PROP_TYPE_BOOLEAN, null),
    striped: makeProp(PROP_TYPE_BOOLEAN, null),
    value: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_PROGRESS_BAR);
  var BProgressBar = /* @__PURE__ */ extend({
    name: NAME_PROGRESS_BAR,
    mixins: [normalizeSlotMixin],
    inject: {
      getBvProgress: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    props: props$C,
    computed: {
      bvProgress: function bvProgress() {
        return this.getBvProgress();
      },
      progressBarClasses: function progressBarClasses() {
        var computedAnimated = this.computedAnimated, computedVariant = this.computedVariant;
        return [computedVariant ? "bg-".concat(computedVariant) : "", this.computedStriped || computedAnimated ? "progress-bar-striped" : "", computedAnimated ? "progress-bar-animated" : ""];
      },
      progressBarStyles: function progressBarStyles() {
        return {
          width: 100 * (this.computedValue / this.computedMax) + "%"
        };
      },
      computedValue: function computedValue() {
        return toFloat(this.value, 0);
      },
      computedMax: function computedMax() {
        var max = toFloat(this.max) || toFloat(this.bvProgress.max, 0);
        return max > 0 ? max : 100;
      },
      computedPrecision: function computedPrecision() {
        return mathMax(toInteger(this.precision, toInteger(this.bvProgress.precision, 0)), 0);
      },
      computedProgress: function computedProgress() {
        var precision = this.computedPrecision;
        var p = mathPow(10, precision);
        return toFixed(100 * p * this.computedValue / this.computedMax / p, precision);
      },
      computedVariant: function computedVariant() {
        return this.variant || this.bvProgress.variant;
      },
      computedStriped: function computedStriped() {
        return isBoolean(this.striped) ? this.striped : this.bvProgress.striped || false;
      },
      computedAnimated: function computedAnimated() {
        return isBoolean(this.animated) ? this.animated : this.bvProgress.animated || false;
      },
      computedShowProgress: function computedShowProgress() {
        return isBoolean(this.showProgress) ? this.showProgress : this.bvProgress.showProgress || false;
      },
      computedShowValue: function computedShowValue() {
        return isBoolean(this.showValue) ? this.showValue : this.bvProgress.showValue || false;
      }
    },
    render: function render(h) {
      var label = this.label, labelHtml = this.labelHtml, computedValue = this.computedValue, computedPrecision = this.computedPrecision;
      var $children;
      var domProps = {};
      if (this.hasNormalizedSlot()) {
        $children = this.normalizeSlot();
      } else if (label || labelHtml) {
        domProps = htmlOrText(labelHtml, label);
      } else if (this.computedShowProgress) {
        $children = this.computedProgress;
      } else if (this.computedShowValue) {
        $children = toFixed(computedValue, computedPrecision);
      }
      return h("div", {
        staticClass: "progress-bar",
        class: this.progressBarClasses,
        style: this.progressBarStyles,
        attrs: {
          role: "progressbar",
          "aria-valuemin": "0",
          "aria-valuemax": toString(this.computedMax),
          "aria-valuenow": toFixed(computedValue, computedPrecision)
        },
        domProps
      }, $children);
    }
  });
  function ownKeys$o(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$o(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$o(Object(source), true).forEach(function(key) {
        _defineProperty$t(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$t(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var progressBarProps = omit(props$C, ["label", "labelHtml"]);
  var props$B = makePropsConfigurable(sortKeys(_objectSpread$o(_objectSpread$o({}, progressBarProps), {}, {
    animated: makeProp(PROP_TYPE_BOOLEAN, false),
    height: makeProp(PROP_TYPE_STRING),
    max: makeProp(PROP_TYPE_NUMBER_STRING, 100),
    precision: makeProp(PROP_TYPE_NUMBER_STRING, 0),
    showProgress: makeProp(PROP_TYPE_BOOLEAN, false),
    showValue: makeProp(PROP_TYPE_BOOLEAN, false),
    striped: makeProp(PROP_TYPE_BOOLEAN, false)
  })), NAME_PROGRESS);
  var BProgress = /* @__PURE__ */ extend({
    name: NAME_PROGRESS,
    mixins: [normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvProgress: function getBvProgress() {
          return _this;
        }
      };
    },
    props: props$B,
    computed: {
      progressHeight: function progressHeight() {
        return {
          height: this.height || null
        };
      }
    },
    render: function render(h) {
      var $childNodes = this.normalizeSlot();
      if (!$childNodes) {
        $childNodes = h(BProgressBar, {
          props: pluckProps(progressBarProps, this.$props)
        });
      }
      return h("div", {
        staticClass: "progress",
        style: this.progressHeight
      }, [$childNodes]);
    }
  });
  var ProgressPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BProgress,
      BProgressBar
    }
  });
  var _watch$4;
  function ownKeys$n(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$n(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$n(Object(source), true).forEach(function(key) {
        _defineProperty$s(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$s(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var CLASS_NAME = "b-sidebar";
  var ROOT_ACTION_EVENT_NAME_REQUEST_STATE = getRootActionEventName(NAME_COLLAPSE, "request-state");
  var ROOT_ACTION_EVENT_NAME_TOGGLE = getRootActionEventName(NAME_COLLAPSE, "toggle");
  var ROOT_EVENT_NAME_STATE = getRootEventName(NAME_COLLAPSE, "state");
  var ROOT_EVENT_NAME_SYNC_STATE = getRootEventName(NAME_COLLAPSE, "sync-state");
  var _makeModelMixin$3 = makeModelMixin("visible", {
    type: PROP_TYPE_BOOLEAN,
    defaultValue: false,
    event: EVENT_NAME_CHANGE
  }), modelMixin$3 = _makeModelMixin$3.mixin, modelProps$3 = _makeModelMixin$3.props, MODEL_PROP_NAME$3 = _makeModelMixin$3.prop, MODEL_EVENT_NAME$3 = _makeModelMixin$3.event;
  var props$A = makePropsConfigurable(sortKeys(_objectSpread$n(_objectSpread$n(_objectSpread$n({}, props$25), modelProps$3), {}, {
    ariaLabel: makeProp(PROP_TYPE_STRING),
    ariaLabelledby: makeProp(PROP_TYPE_STRING),
    // If `true`, shows a basic backdrop
    backdrop: makeProp(PROP_TYPE_BOOLEAN, false),
    backdropVariant: makeProp(PROP_TYPE_STRING, "dark"),
    bgVariant: makeProp(PROP_TYPE_STRING, "light"),
    bodyClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // `aria-label` for close button
    closeLabel: makeProp(PROP_TYPE_STRING),
    footerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    footerTag: makeProp(PROP_TYPE_STRING, "footer"),
    headerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    noCloseOnBackdrop: makeProp(PROP_TYPE_BOOLEAN, false),
    noCloseOnEsc: makeProp(PROP_TYPE_BOOLEAN, false),
    noCloseOnRouteChange: makeProp(PROP_TYPE_BOOLEAN, false),
    noEnforceFocus: makeProp(PROP_TYPE_BOOLEAN, false),
    noHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    noHeaderClose: makeProp(PROP_TYPE_BOOLEAN, false),
    noSlide: makeProp(PROP_TYPE_BOOLEAN, false),
    right: makeProp(PROP_TYPE_BOOLEAN, false),
    shadow: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    sidebarClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    tag: makeProp(PROP_TYPE_STRING, "div"),
    textVariant: makeProp(PROP_TYPE_STRING, "dark"),
    title: makeProp(PROP_TYPE_STRING),
    width: makeProp(PROP_TYPE_STRING),
    zIndex: makeProp(PROP_TYPE_NUMBER_STRING)
  })), NAME_SIDEBAR);
  var renderHeaderTitle = function renderHeaderTitle2(h, ctx) {
    var title = ctx.normalizeSlot(SLOT_NAME_TITLE, ctx.slotScope) || ctx.title;
    if (!title) {
      return h("span");
    }
    return h("strong", {
      attrs: {
        id: ctx.safeId("__title__")
      }
    }, [title]);
  };
  var renderHeaderClose = function renderHeaderClose2(h, ctx) {
    if (ctx.noHeaderClose) {
      return h();
    }
    var closeLabel = ctx.closeLabel, textVariant = ctx.textVariant, hide2 = ctx.hide;
    return h(BButtonClose, {
      props: {
        ariaLabel: closeLabel,
        textVariant
      },
      on: {
        click: hide2
      },
      ref: "close-button"
    }, [ctx.normalizeSlot(SLOT_NAME_HEADER_CLOSE) || h(BIconX)]);
  };
  var renderHeader = function renderHeader2(h, ctx) {
    if (ctx.noHeader) {
      return h();
    }
    var $content = ctx.normalizeSlot(SLOT_NAME_HEADER, ctx.slotScope);
    if (!$content) {
      var $title = renderHeaderTitle(h, ctx);
      var $close = renderHeaderClose(h, ctx);
      $content = ctx.right ? [$close, $title] : [$title, $close];
    }
    return h(ctx.headerTag, {
      staticClass: "".concat(CLASS_NAME, "-header"),
      class: ctx.headerClass,
      key: "header"
    }, $content);
  };
  var renderBody = function renderBody2(h, ctx) {
    return h("div", {
      staticClass: "".concat(CLASS_NAME, "-body"),
      class: ctx.bodyClass,
      key: "body"
    }, [ctx.normalizeSlot(SLOT_NAME_DEFAULT, ctx.slotScope)]);
  };
  var renderFooter = function renderFooter2(h, ctx) {
    var $footer = ctx.normalizeSlot(SLOT_NAME_FOOTER, ctx.slotScope);
    if (!$footer) {
      return h();
    }
    return h(ctx.footerTag, {
      staticClass: "".concat(CLASS_NAME, "-footer"),
      class: ctx.footerClass,
      key: "footer"
    }, [$footer]);
  };
  var renderContent = function renderContent2(h, ctx) {
    var $header = renderHeader(h, ctx);
    if (ctx.lazy && !ctx.isOpen) {
      return $header;
    }
    return [$header, renderBody(h, ctx), renderFooter(h, ctx)];
  };
  var renderBackdrop = function renderBackdrop2(h, ctx) {
    if (!ctx.backdrop) {
      return h();
    }
    var backdropVariant = ctx.backdropVariant;
    return h("div", {
      directives: [{
        name: "show",
        value: ctx.localShow
      }],
      staticClass: "b-sidebar-backdrop",
      class: _defineProperty$s({}, "bg-".concat(backdropVariant), backdropVariant),
      on: {
        click: ctx.onBackdropClick
      }
    });
  };
  var BSidebar = /* @__PURE__ */ extend({
    name: NAME_SIDEBAR,
    mixins: [attrsMixin, idMixin, modelMixin$3, listenOnRootMixin, normalizeSlotMixin],
    inheritAttrs: false,
    props: props$A,
    data: function data() {
      var visible = !!this[MODEL_PROP_NAME$3];
      return {
        // Internal `v-model` state
        localShow: visible,
        // For lazy render triggering
        isOpen: visible
      };
    },
    computed: {
      transitionProps: function transitionProps() {
        return this.noSlide ? (
          /* istanbul ignore next */
          {
            css: true
          }
        ) : {
          css: true,
          enterClass: "",
          enterActiveClass: "slide",
          enterToClass: "show",
          leaveClass: "show",
          leaveActiveClass: "slide",
          leaveToClass: ""
        };
      },
      slotScope: function slotScope() {
        var hide2 = this.hide, right = this.right, visible = this.localShow;
        return {
          hide: hide2,
          right,
          visible
        };
      },
      hasTitle: function hasTitle() {
        var $scopedSlots = this.$scopedSlots, $slots = this.$slots;
        return !this.noHeader && !this.hasNormalizedSlot(SLOT_NAME_HEADER) && !!(this.normalizeSlot(SLOT_NAME_TITLE, this.slotScope, $scopedSlots, $slots) || this.title);
      },
      titleId: function titleId() {
        return this.hasTitle ? this.safeId("__title__") : null;
      },
      computedAttrs: function computedAttrs() {
        return _objectSpread$n(_objectSpread$n({}, this.bvAttrs), {}, {
          id: this.safeId(),
          tabindex: "-1",
          role: "dialog",
          "aria-modal": this.backdrop ? "true" : "false",
          "aria-hidden": this.localShow ? null : "true",
          "aria-label": this.ariaLabel || null,
          "aria-labelledby": this.ariaLabelledby || this.titleId || null
        });
      }
    },
    watch: (_watch$4 = {}, _defineProperty$s(_watch$4, MODEL_PROP_NAME$3, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.localShow = newValue;
      }
    }), _defineProperty$s(_watch$4, "localShow", function localShow(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.emitState(newValue);
        this.$emit(MODEL_EVENT_NAME$3, newValue);
      }
    }), _defineProperty$s(_watch$4, "$route", function $route() {
      var newValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var oldValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.noCloseOnRouteChange && newValue.fullPath !== oldValue.fullPath) {
        this.hide();
      }
    }), _watch$4),
    created: function created() {
      this.$_returnFocusEl = null;
    },
    mounted: function mounted() {
      var _this = this;
      this.listenOnRoot(ROOT_ACTION_EVENT_NAME_TOGGLE, this.handleToggle);
      this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REQUEST_STATE, this.handleSync);
      this.$nextTick(function() {
        _this.emitState(_this.localShow);
      });
    },
    /* istanbul ignore next */
    activated: function activated() {
      this.emitSync();
    },
    beforeDestroy: function beforeDestroy() {
      this.localShow = false;
      this.$_returnFocusEl = null;
    },
    methods: {
      hide: function hide2() {
        this.localShow = false;
      },
      emitState: function emitState() {
        var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.localShow;
        this.emitOnRoot(ROOT_EVENT_NAME_STATE, this.safeId(), state);
      },
      emitSync: function emitSync() {
        var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.localShow;
        this.emitOnRoot(ROOT_EVENT_NAME_SYNC_STATE, this.safeId(), state);
      },
      handleToggle: function handleToggle(id) {
        if (id && id === this.safeId()) {
          this.localShow = !this.localShow;
        }
      },
      handleSync: function handleSync(id) {
        var _this2 = this;
        if (id && id === this.safeId()) {
          this.$nextTick(function() {
            _this2.emitSync(_this2.localShow);
          });
        }
      },
      onKeydown: function onKeydown(event2) {
        var keyCode = event2.keyCode;
        if (!this.noCloseOnEsc && keyCode === CODE_ESC && this.localShow) {
          this.hide();
        }
      },
      onBackdropClick: function onBackdropClick() {
        if (this.localShow && !this.noCloseOnBackdrop) {
          this.hide();
        }
      },
      /* istanbul ignore next */
      onTopTrapFocus: function onTopTrapFocus() {
        var tabables = getTabables(this.$refs.content);
        this.enforceFocus(tabables.reverse()[0]);
      },
      /* istanbul ignore next */
      onBottomTrapFocus: function onBottomTrapFocus() {
        var tabables = getTabables(this.$refs.content);
        this.enforceFocus(tabables[0]);
      },
      onBeforeEnter: function onBeforeEnter() {
        this.$_returnFocusEl = getActiveElement(IS_BROWSER ? [document.body] : []);
        this.isOpen = true;
      },
      onAfterEnter: function onAfterEnter2(el) {
        if (!contains(el, getActiveElement())) {
          this.enforceFocus(el);
        }
        this.$emit(EVENT_NAME_SHOWN);
      },
      onAfterLeave: function onAfterLeave2() {
        this.enforceFocus(this.$_returnFocusEl);
        this.$_returnFocusEl = null;
        this.isOpen = false;
        this.$emit(EVENT_NAME_HIDDEN);
      },
      enforceFocus: function enforceFocus(el) {
        if (!this.noEnforceFocus) {
          attemptFocus(el);
        }
      }
    },
    render: function render(h) {
      var _ref;
      var bgVariant = this.bgVariant, width = this.width, textVariant = this.textVariant, localShow = this.localShow;
      var shadow = this.shadow === "" ? true : this.shadow;
      var $sidebar = h(this.tag, {
        staticClass: CLASS_NAME,
        class: [(_ref = {
          shadow: shadow === true
        }, _defineProperty$s(_ref, "shadow-".concat(shadow), shadow && shadow !== true), _defineProperty$s(_ref, "".concat(CLASS_NAME, "-right"), this.right), _defineProperty$s(_ref, "bg-".concat(bgVariant), bgVariant), _defineProperty$s(_ref, "text-".concat(textVariant), textVariant), _ref), this.sidebarClass],
        style: {
          width
        },
        attrs: this.computedAttrs,
        directives: [{
          name: "show",
          value: localShow
        }],
        ref: "content"
      }, [renderContent(h, this)]);
      $sidebar = h("transition", {
        props: this.transitionProps,
        on: {
          beforeEnter: this.onBeforeEnter,
          afterEnter: this.onAfterEnter,
          afterLeave: this.onAfterLeave
        }
      }, [$sidebar]);
      var $backdrop = h(BVTransition, {
        props: {
          noFade: this.noSlide
        }
      }, [renderBackdrop(h, this)]);
      var $tabTrapTop = h();
      var $tabTrapBottom = h();
      if (this.backdrop && localShow) {
        $tabTrapTop = h("div", {
          attrs: {
            tabindex: "0"
          },
          on: {
            focus: this.onTopTrapFocus
          }
        });
        $tabTrapBottom = h("div", {
          attrs: {
            tabindex: "0"
          },
          on: {
            focus: this.onBottomTrapFocus
          }
        });
      }
      return h("div", {
        staticClass: "b-sidebar-outer",
        style: {
          zIndex: this.zIndex
        },
        attrs: {
          tabindex: "-1"
        },
        on: {
          keydown: this.onKeydown
        }
      }, [$tabTrapTop, $sidebar, $tabTrapBottom, $backdrop]);
    }
  });
  var SidebarPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BSidebar
    },
    plugins: {
      VBTogglePlugin
    }
  });
  function _defineProperty$r(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$z = makePropsConfigurable({
    animation: makeProp(PROP_TYPE_STRING, "wave"),
    height: makeProp(PROP_TYPE_STRING),
    size: makeProp(PROP_TYPE_STRING),
    type: makeProp(PROP_TYPE_STRING, "text"),
    variant: makeProp(PROP_TYPE_STRING),
    width: makeProp(PROP_TYPE_STRING)
  }, NAME_SKELETON);
  var BSkeleton = /* @__PURE__ */ extend({
    name: NAME_SKELETON,
    functional: true,
    props: props$z,
    render: function render(h, _ref) {
      var _class;
      var data = _ref.data, props2 = _ref.props;
      var size = props2.size, animation = props2.animation, variant = props2.variant;
      return h("div", a(data, {
        staticClass: "b-skeleton",
        style: {
          width: size || props2.width,
          height: size || props2.height
        },
        class: (_class = {}, _defineProperty$r(_class, "b-skeleton-".concat(props2.type), true), _defineProperty$r(_class, "b-skeleton-animate-".concat(animation), animation), _defineProperty$r(_class, "bg-".concat(variant), variant), _class)
      }));
    }
  });
  function ownKeys$m(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$m(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$m(Object(source), true).forEach(function(key) {
        _defineProperty$q(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$q(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$y = makePropsConfigurable({
    animation: makeProp(PROP_TYPE_STRING, "wave"),
    icon: makeProp(PROP_TYPE_STRING),
    iconProps: makeProp(PROP_TYPE_OBJECT, {})
  }, NAME_SKELETON_ICON);
  var BSkeletonIcon = /* @__PURE__ */ extend({
    name: NAME_SKELETON_ICON,
    functional: true,
    props: props$y,
    render: function render(h, _ref) {
      var data = _ref.data, props2 = _ref.props;
      var icon = props2.icon, animation = props2.animation;
      var $icon = h(BIcon, {
        staticClass: "b-skeleton-icon",
        props: _objectSpread$m(_objectSpread$m({}, props2.iconProps), {}, {
          icon
        })
      });
      return h("div", a(data, {
        staticClass: "b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden",
        class: _defineProperty$q({}, "b-skeleton-animate-".concat(animation), animation)
      }), [$icon]);
    }
  });
  function _defineProperty$p(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$x = makePropsConfigurable({
    animation: makeProp(PROP_TYPE_STRING),
    aspect: makeProp(PROP_TYPE_STRING, "16:9"),
    cardImg: makeProp(PROP_TYPE_STRING),
    height: makeProp(PROP_TYPE_STRING),
    noAspect: makeProp(PROP_TYPE_BOOLEAN, false),
    variant: makeProp(PROP_TYPE_STRING),
    width: makeProp(PROP_TYPE_STRING)
  }, NAME_SKELETON_IMG);
  var BSkeletonImg = /* @__PURE__ */ extend({
    name: NAME_SKELETON_IMG,
    functional: true,
    props: props$x,
    render: function render(h, _ref) {
      var data = _ref.data, props2 = _ref.props;
      var aspect = props2.aspect, width = props2.width, height = props2.height, animation = props2.animation, variant = props2.variant, cardImg = props2.cardImg;
      var $img = h(BSkeleton, a(data, {
        props: {
          type: "img",
          width,
          height,
          animation,
          variant
        },
        class: _defineProperty$p({}, "card-img-".concat(cardImg), cardImg)
      }));
      return props2.noAspect ? $img : h(BAspect, {
        props: {
          aspect
        }
      }, [$img]);
    }
  });
  var hasListenerMixin = extend({
    methods: {
      hasListener: function hasListener(name) {
        if (isVue3) {
          return true;
        }
        var $listeners = this.$listeners || {};
        var $events = this._events || {};
        return !isUndefined($listeners[name]) || isArray($events[name]) && $events[name].length > 0;
      }
    }
  });
  function ownKeys$l(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$l(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$l(Object(source), true).forEach(function(key) {
        _defineProperty$o(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$o(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var LIGHT = "light";
  var DARK = "dark";
  var props$w = makePropsConfigurable({
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_TR);
  var BTr = /* @__PURE__ */ extend({
    name: NAME_TR,
    mixins: [attrsMixin, listenersMixin, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTableTr: function getBvTableTr() {
          return _this;
        }
      };
    },
    inject: {
      getBvTableRowGroup: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    inheritAttrs: false,
    props: props$w,
    computed: {
      bvTableRowGroup: function bvTableRowGroup() {
        return this.getBvTableRowGroup();
      },
      // Sniffed by `<b-td>` / `<b-th>`
      inTbody: function inTbody() {
        return this.bvTableRowGroup.isTbody;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      inThead: function inThead() {
        return this.bvTableRowGroup.isThead;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      inTfoot: function inTfoot() {
        return this.bvTableRowGroup.isTfoot;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      isDark: function isDark() {
        return this.bvTableRowGroup.isDark;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      isStacked: function isStacked() {
        return this.bvTableRowGroup.isStacked;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      isResponsive: function isResponsive() {
        return this.bvTableRowGroup.isResponsive;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      // Sticky headers are only supported in thead
      isStickyHeader: function isStickyHeader() {
        return this.bvTableRowGroup.isStickyHeader;
      },
      // Sniffed by <b-tr> / `<b-td>` / `<b-th>`
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      hasStickyHeader: function hasStickyHeader() {
        return !this.isStacked && this.bvTableRowGroup.hasStickyHeader;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      tableVariant: function tableVariant() {
        return this.bvTableRowGroup.tableVariant;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      headVariant: function headVariant() {
        return this.inThead ? this.bvTableRowGroup.headVariant : null;
      },
      // Sniffed by `<b-td>` / `<b-th>`
      footVariant: function footVariant() {
        return this.inTfoot ? this.bvTableRowGroup.footVariant : null;
      },
      isRowDark: function isRowDark() {
        return this.headVariant === LIGHT || this.footVariant === LIGHT ? (
          /* istanbul ignore next */
          false
        ) : this.headVariant === DARK || this.footVariant === DARK ? (
          /* istanbul ignore next */
          true
        ) : this.isDark;
      },
      trClasses: function trClasses() {
        var variant = this.variant;
        return [variant ? "".concat(this.isRowDark ? "bg" : "table", "-").concat(variant) : null];
      },
      trAttrs: function trAttrs() {
        return _objectSpread$l({
          role: "row"
        }, this.bvAttrs);
      }
    },
    render: function render(h) {
      return h("tr", {
        class: this.trClasses,
        attrs: this.trAttrs,
        // Pass native listeners to child
        on: this.bvListeners
      }, this.normalizeSlot());
    }
  });
  var props$v = {};
  var bottomRowMixin = extend({
    props: props$v,
    methods: {
      renderBottomRow: function renderBottomRow() {
        var fields = this.computedFields, stacked = this.stacked, tbodyTrClass = this.tbodyTrClass, tbodyTrAttr = this.tbodyTrAttr;
        var h = this.$createElement;
        if (!this.hasNormalizedSlot(SLOT_NAME_BOTTOM_ROW) || stacked === true || stacked === "") {
          return h();
        }
        return h(BTr, {
          staticClass: "b-table-bottom-row",
          class: [isFunction$1(tbodyTrClass) ? (
            /* istanbul ignore next */
            tbodyTrClass(null, "row-bottom")
          ) : tbodyTrClass],
          attrs: isFunction$1(tbodyTrAttr) ? (
            /* istanbul ignore next */
            tbodyTrAttr(null, "row-bottom")
          ) : tbodyTrAttr,
          key: "b-bottom-row"
        }, this.normalizeSlot(SLOT_NAME_BOTTOM_ROW, {
          columns: fields.length,
          fields
        }));
      }
    }
  });
  function ownKeys$k(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$k(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$k(Object(source), true).forEach(function(key) {
        _defineProperty$n(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$n(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var parseSpan = function parseSpan2(value) {
    value = toInteger(value, 0);
    return value > 0 ? value : null;
  };
  var spanValidator = function spanValidator2(value) {
    return isUndefinedOrNull(value) || parseSpan(value) > 0;
  };
  var props$u = makePropsConfigurable({
    colspan: makeProp(PROP_TYPE_NUMBER_STRING, null, spanValidator),
    rowspan: makeProp(PROP_TYPE_NUMBER_STRING, null, spanValidator),
    stackedHeading: makeProp(PROP_TYPE_STRING),
    stickyColumn: makeProp(PROP_TYPE_BOOLEAN, false),
    variant: makeProp(PROP_TYPE_STRING)
  }, NAME_TABLE_CELL);
  var BTd = /* @__PURE__ */ extend({
    name: NAME_TABLE_CELL,
    // Mixin order is important!
    mixins: [attrsMixin, listenersMixin, normalizeSlotMixin],
    inject: {
      getBvTableTr: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    inheritAttrs: false,
    props: props$u,
    computed: {
      bvTableTr: function bvTableTr() {
        return this.getBvTableTr();
      },
      // Overridden by `<b-th>`
      tag: function tag() {
        return "td";
      },
      inTbody: function inTbody() {
        return this.bvTableTr.inTbody;
      },
      inThead: function inThead() {
        return this.bvTableTr.inThead;
      },
      inTfoot: function inTfoot() {
        return this.bvTableTr.inTfoot;
      },
      isDark: function isDark() {
        return this.bvTableTr.isDark;
      },
      isStacked: function isStacked() {
        return this.bvTableTr.isStacked;
      },
      // We only support stacked-heading in tbody in stacked mode
      isStackedCell: function isStackedCell() {
        return this.inTbody && this.isStacked;
      },
      isResponsive: function isResponsive() {
        return this.bvTableTr.isResponsive;
      },
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      // Sticky headers only apply to cells in table `thead`
      isStickyHeader: function isStickyHeader() {
        return this.bvTableTr.isStickyHeader;
      },
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      hasStickyHeader: function hasStickyHeader() {
        return this.bvTableTr.hasStickyHeader;
      },
      // Needed to handle background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      // Sticky column cells are only available in responsive
      // mode (horizontal scrolling) or when sticky header mode
      // Applies to cells in `thead`, `tbody` and `tfoot`
      isStickyColumn: function isStickyColumn() {
        return !this.isStacked && (this.isResponsive || this.hasStickyHeader) && this.stickyColumn;
      },
      rowVariant: function rowVariant() {
        return this.bvTableTr.variant;
      },
      headVariant: function headVariant() {
        return this.bvTableTr.headVariant;
      },
      footVariant: function footVariant() {
        return this.bvTableTr.footVariant;
      },
      tableVariant: function tableVariant() {
        return this.bvTableTr.tableVariant;
      },
      computedColspan: function computedColspan() {
        return parseSpan(this.colspan);
      },
      computedRowspan: function computedRowspan() {
        return parseSpan(this.rowspan);
      },
      // We use computed props here for improved performance by caching
      // the results of the string interpolation
      cellClasses: function cellClasses() {
        var variant = this.variant, headVariant = this.headVariant, isStickyColumn = this.isStickyColumn;
        if (!variant && this.isStickyHeader && !headVariant || !variant && isStickyColumn && this.inTfoot && !this.footVariant || !variant && isStickyColumn && this.inThead && !headVariant || !variant && isStickyColumn && this.inTbody) {
          variant = this.rowVariant || this.tableVariant || "b-table-default";
        }
        return [variant ? "".concat(this.isDark ? "bg" : "table", "-").concat(variant) : null, isStickyColumn ? "b-table-sticky-column" : null];
      },
      cellAttrs: function cellAttrs() {
        var stackedHeading = this.stackedHeading;
        var headOrFoot = this.inThead || this.inTfoot;
        var colspan = this.computedColspan;
        var rowspan = this.computedRowspan;
        var role = "cell";
        var scope = null;
        if (headOrFoot) {
          role = "columnheader";
          scope = colspan > 0 ? "colspan" : "col";
        } else if (isTag(this.tag, "th")) {
          role = "rowheader";
          scope = rowspan > 0 ? "rowgroup" : "row";
        }
        return _objectSpread$k(_objectSpread$k({
          colspan,
          rowspan,
          role,
          scope
        }, this.bvAttrs), {}, {
          // Add in the stacked cell label data-attribute if in
          // stacked mode (if a stacked heading label is provided)
          "data-label": this.isStackedCell && !isUndefinedOrNull(stackedHeading) ? (
            /* istanbul ignore next */
            toString(stackedHeading)
          ) : null
        });
      }
    },
    render: function render(h) {
      var $content = [this.normalizeSlot()];
      return h(this.tag, {
        class: this.cellClasses,
        attrs: this.cellAttrs,
        // Transfer any native listeners
        on: this.bvListeners
      }, [this.isStackedCell ? h("div", [$content]) : $content]);
    }
  });
  function _defineProperty$m(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_BUSY = "busy";
  var MODEL_EVENT_NAME_BUSY = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_BUSY;
  var props$t = _defineProperty$m({}, MODEL_PROP_NAME_BUSY, makeProp(PROP_TYPE_BOOLEAN, false));
  var busyMixin = extend({
    props: props$t,
    data: function data() {
      return {
        localBusy: false
      };
    },
    computed: {
      computedBusy: function computedBusy() {
        return this[MODEL_PROP_NAME_BUSY] || this.localBusy;
      }
    },
    watch: {
      localBusy: function localBusy(newValue, oldValue) {
        if (newValue !== oldValue) {
          this.$emit(MODEL_EVENT_NAME_BUSY, newValue);
        }
      }
    },
    methods: {
      // Event handler helper
      stopIfBusy: function stopIfBusy(event2) {
        if (this.computedBusy) {
          stopEvent(event2);
          return true;
        }
        return false;
      },
      // Render the busy indicator or return `null` if not busy
      renderBusy: function renderBusy() {
        var tbodyTrClass = this.tbodyTrClass, tbodyTrAttr = this.tbodyTrAttr;
        var h = this.$createElement;
        if (this.computedBusy && this.hasNormalizedSlot(SLOT_NAME_TABLE_BUSY)) {
          return h(BTr, {
            staticClass: "b-table-busy-slot",
            class: [isFunction$1(tbodyTrClass) ? (
              /* istanbul ignore next */
              tbodyTrClass(null, SLOT_NAME_TABLE_BUSY)
            ) : tbodyTrClass],
            attrs: isFunction$1(tbodyTrAttr) ? (
              /* istanbul ignore next */
              tbodyTrAttr(null, SLOT_NAME_TABLE_BUSY)
            ) : tbodyTrAttr,
            key: "table-busy-slot"
          }, [h(BTd, {
            props: {
              colspan: this.computedFields.length || null
            }
          }, [this.normalizeSlot(SLOT_NAME_TABLE_BUSY)])]);
        }
        return null;
      }
    }
  });
  var props$s = {
    caption: makeProp(PROP_TYPE_STRING),
    captionHtml: makeProp(PROP_TYPE_STRING)
    // `caption-top` is part of table-render mixin (styling)
    // captionTop: makeProp(PROP_TYPE_BOOLEAN, false)
  };
  var captionMixin = extend({
    props: props$s,
    computed: {
      captionId: function captionId() {
        return this.isStacked ? this.safeId("_caption_") : null;
      }
    },
    methods: {
      renderCaption: function renderCaption() {
        var caption = this.caption, captionHtml = this.captionHtml;
        var h = this.$createElement;
        var $caption = h();
        var hasCaptionSlot = this.hasNormalizedSlot(SLOT_NAME_TABLE_CAPTION);
        if (hasCaptionSlot || caption || captionHtml) {
          $caption = h("caption", {
            attrs: {
              id: this.captionId
            },
            domProps: hasCaptionSlot ? {} : htmlOrText(captionHtml, caption),
            key: "caption",
            ref: "caption"
          }, this.normalizeSlot(SLOT_NAME_TABLE_CAPTION));
        }
        return $caption;
      }
    }
  });
  var props$r = {};
  var colgroupMixin = extend({
    methods: {
      renderColgroup: function renderColgroup() {
        var fields = this.computedFields;
        var h = this.$createElement;
        var $colgroup = h();
        if (this.hasNormalizedSlot(SLOT_NAME_TABLE_COLGROUP)) {
          $colgroup = h("colgroup", {
            key: "colgroup"
          }, [this.normalizeSlot(SLOT_NAME_TABLE_COLGROUP, {
            columns: fields.length,
            fields
          })]);
        }
        return $colgroup;
      }
    }
  });
  var props$q = {
    emptyFilteredHtml: makeProp(PROP_TYPE_STRING),
    emptyFilteredText: makeProp(PROP_TYPE_STRING, "There are no records matching your request"),
    emptyHtml: makeProp(PROP_TYPE_STRING),
    emptyText: makeProp(PROP_TYPE_STRING, "There are no records to show"),
    showEmpty: makeProp(PROP_TYPE_BOOLEAN, false)
  };
  var emptyMixin = extend({
    props: props$q,
    methods: {
      renderEmpty: function renderEmpty() {
        var _safeVueInstance = safeVueInstance(this), items = _safeVueInstance.computedItems, computedBusy = _safeVueInstance.computedBusy;
        var h = this.$createElement;
        var $empty = h();
        if (this.showEmpty && (!items || items.length === 0) && !(computedBusy && this.hasNormalizedSlot(SLOT_NAME_TABLE_BUSY))) {
          var fields = this.computedFields, isFiltered = this.isFiltered, emptyText = this.emptyText, emptyHtml = this.emptyHtml, emptyFilteredText = this.emptyFilteredText, emptyFilteredHtml = this.emptyFilteredHtml, tbodyTrClass = this.tbodyTrClass, tbodyTrAttr = this.tbodyTrAttr;
          $empty = this.normalizeSlot(isFiltered ? SLOT_NAME_EMPTYFILTERED : SLOT_NAME_EMPTY, {
            emptyFilteredHtml,
            emptyFilteredText,
            emptyHtml,
            emptyText,
            fields,
            // Not sure why this is included, as it will always be an empty array
            items
          });
          if (!$empty) {
            $empty = h("div", {
              class: ["text-center", "my-2"],
              domProps: isFiltered ? htmlOrText(emptyFilteredHtml, emptyFilteredText) : htmlOrText(emptyHtml, emptyText)
            });
          }
          $empty = h(BTd, {
            props: {
              colspan: fields.length || null
            }
          }, [h("div", {
            attrs: {
              role: "alert",
              "aria-live": "polite"
            }
          }, [$empty])]);
          $empty = h(BTr, {
            staticClass: "b-table-empty-row",
            class: [isFunction$1(tbodyTrClass) ? (
              /* istanbul ignore next */
              tbodyTrClass(null, "row-empty")
            ) : tbodyTrClass],
            attrs: isFunction$1(tbodyTrAttr) ? (
              /* istanbul ignore next */
              tbodyTrAttr(null, "row-empty")
            ) : tbodyTrAttr,
            key: isFiltered ? "b-empty-filtered-row" : "b-empty-row"
          }, [$empty]);
        }
        return $empty;
      }
    }
  });
  var stringifyObjectValues = function stringifyObjectValues2(value) {
    if (isUndefinedOrNull(value)) {
      return "";
    }
    if (isObject(value) && !isDate(value)) {
      return keys(value).sort().map(function(k) {
        return stringifyObjectValues2(value[k]);
      }).filter(function(v) {
        return !!v;
      }).join(" ");
    }
    return toString(value);
  };
  function ownKeys$j(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$j(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$j(Object(source), true).forEach(function(key) {
        _defineProperty$l(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$l(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var FIELD_KEY_CELL_VARIANT = "_cellVariants";
  var FIELD_KEY_ROW_VARIANT = "_rowVariant";
  var FIELD_KEY_SHOW_DETAILS = "_showDetails";
  var IGNORED_FIELD_KEYS = [FIELD_KEY_CELL_VARIANT, FIELD_KEY_ROW_VARIANT, FIELD_KEY_SHOW_DETAILS].reduce(function(result, key) {
    return _objectSpread$j(_objectSpread$j({}, result), {}, _defineProperty$l({}, key, true));
  }, {});
  var EVENT_FILTER = [
    "a",
    "a *",
    // Include content inside links
    "button",
    "button *",
    // Include content inside buttons
    "input:not(.disabled):not([disabled])",
    "select:not(.disabled):not([disabled])",
    "textarea:not(.disabled):not([disabled])",
    '[role="link"]',
    '[role="link"] *',
    '[role="button"]',
    '[role="button"] *',
    "[tabindex]:not(.disabled):not([disabled])"
  ].join(",");
  var sanitizeRow = function sanitizeRow2(row, ignoreFields, includeFields) {
    var fieldsObj = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var formattedRow = keys(fieldsObj).reduce(function(result, key) {
      var field = fieldsObj[key];
      var filterByFormatted = field.filterByFormatted;
      var formatter = isFunction$1(filterByFormatted) ? (
        /* istanbul ignore next */
        filterByFormatted
      ) : filterByFormatted ? (
        /* istanbul ignore next */
        field.formatter
      ) : null;
      if (isFunction$1(formatter)) {
        result[key] = formatter(row[key], key, row);
      }
      return result;
    }, clone(row));
    var allowedKeys = keys(formattedRow).filter(function(key) {
      return !IGNORED_FIELD_KEYS[key] && !(isArray(ignoreFields) && ignoreFields.length > 0 && arrayIncludes(ignoreFields, key)) && !(isArray(includeFields) && includeFields.length > 0 && !arrayIncludes(includeFields, key));
    });
    return pick$1(formattedRow, allowedKeys);
  };
  var stringifyRecordValues = function stringifyRecordValues2(row, ignoreFields, includeFields, fieldsObj) {
    return isObject(row) ? stringifyObjectValues(sanitizeRow(row, ignoreFields, includeFields, fieldsObj)) : (
      /* istanbul ignore next */
      ""
    );
  };
  function _toConsumableArray$4(arr) {
    return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$3(arr) || _nonIterableSpread$4();
  }
  function _nonIterableSpread$4() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$3(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen);
  }
  function _iterableToArray$4(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$4(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$3(arr);
  }
  function _arrayLikeToArray$3(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var DEBOUNCE_DEPRECATED_MSG = 'Prop "filter-debounce" is deprecated. Use the debounce feature of "<b-form-input>" instead.';
  var props$p = {
    filter: makeProp([].concat(_toConsumableArray$4(PROP_TYPE_ARRAY_OBJECT_STRING), [PROP_TYPE_REG_EXP])),
    filterDebounce: makeProp(PROP_TYPE_NUMBER_STRING, 0, function(value) {
      return RX_DIGITS.test(String(value));
    }),
    filterFunction: makeProp(PROP_TYPE_FUNCTION),
    filterIgnoredFields: makeProp(PROP_TYPE_ARRAY, []),
    filterIncludedFields: makeProp(PROP_TYPE_ARRAY, [])
  };
  var filteringMixin = extend({
    props: props$p,
    data: function data() {
      return {
        // Flag for displaying which empty slot to show and some event triggering
        isFiltered: false,
        // Where we store the copy of the filter criteria after debouncing
        // We pre-set it with the sanitized filter value
        localFilter: this.filterSanitize(this.filter)
      };
    },
    computed: {
      computedFilterIgnored: function computedFilterIgnored() {
        return concat(this.filterIgnoredFields || []).filter(identity);
      },
      computedFilterIncluded: function computedFilterIncluded() {
        return concat(this.filterIncludedFields || []).filter(identity);
      },
      computedFilterDebounce: function computedFilterDebounce() {
        var ms = toInteger(this.filterDebounce, 0);
        if (ms > 0) {
          warn(DEBOUNCE_DEPRECATED_MSG, NAME_TABLE);
        }
        return ms;
      },
      localFiltering: function localFiltering() {
        return this.hasProvider ? !!this.noProviderFiltering : true;
      },
      // For watching changes to `filteredItems` vs `localItems`
      filteredCheck: function filteredCheck() {
        var filteredItems = this.filteredItems, localItems = this.localItems, localFilter = this.localFilter;
        return {
          filteredItems,
          localItems,
          localFilter
        };
      },
      // Sanitized/normalize filter-function prop
      localFilterFn: function localFilterFn() {
        var filterFunction = this.filterFunction;
        return hasPropFunction(filterFunction) ? filterFunction : null;
      },
      // Returns the records in `localItems` that match the filter criteria
      // Returns the original `localItems` array if not sorting
      filteredItems: function filteredItems() {
        var items = this.localItems, criteria = this.localFilter;
        var filterFn = this.localFiltering ? this.filterFnFactory(this.localFilterFn, criteria) || this.defaultFilterFnFactory(criteria) : null;
        return filterFn && items.length > 0 ? items.filter(filterFn) : items;
      }
    },
    watch: {
      // Watch for debounce being set to 0
      computedFilterDebounce: function computedFilterDebounce(newValue) {
        if (!newValue && this.$_filterTimer) {
          this.clearFilterTimer();
          this.localFilter = this.filterSanitize(this.filter);
        }
      },
      // Watch for changes to the filter criteria, and debounce if necessary
      filter: {
        // We need a deep watcher in case the user passes
        // an object when using `filter-function`
        deep: true,
        handler: function handler(newCriteria) {
          var _this = this;
          var timeout = this.computedFilterDebounce;
          this.clearFilterTimer();
          if (timeout && timeout > 0) {
            this.$_filterTimer = setTimeout(function() {
              _this.localFilter = _this.filterSanitize(newCriteria);
            }, timeout);
          } else {
            this.localFilter = this.filterSanitize(newCriteria);
          }
        }
      },
      // Watch for changes to the filter criteria and filtered items vs `localItems`
      // Set visual state and emit events as required
      filteredCheck: function filteredCheck(_ref) {
        var filteredItems = _ref.filteredItems, localFilter = _ref.localFilter;
        var isFiltered = false;
        if (!localFilter) {
          isFiltered = false;
        } else if (looseEqual(localFilter, []) || looseEqual(localFilter, {})) {
          isFiltered = false;
        } else if (localFilter) {
          isFiltered = true;
        }
        if (isFiltered) {
          this.$emit(EVENT_NAME_FILTERED, filteredItems, filteredItems.length);
        }
        this.isFiltered = isFiltered;
      },
      isFiltered: function isFiltered(newValue, oldValue) {
        if (newValue === false && oldValue === true) {
          var localItems = this.localItems;
          this.$emit(EVENT_NAME_FILTERED, localItems, localItems.length);
        }
      }
    },
    created: function created() {
      var _this2 = this;
      this.$_filterTimer = null;
      this.$nextTick(function() {
        _this2.isFiltered = Boolean(_this2.localFilter);
      });
    },
    beforeDestroy: function beforeDestroy() {
      this.clearFilterTimer();
    },
    methods: {
      clearFilterTimer: function clearFilterTimer() {
        clearTimeout(this.$_filterTimer);
        this.$_filterTimer = null;
      },
      filterSanitize: function filterSanitize(criteria) {
        if (this.localFiltering && !this.localFilterFn && !(isString(criteria) || isRegExp(criteria))) {
          return "";
        }
        return cloneDeep(criteria);
      },
      // Filter Function factories
      filterFnFactory: function filterFnFactory(filterFn, criteria) {
        if (!filterFn || !isFunction$1(filterFn) || !criteria || looseEqual(criteria, []) || looseEqual(criteria, {})) {
          return null;
        }
        var fn = function fn2(item) {
          return filterFn(item, criteria);
        };
        return fn;
      },
      defaultFilterFnFactory: function defaultFilterFnFactory(criteria) {
        var _this3 = this;
        if (!criteria || !(isString(criteria) || isRegExp(criteria))) {
          return null;
        }
        var regExp = criteria;
        if (isString(regExp)) {
          var pattern = escapeRegExp(criteria).replace(RX_SPACES, "\\s+");
          regExp = new RegExp(".*".concat(pattern, ".*"), "i");
        }
        var fn = function fn2(item) {
          regExp.lastIndex = 0;
          return regExp.test(stringifyRecordValues(item, _this3.computedFilterIgnored, _this3.computedFilterIncluded, _this3.computedFieldsObj));
        };
        return fn;
      }
    }
  });
  var processField = function processField2(key, value) {
    var field = null;
    if (isString(value)) {
      field = {
        key,
        label: value
      };
    } else if (isFunction$1(value)) {
      field = {
        key,
        formatter: value
      };
    } else if (isObject(value)) {
      field = clone(value);
      field.key = field.key || key;
    } else if (value !== false) {
      field = {
        key
      };
    }
    return field;
  };
  var normalizeFields = function normalizeFields2(origFields, items) {
    var fields = [];
    if (isArray(origFields)) {
      origFields.filter(identity).forEach(function(f) {
        if (isString(f)) {
          fields.push({
            key: f,
            label: startCase(f)
          });
        } else if (isObject(f) && f.key && isString(f.key)) {
          fields.push(clone(f));
        } else if (isObject(f) && keys(f).length === 1) {
          var key = keys(f)[0];
          var field = processField(key, f[key]);
          if (field) {
            fields.push(field);
          }
        }
      });
    }
    if (fields.length === 0 && isArray(items) && items.length > 0) {
      var sample = items[0];
      keys(sample).forEach(function(k) {
        if (!IGNORED_FIELD_KEYS[k]) {
          fields.push({
            key: k,
            label: startCase(k)
          });
        }
      });
    }
    var memo = {};
    return fields.filter(function(f) {
      if (!memo[f.key]) {
        memo[f.key] = true;
        f.label = isString(f.label) ? f.label : startCase(f.key);
        return true;
      }
      return false;
    });
  };
  function ownKeys$i(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$i(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$i(Object(source), true).forEach(function(key) {
        _defineProperty$k(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$k(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$2 = makeModelMixin("value", {
    type: PROP_TYPE_ARRAY,
    defaultValue: []
  }), modelMixin$2 = _makeModelMixin$2.mixin, modelProps$2 = _makeModelMixin$2.props, MODEL_PROP_NAME$2 = _makeModelMixin$2.prop, MODEL_EVENT_NAME$2 = _makeModelMixin$2.event;
  var props$o = sortKeys(_objectSpread$i(_objectSpread$i({}, modelProps$2), {}, _defineProperty$k({
    fields: makeProp(PROP_TYPE_ARRAY, null),
    // Provider mixin adds in `Function` type
    items: makeProp(PROP_TYPE_ARRAY, []),
    // Primary key for record
    // If provided the value in each row must be unique!
    primaryKey: makeProp(PROP_TYPE_STRING)
  }, MODEL_PROP_NAME$2, makeProp(PROP_TYPE_ARRAY, []))));
  var itemsMixin = extend({
    mixins: [modelMixin$2, useParentMixin],
    props: props$o,
    data: function data() {
      var items = this.items;
      return {
        // Our local copy of the items
        // Must be an array
        localItems: isArray(items) ? items.slice() : []
      };
    },
    computed: {
      computedFields: function computedFields() {
        return normalizeFields(this.fields, this.localItems);
      },
      computedFieldsObj: function computedFieldsObj() {
        var bvParent = this.bvParent;
        return this.computedFields.reduce(function(obj, f) {
          obj[f.key] = clone(f);
          if (f.formatter) {
            var formatter = f.formatter;
            if (isString(formatter) && isFunction$1(bvParent[formatter])) {
              formatter = bvParent[formatter];
            } else if (!isFunction$1(formatter)) {
              formatter = void 0;
            }
            obj[f.key].formatter = formatter;
          }
          return obj;
        }, {});
      },
      computedItems: function computedItems() {
        var _safeVueInstance = safeVueInstance(this), paginatedItems = _safeVueInstance.paginatedItems, sortedItems = _safeVueInstance.sortedItems, filteredItems = _safeVueInstance.filteredItems, localItems = _safeVueInstance.localItems;
        return (paginatedItems || sortedItems || filteredItems || localItems || /* istanbul ignore next */
        []).slice();
      },
      context: function context() {
        var _safeVueInstance2 = safeVueInstance(this), perPage = _safeVueInstance2.perPage, currentPage = _safeVueInstance2.currentPage;
        return {
          filter: this.localFilter,
          sortBy: this.localSortBy,
          sortDesc: this.localSortDesc,
          perPage: mathMax(toInteger(perPage, 0), 0),
          currentPage: mathMax(toInteger(currentPage, 0), 1),
          apiUrl: this.apiUrl
        };
      }
    },
    watch: {
      items: function items(newValue) {
        this.localItems = isArray(newValue) ? newValue.slice() : [];
      },
      // Watch for changes on `computedItems` and update the `v-model`
      computedItems: function computedItems(newValue, oldValue) {
        if (!looseEqual(newValue, oldValue)) {
          this.$emit(MODEL_EVENT_NAME$2, newValue);
        }
      },
      // Watch for context changes
      context: function context(newValue, oldValue) {
        if (!looseEqual(newValue, oldValue)) {
          this.$emit(EVENT_NAME_CONTEXT_CHANGED, newValue);
        }
      }
    },
    mounted: function mounted() {
      this.$emit(MODEL_EVENT_NAME$2, this.computedItems);
    },
    methods: {
      // Method to get the formatter method for a given field key
      getFieldFormatter: function getFieldFormatter(key) {
        var field = this.computedFieldsObj[key];
        return field ? field.formatter : void 0;
      }
    }
  });
  var props$n = {
    currentPage: makeProp(PROP_TYPE_NUMBER_STRING, 1),
    perPage: makeProp(PROP_TYPE_NUMBER_STRING, 0)
  };
  var paginationMixin = extend({
    props: props$n,
    computed: {
      localPaging: function localPaging() {
        return this.hasProvider ? !!this.noProviderPaging : true;
      },
      paginatedItems: function paginatedItems() {
        var _safeVueInstance = safeVueInstance(this), sortedItems = _safeVueInstance.sortedItems, filteredItems = _safeVueInstance.filteredItems, localItems = _safeVueInstance.localItems;
        var items = sortedItems || filteredItems || localItems || [];
        var currentPage = mathMax(toInteger(this.currentPage, 1), 1);
        var perPage = mathMax(toInteger(this.perPage, 0), 0);
        if (this.localPaging && perPage) {
          items = items.slice((currentPage - 1) * perPage, currentPage * perPage);
        }
        return items;
      }
    }
  });
  var ROOT_EVENT_NAME_REFRESHED = getRootEventName(NAME_TABLE, EVENT_NAME_REFRESHED);
  var ROOT_ACTION_EVENT_NAME_REFRESH = getRootActionEventName(NAME_TABLE, EVENT_NAME_REFRESH);
  var props$m = {
    // Passed to the context object
    // Not used by `<b-table>` directly
    apiUrl: makeProp(PROP_TYPE_STRING),
    // Adds in 'Function' support
    items: makeProp(PROP_TYPE_ARRAY_FUNCTION, []),
    noProviderFiltering: makeProp(PROP_TYPE_BOOLEAN, false),
    noProviderPaging: makeProp(PROP_TYPE_BOOLEAN, false),
    noProviderSorting: makeProp(PROP_TYPE_BOOLEAN, false)
  };
  var providerMixin = extend({
    mixins: [listenOnRootMixin],
    props: props$m,
    computed: {
      hasProvider: function hasProvider() {
        return isFunction$1(this.items);
      },
      providerTriggerContext: function providerTriggerContext() {
        var ctx = {
          apiUrl: this.apiUrl,
          filter: null,
          sortBy: null,
          sortDesc: null,
          perPage: null,
          currentPage: null
        };
        if (!this.noProviderFiltering) {
          ctx.filter = this.localFilter;
        }
        if (!this.noProviderSorting) {
          ctx.sortBy = this.localSortBy;
          ctx.sortDesc = this.localSortDesc;
        }
        if (!this.noProviderPaging) {
          ctx.perPage = this.perPage;
          ctx.currentPage = this.currentPage;
        }
        return clone(ctx);
      }
    },
    watch: {
      // Provider update triggering
      items: function items(newValue) {
        if (this.hasProvider || isFunction$1(newValue)) {
          this.$nextTick(this._providerUpdate);
        }
      },
      providerTriggerContext: function providerTriggerContext(newValue, oldValue) {
        if (!looseEqual(newValue, oldValue)) {
          this.$nextTick(this._providerUpdate);
        }
      }
    },
    mounted: function mounted() {
      var _this = this;
      if (this.hasProvider && (!this.localItems || this.localItems.length === 0)) {
        this._providerUpdate();
      }
      this.listenOnRoot(ROOT_ACTION_EVENT_NAME_REFRESH, function(id) {
        if (id === _this.id || id === _this) {
          _this.refresh();
        }
      });
    },
    methods: {
      refresh: function refresh() {
        var _safeVueInstance = safeVueInstance(this), items = _safeVueInstance.items, refresh2 = _safeVueInstance.refresh, computedBusy = _safeVueInstance.computedBusy;
        this.$off(EVENT_NAME_REFRESHED, refresh2);
        if (computedBusy) {
          if (this.localBusy && this.hasProvider) {
            this.$on(EVENT_NAME_REFRESHED, refresh2);
          }
        } else {
          this.clearSelected();
          if (this.hasProvider) {
            this.$nextTick(this._providerUpdate);
          } else {
            this.localItems = isArray(items) ? items.slice() : [];
          }
        }
      },
      // Provider related methods
      _providerSetLocal: function _providerSetLocal(items) {
        this.localItems = isArray(items) ? items.slice() : [];
        this.localBusy = false;
        this.$emit(EVENT_NAME_REFRESHED);
        if (this.id) {
          this.emitOnRoot(ROOT_EVENT_NAME_REFRESHED, this.id);
        }
      },
      _providerUpdate: function _providerUpdate() {
        var _this2 = this;
        if (!this.hasProvider) {
          return;
        }
        if (safeVueInstance(this).computedBusy) {
          this.$nextTick(this.refresh);
          return;
        }
        this.localBusy = true;
        this.$nextTick(function() {
          try {
            var data = _this2.items(_this2.context, _this2._providerSetLocal);
            if (isPromise(data)) {
              data.then(function(items) {
                _this2._providerSetLocal(items);
              });
            } else if (isArray(data)) {
              _this2._providerSetLocal(data);
            } else {
              if (_this2.items.length !== 2) {
                warn("Provider function didn't request callback and did not return a promise or data.", NAME_TABLE);
                _this2.localBusy = false;
              }
            }
          } catch (e2) {
            warn("Provider function error [".concat(e2.name, "] ").concat(e2.message, "."), NAME_TABLE);
            _this2.localBusy = false;
            _this2.$off(EVENT_NAME_REFRESHED, _this2.refresh);
          }
        });
      }
    }
  });
  function _defineProperty$j(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var SELECT_MODES = ["range", "multi", "single"];
  var ROLE_GRID = "grid";
  var props$l = {
    // Disable use of click handlers for row selection
    noSelectOnClick: makeProp(PROP_TYPE_BOOLEAN, false),
    selectMode: makeProp(PROP_TYPE_STRING, "multi", function(value) {
      return arrayIncludes(SELECT_MODES, value);
    }),
    selectable: makeProp(PROP_TYPE_BOOLEAN, false),
    selectedVariant: makeProp(PROP_TYPE_STRING, "active")
  };
  var selectableMixin = extend({
    props: props$l,
    data: function data() {
      return {
        selectedRows: [],
        selectedLastRow: -1
      };
    },
    computed: {
      isSelectable: function isSelectable() {
        return this.selectable && this.selectMode;
      },
      hasSelectableRowClick: function hasSelectableRowClick() {
        return this.isSelectable && !this.noSelectOnClick;
      },
      supportsSelectableRows: function supportsSelectableRows() {
        return true;
      },
      selectableHasSelection: function selectableHasSelection() {
        var selectedRows = this.selectedRows;
        return this.isSelectable && selectedRows && selectedRows.length > 0 && selectedRows.some(identity);
      },
      selectableIsMultiSelect: function selectableIsMultiSelect() {
        return this.isSelectable && arrayIncludes(["range", "multi"], this.selectMode);
      },
      selectableTableClasses: function selectableTableClasses() {
        var _ref;
        var isSelectable = this.isSelectable;
        return _ref = {
          "b-table-selectable": isSelectable
        }, _defineProperty$j(_ref, "b-table-select-".concat(this.selectMode), isSelectable), _defineProperty$j(_ref, "b-table-selecting", this.selectableHasSelection), _defineProperty$j(_ref, "b-table-selectable-no-click", isSelectable && !this.hasSelectableRowClick), _ref;
      },
      selectableTableAttrs: function selectableTableAttrs() {
        if (!this.isSelectable) {
          return {};
        }
        var role = this.bvAttrs.role || ROLE_GRID;
        return {
          role,
          // TODO:
          //   Should this attribute not be included when `no-select-on-click` is set
          //   since this attribute implies keyboard navigation?
          "aria-multiselectable": role === ROLE_GRID ? toString(this.selectableIsMultiSelect) : null
        };
      }
    },
    watch: {
      computedItems: function computedItems(newValue, oldValue) {
        var equal = false;
        if (this.isSelectable && this.selectedRows.length > 0) {
          equal = isArray(newValue) && isArray(oldValue) && newValue.length === oldValue.length;
          for (var i = 0; equal && i < newValue.length; i++) {
            equal = looseEqual(sanitizeRow(newValue[i]), sanitizeRow(oldValue[i]));
          }
        }
        if (!equal) {
          this.clearSelected();
        }
      },
      selectable: function selectable(newValue) {
        this.clearSelected();
        this.setSelectionHandlers(newValue);
      },
      selectMode: function selectMode() {
        this.clearSelected();
      },
      hasSelectableRowClick: function hasSelectableRowClick(newValue) {
        this.clearSelected();
        this.setSelectionHandlers(!newValue);
      },
      selectedRows: function selectedRows(_selectedRows, oldValue) {
        var _this = this;
        if (this.isSelectable && !looseEqual(_selectedRows, oldValue)) {
          var items = [];
          _selectedRows.forEach(function(v, idx) {
            if (v) {
              items.push(_this.computedItems[idx]);
            }
          });
          this.$emit(EVENT_NAME_ROW_SELECTED, items);
        }
      }
    },
    beforeMount: function beforeMount() {
      if (this.isSelectable) {
        this.setSelectionHandlers(true);
      }
    },
    methods: {
      // Public methods
      selectRow: function selectRow(index) {
        if (this.isSelectable && isNumber(index) && index >= 0 && index < this.computedItems.length && !this.isRowSelected(index)) {
          var selectedRows = this.selectableIsMultiSelect ? this.selectedRows.slice() : [];
          selectedRows[index] = true;
          this.selectedLastClicked = -1;
          this.selectedRows = selectedRows;
        }
      },
      unselectRow: function unselectRow(index) {
        if (this.isSelectable && isNumber(index) && this.isRowSelected(index)) {
          var selectedRows = this.selectedRows.slice();
          selectedRows[index] = false;
          this.selectedLastClicked = -1;
          this.selectedRows = selectedRows;
        }
      },
      selectAllRows: function selectAllRows() {
        var length = this.computedItems.length;
        if (this.isSelectable && length > 0) {
          this.selectedLastClicked = -1;
          this.selectedRows = this.selectableIsMultiSelect ? createArray(length, true) : [true];
        }
      },
      isRowSelected: function isRowSelected(index) {
        return !!(isNumber(index) && this.selectedRows[index]);
      },
      clearSelected: function clearSelected() {
        this.selectedLastClicked = -1;
        this.selectedRows = [];
      },
      // Internal private methods
      selectableRowClasses: function selectableRowClasses(index) {
        if (this.isSelectable && this.isRowSelected(index)) {
          var variant = this.selectedVariant;
          return _defineProperty$j({
            "b-table-row-selected": true
          }, "".concat(this.dark ? "bg" : "table", "-").concat(variant), variant);
        }
        return {};
      },
      selectableRowAttrs: function selectableRowAttrs(index) {
        return {
          "aria-selected": !this.isSelectable ? null : this.isRowSelected(index) ? "true" : "false"
        };
      },
      setSelectionHandlers: function setSelectionHandlers(on) {
        var method = on && !this.noSelectOnClick ? "$on" : "$off";
        this[method](EVENT_NAME_ROW_CLICKED, this.selectionHandler);
        this[method](EVENT_NAME_FILTERED, this.clearSelected);
        this[method](EVENT_NAME_CONTEXT_CHANGED, this.clearSelected);
      },
      selectionHandler: function selectionHandler(item, index, event2) {
        if (!this.isSelectable || this.noSelectOnClick) {
          this.clearSelected();
          return;
        }
        var selectMode = this.selectMode, selectedLastRow = this.selectedLastRow;
        var selectedRows = this.selectedRows.slice();
        var selected = !selectedRows[index];
        if (selectMode === "single") {
          selectedRows = [];
        } else if (selectMode === "range") {
          if (selectedLastRow > -1 && event2.shiftKey) {
            for (var idx = mathMin(selectedLastRow, index); idx <= mathMax(selectedLastRow, index); idx++) {
              selectedRows[idx] = true;
            }
            selected = true;
          } else {
            if (!(event2.ctrlKey || event2.metaKey)) {
              selectedRows = [];
              selected = true;
            }
            if (selected) this.selectedLastRow = index;
          }
        }
        selectedRows[index] = selected;
        this.selectedRows = selectedRows;
      }
    }
  });
  var stableSort$1 = function stableSort2(array, compareFn) {
    return array.map(function(a2, index) {
      return [index, a2];
    }).sort((function(a2, b) {
      return this(a2[1], b[1]) || a2[0] - b[0];
    }).bind(compareFn)).map(function(e2) {
      return e2[1];
    });
  };
  var normalizeValue = function normalizeValue2(value) {
    if (isUndefinedOrNull(value)) {
      return "";
    }
    if (isNumeric$1(value)) {
      return toFloat(value, value);
    }
    return value;
  };
  var defaultSortCompare = function defaultSortCompare2(a2, b) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$sortBy = _ref.sortBy, sortBy = _ref$sortBy === void 0 ? null : _ref$sortBy, _ref$formatter = _ref.formatter, formatter = _ref$formatter === void 0 ? null : _ref$formatter, _ref$locale = _ref.locale, locale = _ref$locale === void 0 ? void 0 : _ref$locale, _ref$localeOptions = _ref.localeOptions, localeOptions = _ref$localeOptions === void 0 ? {} : _ref$localeOptions, _ref$nullLast = _ref.nullLast, nullLast = _ref$nullLast === void 0 ? false : _ref$nullLast;
    var aa = get(a2, sortBy, null);
    var bb = get(b, sortBy, null);
    if (isFunction$1(formatter)) {
      aa = formatter(aa, sortBy, a2);
      bb = formatter(bb, sortBy, b);
    }
    aa = normalizeValue(aa);
    bb = normalizeValue(bb);
    if (isDate(aa) && isDate(bb) || isNumber(aa) && isNumber(bb)) {
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    } else if (nullLast && aa === "" && bb !== "") {
      return 1;
    } else if (nullLast && aa !== "" && bb === "") {
      return -1;
    }
    return stringifyObjectValues(aa).localeCompare(stringifyObjectValues(bb), locale, localeOptions);
  };
  var _props, _watch$3;
  function ownKeys$h(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$h(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
        _defineProperty$i(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$i(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_SORT_BY = "sortBy";
  var MODEL_EVENT_NAME_SORT_BY = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_SORT_BY;
  var MODEL_PROP_NAME_SORT_DESC = "sortDesc";
  var MODEL_EVENT_NAME_SORT_DESC = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_SORT_DESC;
  var SORT_DIRECTION_ASC = "asc";
  var SORT_DIRECTION_DESC = "desc";
  var SORT_DIRECTION_LAST = "last";
  var SORT_DIRECTIONS = [SORT_DIRECTION_ASC, SORT_DIRECTION_DESC, SORT_DIRECTION_LAST];
  var props$k = (_props = {
    labelSortAsc: makeProp(PROP_TYPE_STRING, "Click to sort ascending"),
    labelSortClear: makeProp(PROP_TYPE_STRING, "Click to clear sorting"),
    labelSortDesc: makeProp(PROP_TYPE_STRING, "Click to sort descending"),
    noFooterSorting: makeProp(PROP_TYPE_BOOLEAN, false),
    noLocalSorting: makeProp(PROP_TYPE_BOOLEAN, false),
    // Another prop that should have had a better name
    // It should be `noSortClear` (on non-sortable headers)
    // We will need to make sure the documentation is clear on what
    // this prop does (as well as in the code for future reference)
    noSortReset: makeProp(PROP_TYPE_BOOLEAN, false)
  }, _defineProperty$i(_props, MODEL_PROP_NAME_SORT_BY, makeProp(PROP_TYPE_STRING)), _defineProperty$i(_props, "sortCompare", makeProp(PROP_TYPE_FUNCTION)), _defineProperty$i(_props, "sortCompareLocale", makeProp(PROP_TYPE_ARRAY_STRING)), _defineProperty$i(_props, "sortCompareOptions", makeProp(PROP_TYPE_OBJECT, {
    numeric: true
  })), _defineProperty$i(_props, MODEL_PROP_NAME_SORT_DESC, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$i(_props, "sortDirection", makeProp(PROP_TYPE_STRING, SORT_DIRECTION_ASC, function(value) {
    return arrayIncludes(SORT_DIRECTIONS, value);
  })), _defineProperty$i(_props, "sortIconLeft", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$i(_props, "sortNullLast", makeProp(PROP_TYPE_BOOLEAN, false)), _props);
  var sortingMixin = extend({
    props: props$k,
    data: function data() {
      return {
        localSortBy: this[MODEL_PROP_NAME_SORT_BY] || "",
        localSortDesc: this[MODEL_PROP_NAME_SORT_DESC] || false
      };
    },
    computed: {
      localSorting: function localSorting() {
        return this.hasProvider ? !!this.noProviderSorting : !this.noLocalSorting;
      },
      isSortable: function isSortable() {
        return this.computedFields.some(function(f) {
          return f.sortable;
        });
      },
      // Sorts the filtered items and returns a new array of the sorted items
      // When not sorted, the original items array will be returned
      sortedItems: function sortedItems() {
        var _safeVueInstance = safeVueInstance(this), sortBy = _safeVueInstance.localSortBy, sortDesc = _safeVueInstance.localSortDesc, locale = _safeVueInstance.sortCompareLocale, nullLast = _safeVueInstance.sortNullLast, sortCompare = _safeVueInstance.sortCompare, localSorting = _safeVueInstance.localSorting, filteredItems = _safeVueInstance.filteredItems, localItems = _safeVueInstance.localItems;
        var items = (filteredItems || localItems || []).slice();
        var localeOptions = _objectSpread$h(_objectSpread$h({}, this.sortCompareOptions), {}, {
          usage: "sort"
        });
        if (sortBy && localSorting) {
          var field = this.computedFieldsObj[sortBy] || {};
          var sortByFormatted = field.sortByFormatted;
          var formatter = isFunction$1(sortByFormatted) ? (
            /* istanbul ignore next */
            sortByFormatted
          ) : sortByFormatted ? this.getFieldFormatter(sortBy) : void 0;
          return stableSort$1(items, function(a2, b) {
            var result = null;
            if (isFunction$1(sortCompare)) {
              result = sortCompare(a2, b, sortBy, sortDesc, formatter, localeOptions, locale);
            }
            if (isUndefinedOrNull(result) || result === false) {
              result = defaultSortCompare(a2, b, {
                sortBy,
                formatter,
                locale,
                localeOptions,
                nullLast
              });
            }
            return (result || 0) * (sortDesc ? -1 : 1);
          });
        }
        return items;
      }
    },
    watch: (_watch$3 = {
      /* istanbul ignore next: pain in the butt to test */
      isSortable: function isSortable(newValue) {
        if (newValue) {
          if (this.isSortable) {
            this.$on(EVENT_NAME_HEAD_CLICKED, this.handleSort);
          }
        } else {
          this.$off(EVENT_NAME_HEAD_CLICKED, this.handleSort);
        }
      }
    }, _defineProperty$i(_watch$3, MODEL_PROP_NAME_SORT_DESC, function(newValue) {
      if (newValue === this.localSortDesc) {
        return;
      }
      this.localSortDesc = newValue || false;
    }), _defineProperty$i(_watch$3, MODEL_PROP_NAME_SORT_BY, function(newValue) {
      if (newValue === this.localSortBy) {
        return;
      }
      this.localSortBy = newValue || "";
    }), _defineProperty$i(_watch$3, "localSortDesc", function localSortDesc(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit(MODEL_EVENT_NAME_SORT_DESC, newValue);
      }
    }), _defineProperty$i(_watch$3, "localSortBy", function localSortBy(newValue, oldValue) {
      if (newValue !== oldValue) {
        this.$emit(MODEL_EVENT_NAME_SORT_BY, newValue);
      }
    }), _watch$3),
    created: function created() {
      if (this.isSortable) {
        this.$on(EVENT_NAME_HEAD_CLICKED, this.handleSort);
      }
    },
    methods: {
      // Handlers
      // Need to move from thead-mixin
      handleSort: function handleSort(key, field, event2, isFoot) {
        var _this = this;
        if (!this.isSortable) {
          return;
        }
        if (isFoot && this.noFooterSorting) {
          return;
        }
        var sortChanged = false;
        var toggleLocalSortDesc = function toggleLocalSortDesc2() {
          var sortDirection = field.sortDirection || _this.sortDirection;
          if (sortDirection === SORT_DIRECTION_ASC) {
            _this.localSortDesc = false;
          } else if (sortDirection === SORT_DIRECTION_DESC) {
            _this.localSortDesc = true;
          } else ;
        };
        if (field.sortable) {
          var sortKey = !this.localSorting && field.sortKey ? field.sortKey : key;
          if (this.localSortBy === sortKey) {
            this.localSortDesc = !this.localSortDesc;
          } else {
            this.localSortBy = sortKey;
            toggleLocalSortDesc();
          }
          sortChanged = true;
        } else if (this.localSortBy && !this.noSortReset) {
          this.localSortBy = "";
          toggleLocalSortDesc();
          sortChanged = true;
        }
        if (sortChanged) {
          this.$emit(EVENT_NAME_SORT_CHANGED, this.context);
        }
      },
      // methods to compute classes and attrs for thead>th cells
      sortTheadThClasses: function sortTheadThClasses(key, field, isFoot) {
        return {
          // If sortable and sortIconLeft are true, then place sort icon on the left
          "b-table-sort-icon-left": field.sortable && this.sortIconLeft && !(isFoot && this.noFooterSorting)
        };
      },
      sortTheadThAttrs: function sortTheadThAttrs(key, field, isFoot) {
        var _field$sortKey;
        var isSortable = this.isSortable, noFooterSorting = this.noFooterSorting, localSortDesc = this.localSortDesc, localSortBy = this.localSortBy, localSorting = this.localSorting;
        if (!isSortable || isFoot && noFooterSorting) {
          return {};
        }
        var sortable = field.sortable;
        var sortKey = !localSorting ? (_field$sortKey = field.sortKey) !== null && _field$sortKey !== void 0 ? _field$sortKey : key : key;
        var ariaSort = sortable && localSortBy === sortKey ? localSortDesc ? "descending" : "ascending" : sortable ? "none" : null;
        return {
          "aria-sort": ariaSort
        };
      },
      // A label to be placed in an `.sr-only` element in the header cell
      sortTheadThLabel: function sortTheadThLabel(key, field, isFoot) {
        if (!this.isSortable || isFoot && this.noFooterSorting) {
          return null;
        }
        var localSortBy = this.localSortBy, localSortDesc = this.localSortDesc, labelSortAsc = this.labelSortAsc, labelSortDesc = this.labelSortDesc;
        var sortable = field.sortable;
        var labelSorting = "";
        if (sortable) {
          if (localSortBy === key) {
            labelSorting = localSortDesc ? labelSortAsc : labelSortDesc;
          } else {
            labelSorting = localSortDesc ? labelSortDesc : labelSortAsc;
            var sortDirection = this.sortDirection || field.sortDirection;
            if (sortDirection === SORT_DIRECTION_ASC) {
              labelSorting = labelSortAsc;
            } else if (sortDirection === SORT_DIRECTION_DESC) {
              labelSorting = labelSortDesc;
            }
          }
        } else if (!this.noSortReset) {
          labelSorting = localSortBy ? this.labelSortClear : "";
        }
        return trim(labelSorting) || null;
      }
    }
  });
  function _defineProperty$h(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$j = {
    stacked: makeProp(PROP_TYPE_BOOLEAN_STRING, false)
  };
  var stackedMixin = extend({
    props: props$j,
    computed: {
      isStacked: function isStacked() {
        var stacked = this.stacked;
        return stacked === "" ? true : stacked;
      },
      isStackedAlways: function isStackedAlways() {
        return this.isStacked === true;
      },
      stackedTableClasses: function stackedTableClasses() {
        var isStackedAlways = this.isStackedAlways;
        return _defineProperty$h({
          "b-table-stacked": isStackedAlways
        }, "b-table-stacked-".concat(this.stacked), !isStackedAlways && this.isStacked);
      }
    }
  });
  function ownKeys$g(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$g(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
        _defineProperty$g(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$g(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$i = {
    bordered: makeProp(PROP_TYPE_BOOLEAN, false),
    borderless: makeProp(PROP_TYPE_BOOLEAN, false),
    captionTop: makeProp(PROP_TYPE_BOOLEAN, false),
    dark: makeProp(PROP_TYPE_BOOLEAN, false),
    fixed: makeProp(PROP_TYPE_BOOLEAN, false),
    hover: makeProp(PROP_TYPE_BOOLEAN, false),
    noBorderCollapse: makeProp(PROP_TYPE_BOOLEAN, false),
    outlined: makeProp(PROP_TYPE_BOOLEAN, false),
    responsive: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    small: makeProp(PROP_TYPE_BOOLEAN, false),
    // If a string, it is assumed to be the table `max-height` value
    stickyHeader: makeProp(PROP_TYPE_BOOLEAN_STRING, false),
    striped: makeProp(PROP_TYPE_BOOLEAN, false),
    tableClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    tableVariant: makeProp(PROP_TYPE_STRING)
  };
  var tableRendererMixin = extend({
    mixins: [attrsMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTable: function getBvTable() {
          return _this;
        }
      };
    },
    // Don't place attributes on root element automatically,
    // as table could be wrapped in responsive `<div>`
    inheritAttrs: false,
    props: props$i,
    computed: {
      isTableSimple: function isTableSimple() {
        return false;
      },
      // Layout related computed props
      isResponsive: function isResponsive() {
        var responsive = this.responsive;
        return responsive === "" ? true : responsive;
      },
      isStickyHeader: function isStickyHeader() {
        var stickyHeader = this.stickyHeader;
        stickyHeader = stickyHeader === "" ? true : stickyHeader;
        return this.isStacked ? false : stickyHeader;
      },
      wrapperClasses: function wrapperClasses() {
        var isResponsive = this.isResponsive;
        return [this.isStickyHeader ? "b-table-sticky-header" : "", isResponsive === true ? "table-responsive" : isResponsive ? "table-responsive-".concat(this.responsive) : ""].filter(identity);
      },
      wrapperStyles: function wrapperStyles() {
        var isStickyHeader = this.isStickyHeader;
        return isStickyHeader && !isBoolean(isStickyHeader) ? {
          maxHeight: isStickyHeader
        } : {};
      },
      tableClasses: function tableClasses() {
        var _safeVueInstance = safeVueInstance(this), hover = _safeVueInstance.hover, tableVariant = _safeVueInstance.tableVariant, selectableTableClasses = _safeVueInstance.selectableTableClasses, stackedTableClasses = _safeVueInstance.stackedTableClasses, tableClass = _safeVueInstance.tableClass, computedBusy = _safeVueInstance.computedBusy;
        hover = this.isTableSimple ? hover : hover && this.computedItems.length > 0 && !computedBusy;
        return [
          // User supplied classes
          tableClass,
          // Styling classes
          {
            "table-striped": this.striped,
            "table-hover": hover,
            "table-dark": this.dark,
            "table-bordered": this.bordered,
            "table-borderless": this.borderless,
            "table-sm": this.small,
            // The following are b-table custom styles
            border: this.outlined,
            "b-table-fixed": this.fixed,
            "b-table-caption-top": this.captionTop,
            "b-table-no-border-collapse": this.noBorderCollapse
          },
          tableVariant ? "".concat(this.dark ? "bg" : "table", "-").concat(tableVariant) : "",
          // Stacked table classes
          stackedTableClasses,
          // Selectable classes
          selectableTableClasses
        ];
      },
      tableAttrs: function tableAttrs() {
        var _safeVueInstance2 = safeVueInstance(this), items = _safeVueInstance2.computedItems, filteredItems = _safeVueInstance2.filteredItems, fields = _safeVueInstance2.computedFields, selectableTableAttrs = _safeVueInstance2.selectableTableAttrs, computedBusy = _safeVueInstance2.computedBusy;
        var ariaAttrs = this.isTableSimple ? {} : {
          "aria-busy": toString(computedBusy),
          "aria-colcount": toString(fields.length),
          // Preserve user supplied `aria-describedby`, if provided
          "aria-describedby": this.bvAttrs["aria-describedby"] || this.$refs.caption ? this.captionId : null
        };
        var rowCount = items && filteredItems && filteredItems.length > items.length ? toString(filteredItems.length) : null;
        return _objectSpread$g(_objectSpread$g(_objectSpread$g({
          // We set `aria-rowcount` before merging in `$attrs`,
          // in case user has supplied their own
          "aria-rowcount": rowCount
        }, this.bvAttrs), {}, {
          // Now we can override any `$attrs` here
          id: this.safeId(),
          role: this.bvAttrs.role || "table"
        }, ariaAttrs), selectableTableAttrs);
      }
    },
    render: function render(h) {
      var _safeVueInstance3 = safeVueInstance(this), wrapperClasses = _safeVueInstance3.wrapperClasses, renderCaption = _safeVueInstance3.renderCaption, renderColgroup = _safeVueInstance3.renderColgroup, renderThead = _safeVueInstance3.renderThead, renderTbody = _safeVueInstance3.renderTbody, renderTfoot = _safeVueInstance3.renderTfoot;
      var $content = [];
      if (this.isTableSimple) {
        $content.push(this.normalizeSlot());
      } else {
        $content.push(renderCaption ? renderCaption() : null);
        $content.push(renderColgroup ? renderColgroup() : null);
        $content.push(renderThead ? renderThead() : null);
        $content.push(renderTbody ? renderTbody() : null);
        $content.push(renderTfoot ? renderTfoot() : null);
      }
      var $table = h("table", {
        staticClass: "table b-table",
        class: this.tableClasses,
        attrs: this.tableAttrs,
        key: "b-table"
      }, $content.filter(identity));
      return wrapperClasses.length > 0 ? h("div", {
        class: wrapperClasses,
        style: this.wrapperStyles,
        key: "wrap"
      }, [$table]) : $table;
    }
  });
  function ownKeys$f(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$f(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
        _defineProperty$f(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$f(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$h = makePropsConfigurable({
    tbodyTransitionHandlers: makeProp(PROP_TYPE_OBJECT),
    tbodyTransitionProps: makeProp(PROP_TYPE_OBJECT)
  }, NAME_TBODY);
  var BTbody = /* @__PURE__ */ extend({
    name: NAME_TBODY,
    mixins: [attrsMixin, listenersMixin, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTableRowGroup: function getBvTableRowGroup() {
          return _this;
        }
      };
    },
    inject: {
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      getBvTable: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    inheritAttrs: false,
    props: props$h,
    computed: {
      bvTable: function bvTable() {
        return this.getBvTable();
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isTbody: function isTbody() {
        return true;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isDark: function isDark() {
        return this.bvTable.dark;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isStacked: function isStacked() {
        return this.bvTable.isStacked;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isResponsive: function isResponsive() {
        return this.bvTable.isResponsive;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Sticky headers are only supported in thead
      isStickyHeader: function isStickyHeader() {
        return false;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      hasStickyHeader: function hasStickyHeader() {
        return !this.isStacked && this.bvTable.stickyHeader;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      tableVariant: function tableVariant() {
        return this.bvTable.tableVariant;
      },
      isTransitionGroup: function isTransitionGroup() {
        return this.tbodyTransitionProps || this.tbodyTransitionHandlers;
      },
      tbodyAttrs: function tbodyAttrs() {
        return _objectSpread$f({
          role: "rowgroup"
        }, this.bvAttrs);
      },
      tbodyProps: function tbodyProps() {
        var tbodyTransitionProps = this.tbodyTransitionProps;
        return tbodyTransitionProps ? _objectSpread$f(_objectSpread$f({}, tbodyTransitionProps), {}, {
          tag: "tbody"
        }) : {};
      }
    },
    render: function render(h) {
      var data = {
        props: this.tbodyProps,
        attrs: this.tbodyAttrs
      };
      if (this.isTransitionGroup) {
        data.on = this.tbodyTransitionHandlers || {};
        data.nativeOn = this.bvListeners;
      } else {
        data.on = this.bvListeners;
      }
      return h(this.isTransitionGroup ? "transition-group" : "tbody", data, this.normalizeSlot());
    }
  });
  var TABLE_TAG_NAMES = ["TD", "TH", "TR"];
  var filterEvent = function filterEvent2(event2) {
    if (!event2 || !event2.target) {
      return false;
    }
    var el = event2.target;
    if (el.disabled || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {
      return false;
    }
    if (closest(".dropdown-menu", el)) {
      return true;
    }
    var label = el.tagName === "LABEL" ? el : closest("label", el);
    if (label) {
      var labelFor = getAttr(label, "for");
      var input = labelFor ? getById(labelFor) : select("input, select, textarea", label);
      if (input && !input.disabled) {
        return true;
      }
    }
    return matches(el, EVENT_FILTER);
  };
  var textSelectionActive = function textSelectionActive2() {
    var el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : document;
    var sel = getSel();
    return sel && sel.toString().trim() !== "" && sel.containsNode && isElement(el) ? (
      /* istanbul ignore next */
      sel.containsNode(el, true)
    ) : false;
  };
  var props$g = makePropsConfigurable(props$u, NAME_TH);
  var BTh = /* @__PURE__ */ extend({
    name: NAME_TH,
    extends: BTd,
    props: props$g,
    computed: {
      tag: function tag() {
        return "th";
      }
    }
  });
  function ownKeys$e(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$e(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
        _defineProperty$e(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$e(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray$3(arr) {
    return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$3();
  }
  function _nonIterableSpread$3() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$2(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen);
  }
  function _iterableToArray$3(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$3(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$2(arr);
  }
  function _arrayLikeToArray$2(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var props$f = {
    detailsTdClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    tbodyTrAttr: makeProp(PROP_TYPE_OBJECT_FUNCTION),
    tbodyTrClass: makeProp([].concat(_toConsumableArray$3(PROP_TYPE_ARRAY_OBJECT_STRING), [PROP_TYPE_FUNCTION]))
  };
  var tbodyRowMixin = extend({
    mixins: [useParentMixin],
    props: props$f,
    methods: {
      // Methods for computing classes, attributes and styles for table cells
      getTdValues: function getTdValues(item, key, tdValue, defaultValue) {
        var bvParent = this.bvParent;
        if (tdValue) {
          var value = get(item, key, "");
          if (isFunction$1(tdValue)) {
            return tdValue(value, key, item);
          } else if (isString(tdValue) && isFunction$1(bvParent[tdValue])) {
            return bvParent[tdValue](value, key, item);
          }
          return tdValue;
        }
        return defaultValue;
      },
      getThValues: function getThValues(item, key, thValue, type, defaultValue) {
        var bvParent = this.bvParent;
        if (thValue) {
          var value = get(item, key, "");
          if (isFunction$1(thValue)) {
            return thValue(value, key, item, type);
          } else if (isString(thValue) && isFunction$1(bvParent[thValue])) {
            return bvParent[thValue](value, key, item, type);
          }
          return thValue;
        }
        return defaultValue;
      },
      // Method to get the value for a field
      getFormattedValue: function getFormattedValue(item, field) {
        var key = field.key;
        var formatter = this.getFieldFormatter(key);
        var value = get(item, key, null);
        if (isFunction$1(formatter)) {
          value = formatter(value, key, item);
        }
        return isUndefinedOrNull(value) ? "" : value;
      },
      // Factory function methods
      toggleDetailsFactory: function toggleDetailsFactory(hasDetailsSlot, item) {
        var _this = this;
        return function() {
          if (hasDetailsSlot) {
            _this.$set(item, FIELD_KEY_SHOW_DETAILS, !item[FIELD_KEY_SHOW_DETAILS]);
          }
        };
      },
      // Row event handlers
      rowHovered: function rowHovered(event2) {
        if (!this.tbodyRowEventStopped(event2)) {
          this.emitTbodyRowEvent(EVENT_NAME_ROW_HOVERED, event2);
        }
      },
      rowUnhovered: function rowUnhovered(event2) {
        if (!this.tbodyRowEventStopped(event2)) {
          this.emitTbodyRowEvent(EVENT_NAME_ROW_UNHOVERED, event2);
        }
      },
      // Renders a TD or TH for a row's field
      renderTbodyRowCell: function renderTbodyRowCell(field, colIndex, item, rowIndex) {
        var _this2 = this;
        var isStacked = this.isStacked;
        var key = field.key, label = field.label, isRowHeader = field.isRowHeader;
        var h = this.$createElement;
        var hasDetailsSlot = this.hasNormalizedSlot(SLOT_NAME_ROW_DETAILS);
        var formatted = this.getFormattedValue(item, field);
        var stickyColumn = !isStacked && (this.isResponsive || this.stickyHeader) && field.stickyColumn;
        var cellTag = stickyColumn ? isRowHeader ? BTh : BTd : isRowHeader ? "th" : "td";
        var cellVariant = item[FIELD_KEY_CELL_VARIANT] && item[FIELD_KEY_CELL_VARIANT][key] ? item[FIELD_KEY_CELL_VARIANT][key] : field.variant || null;
        var data = {
          // For the Vue key, we concatenate the column index and
          // field key (as field keys could be duplicated)
          // TODO: Although we do prevent duplicate field keys...
          //   So we could change this to: `row-${rowIndex}-cell-${key}`
          class: [field.class ? field.class : "", this.getTdValues(item, key, field.tdClass, "")],
          props: {},
          attrs: _objectSpread$e({
            "aria-colindex": String(colIndex + 1)
          }, isRowHeader ? this.getThValues(item, key, field.thAttr, "row", {}) : this.getTdValues(item, key, field.tdAttr, {})),
          key: "row-".concat(rowIndex, "-cell-").concat(colIndex, "-").concat(key)
        };
        if (stickyColumn) {
          data.props = {
            stackedHeading: isStacked ? label : null,
            stickyColumn: true,
            variant: cellVariant
          };
        } else {
          data.attrs["data-label"] = isStacked && !isUndefinedOrNull(label) ? toString(label) : null;
          data.attrs.role = isRowHeader ? "rowheader" : "cell";
          data.attrs.scope = isRowHeader ? "row" : null;
          if (cellVariant) {
            data.class.push("".concat(this.dark ? "bg" : "table", "-").concat(cellVariant));
          }
        }
        var slotScope = {
          item,
          index: rowIndex,
          field,
          unformatted: get(item, key, ""),
          value: formatted,
          toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item),
          detailsShowing: Boolean(item[FIELD_KEY_SHOW_DETAILS])
        };
        if (safeVueInstance(this).supportsSelectableRows) {
          slotScope.rowSelected = this.isRowSelected(rowIndex);
          slotScope.selectRow = function() {
            return _this2.selectRow(rowIndex);
          };
          slotScope.unselectRow = function() {
            return _this2.unselectRow(rowIndex);
          };
        }
        var slotName = this.$_bodyFieldSlotNameCache[key];
        var $childNodes = slotName ? this.normalizeSlot(slotName, slotScope) : toString(formatted);
        if (this.isStacked) {
          $childNodes = [h("div", [$childNodes])];
        }
        return h(cellTag, data, [$childNodes]);
      },
      // Renders an item's row (or rows if details supported)
      renderTbodyRow: function renderTbodyRow(item, rowIndex) {
        var _this3 = this;
        var _safeVueInstance = safeVueInstance(this), fields = _safeVueInstance.computedFields, striped = _safeVueInstance.striped, primaryKey = _safeVueInstance.primaryKey, currentPage = _safeVueInstance.currentPage, perPage = _safeVueInstance.perPage, tbodyTrClass = _safeVueInstance.tbodyTrClass, tbodyTrAttr = _safeVueInstance.tbodyTrAttr, hasSelectableRowClick = _safeVueInstance.hasSelectableRowClick;
        var h = this.$createElement;
        var hasDetailsSlot = this.hasNormalizedSlot(SLOT_NAME_ROW_DETAILS);
        var rowShowDetails = item[FIELD_KEY_SHOW_DETAILS] && hasDetailsSlot;
        var hasRowClickHandler = this.$listeners[EVENT_NAME_ROW_CLICKED] || hasSelectableRowClick;
        var $rows = [];
        var detailsId = rowShowDetails ? this.safeId("_details_".concat(rowIndex, "_")) : null;
        var $tds = fields.map(function(field, colIndex) {
          return _this3.renderTbodyRowCell(field, colIndex, item, rowIndex);
        });
        var ariaRowIndex = null;
        if (currentPage && perPage && perPage > 0) {
          ariaRowIndex = String((currentPage - 1) * perPage + rowIndex + 1);
        }
        var primaryKeyValue = toString(get(item, primaryKey)) || null;
        var rowKey = primaryKeyValue || toString(rowIndex);
        var rowId = primaryKeyValue ? this.safeId("_row_".concat(primaryKeyValue)) : null;
        var selectableClasses = safeVueInstance(this).selectableRowClasses ? this.selectableRowClasses(rowIndex) : {};
        var selectableAttrs = safeVueInstance(this).selectableRowAttrs ? this.selectableRowAttrs(rowIndex) : {};
        var userTrClasses = isFunction$1(tbodyTrClass) ? tbodyTrClass(item, "row") : tbodyTrClass;
        var userTrAttrs = isFunction$1(tbodyTrAttr) ? (
          /* istanbul ignore next */
          tbodyTrAttr(item, "row")
        ) : tbodyTrAttr;
        $rows.push(h(BTr, _defineProperty$e({
          class: [userTrClasses, selectableClasses, rowShowDetails ? "b-table-has-details" : ""],
          props: {
            variant: item[FIELD_KEY_ROW_VARIANT] || null
          },
          attrs: _objectSpread$e(_objectSpread$e({
            id: rowId
          }, userTrAttrs), {}, {
            // Users cannot override the following attributes
            tabindex: hasRowClickHandler ? "0" : null,
            "data-pk": primaryKeyValue || null,
            "aria-details": detailsId,
            "aria-owns": detailsId,
            "aria-rowindex": ariaRowIndex
          }, selectableAttrs),
          on: {
            // Note: These events are not A11Y friendly!
            mouseenter: this.rowHovered,
            mouseleave: this.rowUnhovered
          },
          key: "__b-table-row-".concat(rowKey, "__"),
          ref: "item-rows"
        }, REF_FOR_KEY, true), $tds));
        if (rowShowDetails) {
          var detailsScope = {
            item,
            index: rowIndex,
            fields,
            toggleDetails: this.toggleDetailsFactory(hasDetailsSlot, item)
          };
          if (safeVueInstance(this).supportsSelectableRows) {
            detailsScope.rowSelected = this.isRowSelected(rowIndex);
            detailsScope.selectRow = function() {
              return _this3.selectRow(rowIndex);
            };
            detailsScope.unselectRow = function() {
              return _this3.unselectRow(rowIndex);
            };
          }
          var $details = h(BTd, {
            props: {
              colspan: fields.length
            },
            class: this.detailsTdClass
          }, [this.normalizeSlot(SLOT_NAME_ROW_DETAILS, detailsScope)]);
          if (striped) {
            $rows.push(
              // We don't use `BTr` here as we don't need the extra functionality
              h("tr", {
                staticClass: "d-none",
                attrs: {
                  "aria-hidden": "true",
                  role: "presentation"
                },
                key: "__b-table-details-stripe__".concat(rowKey)
              })
            );
          }
          var userDetailsTrClasses = isFunction$1(this.tbodyTrClass) ? (
            /* istanbul ignore next */
            this.tbodyTrClass(item, SLOT_NAME_ROW_DETAILS)
          ) : this.tbodyTrClass;
          var userDetailsTrAttrs = isFunction$1(this.tbodyTrAttr) ? (
            /* istanbul ignore next */
            this.tbodyTrAttr(item, SLOT_NAME_ROW_DETAILS)
          ) : this.tbodyTrAttr;
          $rows.push(h(BTr, {
            staticClass: "b-table-details",
            class: [userDetailsTrClasses],
            props: {
              variant: item[FIELD_KEY_ROW_VARIANT] || null
            },
            attrs: _objectSpread$e(_objectSpread$e({}, userDetailsTrAttrs), {}, {
              // Users cannot override the following attributes
              id: detailsId,
              tabindex: "-1"
            }),
            key: "__b-table-details__".concat(rowKey)
          }, [$details]));
        } else if (hasDetailsSlot) {
          $rows.push(h());
          if (striped) {
            $rows.push(h());
          }
        }
        return $rows;
      }
    }
  });
  function ownKeys$d(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$d(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
        _defineProperty$d(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$d(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var getCellSlotName = function getCellSlotName2(value) {
    return "cell(".concat(value || "", ")");
  };
  var props$e = sortKeys(_objectSpread$d(_objectSpread$d(_objectSpread$d({}, props$h), props$f), {}, {
    tbodyClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  }));
  var tbodyMixin = extend({
    mixins: [tbodyRowMixin],
    props: props$e,
    beforeDestroy: function beforeDestroy() {
      this.$_bodyFieldSlotNameCache = null;
    },
    methods: {
      // Returns all the item TR elements (excludes detail and spacer rows)
      // `this.$refs['item-rows']` is an array of item TR components/elements
      // Rows should all be `<b-tr>` components, but we map to TR elements
      // Also note that `this.$refs['item-rows']` may not always be in document order
      getTbodyTrs: function getTbodyTrs() {
        var $refs = this.$refs;
        var tbody = $refs.tbody ? $refs.tbody.$el || $refs.tbody : null;
        var trs = ($refs["item-rows"] || []).map(function(tr) {
          return tr.$el || tr;
        });
        return tbody && tbody.children && tbody.children.length > 0 && trs && trs.length > 0 ? from(tbody.children).filter(function(tr) {
          return arrayIncludes(trs, tr);
        }) : (
          /* istanbul ignore next */
          []
        );
      },
      // Returns index of a particular TBODY item TR
      // We set `true` on closest to include self in result
      getTbodyTrIndex: function getTbodyTrIndex(el) {
        if (!isElement(el)) {
          return -1;
        }
        var tr = el.tagName === "TR" ? el : closest("tr", el, true);
        return tr ? this.getTbodyTrs().indexOf(tr) : -1;
      },
      // Emits a row event, with the item object, row index and original event
      emitTbodyRowEvent: function emitTbodyRowEvent(type, event2) {
        if (type && this.hasListener(type) && event2 && event2.target) {
          var rowIndex = this.getTbodyTrIndex(event2.target);
          if (rowIndex > -1) {
            var item = this.computedItems[rowIndex];
            this.$emit(type, item, rowIndex, event2);
          }
        }
      },
      tbodyRowEventStopped: function tbodyRowEventStopped(event2) {
        return this.stopIfBusy && this.stopIfBusy(event2);
      },
      // Delegated row event handlers
      onTbodyRowKeydown: function onTbodyRowKeydown(event2) {
        var target = event2.target, keyCode = event2.keyCode;
        if (this.tbodyRowEventStopped(event2) || target.tagName !== "TR" || !isActiveElement(target) || target.tabIndex !== 0) {
          return;
        }
        if (arrayIncludes([CODE_ENTER, CODE_SPACE], keyCode)) {
          stopEvent(event2);
          this.onTBodyRowClicked(event2);
        } else if (arrayIncludes([CODE_UP, CODE_DOWN, CODE_HOME, CODE_END], keyCode)) {
          var rowIndex = this.getTbodyTrIndex(target);
          if (rowIndex > -1) {
            stopEvent(event2);
            var trs = this.getTbodyTrs();
            var shift2 = event2.shiftKey;
            if (keyCode === CODE_HOME || shift2 && keyCode === CODE_UP) {
              attemptFocus(trs[0]);
            } else if (keyCode === CODE_END || shift2 && keyCode === CODE_DOWN) {
              attemptFocus(trs[trs.length - 1]);
            } else if (keyCode === CODE_UP && rowIndex > 0) {
              attemptFocus(trs[rowIndex - 1]);
            } else if (keyCode === CODE_DOWN && rowIndex < trs.length - 1) {
              attemptFocus(trs[rowIndex + 1]);
            }
          }
        }
      },
      onTBodyRowClicked: function onTBodyRowClicked(event2) {
        var $refs = this.$refs;
        var tbody = $refs.tbody ? $refs.tbody.$el || $refs.tbody : null;
        if (this.tbodyRowEventStopped(event2) || filterEvent(event2) || textSelectionActive(tbody || this.$el)) {
          return;
        }
        this.emitTbodyRowEvent(EVENT_NAME_ROW_CLICKED, event2);
      },
      onTbodyRowMiddleMouseRowClicked: function onTbodyRowMiddleMouseRowClicked(event2) {
        if (!this.tbodyRowEventStopped(event2) && event2.which === 2) {
          this.emitTbodyRowEvent(EVENT_NAME_ROW_MIDDLE_CLICKED, event2);
        }
      },
      onTbodyRowContextmenu: function onTbodyRowContextmenu(event2) {
        if (!this.tbodyRowEventStopped(event2)) {
          this.emitTbodyRowEvent(EVENT_NAME_ROW_CONTEXTMENU, event2);
        }
      },
      onTbodyRowDblClicked: function onTbodyRowDblClicked(event2) {
        if (!this.tbodyRowEventStopped(event2) && !filterEvent(event2)) {
          this.emitTbodyRowEvent(EVENT_NAME_ROW_DBLCLICKED, event2);
        }
      },
      // Render the tbody element and children
      // Note:
      //   Row hover handlers are handled by the tbody-row mixin
      //   As mouseenter/mouseleave events do not bubble
      renderTbody: function renderTbody() {
        var _this = this;
        var _safeVueInstance = safeVueInstance(this), items = _safeVueInstance.computedItems, renderBusy = _safeVueInstance.renderBusy, renderTopRow = _safeVueInstance.renderTopRow, renderEmpty = _safeVueInstance.renderEmpty, renderBottomRow = _safeVueInstance.renderBottomRow, hasSelectableRowClick = _safeVueInstance.hasSelectableRowClick;
        var h = this.$createElement;
        var hasRowClickHandler = this.hasListener(EVENT_NAME_ROW_CLICKED) || hasSelectableRowClick;
        var $rows = [];
        var $busy = renderBusy ? renderBusy() : null;
        if ($busy) {
          $rows.push($busy);
        } else {
          var cache = {};
          var defaultSlotName = getCellSlotName();
          defaultSlotName = this.hasNormalizedSlot(defaultSlotName) ? defaultSlotName : null;
          this.computedFields.forEach(function(field) {
            var key = field.key;
            var slotName = getCellSlotName(key);
            var lowercaseSlotName = getCellSlotName(key.toLowerCase());
            cache[key] = _this.hasNormalizedSlot(slotName) ? slotName : _this.hasNormalizedSlot(lowercaseSlotName) ? (
              /* istanbul ignore next */
              lowercaseSlotName
            ) : defaultSlotName;
          });
          this.$_bodyFieldSlotNameCache = cache;
          $rows.push(renderTopRow ? renderTopRow() : h());
          items.forEach(function(item, rowIndex) {
            $rows.push(_this.renderTbodyRow(item, rowIndex));
          });
          $rows.push(renderEmpty ? renderEmpty() : h());
          $rows.push(renderBottomRow ? renderBottomRow() : h());
        }
        var handlers = {
          auxclick: this.onTbodyRowMiddleMouseRowClicked,
          // TODO:
          //   Perhaps we do want to automatically prevent the
          //   default context menu from showing if there is a
          //   `row-contextmenu` listener registered
          contextmenu: this.onTbodyRowContextmenu,
          // The following event(s) is not considered A11Y friendly
          dblclick: this.onTbodyRowDblClicked
          // Hover events (`mouseenter`/`mouseleave`) are handled by `tbody-row` mixin
        };
        if (hasRowClickHandler) {
          handlers.click = this.onTBodyRowClicked;
          handlers.keydown = this.onTbodyRowKeydown;
        }
        var $tbody = h(BTbody, {
          class: this.tbodyClass || null,
          props: pluckProps(props$h, this.$props),
          // BTbody transfers all native event listeners to the root element
          // TODO: Only set the handlers if the table is not busy
          on: handlers,
          ref: "tbody"
        }, $rows);
        return $tbody;
      }
    }
  });
  function ownKeys$c(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$c(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
        _defineProperty$c(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$c(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$d = makePropsConfigurable({
    // Supported values: 'lite', 'dark', or null
    footVariant: makeProp(PROP_TYPE_STRING)
  }, NAME_TFOOT);
  var BTfoot = /* @__PURE__ */ extend({
    name: NAME_TFOOT,
    mixins: [attrsMixin, listenersMixin, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTableRowGroup: function getBvTableRowGroup() {
          return _this;
        }
      };
    },
    inject: {
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      getBvTable: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    inheritAttrs: false,
    props: props$d,
    computed: {
      bvTable: function bvTable() {
        return this.getBvTable();
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isTfoot: function isTfoot() {
        return true;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isDark: function isDark() {
        return this.bvTable.dark;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isStacked: function isStacked() {
        return this.bvTable.isStacked;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isResponsive: function isResponsive() {
        return this.bvTable.isResponsive;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Sticky headers are only supported in thead
      isStickyHeader: function isStickyHeader() {
        return false;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      hasStickyHeader: function hasStickyHeader() {
        return !this.isStacked && this.bvTable.stickyHeader;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      tableVariant: function tableVariant() {
        return this.bvTable.tableVariant;
      },
      tfootClasses: function tfootClasses() {
        return [this.footVariant ? "thead-".concat(this.footVariant) : null];
      },
      tfootAttrs: function tfootAttrs() {
        return _objectSpread$c(_objectSpread$c({}, this.bvAttrs), {}, {
          role: "rowgroup"
        });
      }
    },
    render: function render(h) {
      return h("tfoot", {
        class: this.tfootClasses,
        attrs: this.tfootAttrs,
        // Pass down any native listeners
        on: this.bvListeners
      }, this.normalizeSlot());
    }
  });
  var props$c = {
    footClone: makeProp(PROP_TYPE_BOOLEAN, false),
    // Any Bootstrap theme variant (or custom)
    // Falls back to `headRowVariant`
    footRowVariant: makeProp(PROP_TYPE_STRING),
    // 'dark', 'light', or `null` (or custom)
    footVariant: makeProp(PROP_TYPE_STRING),
    tfootClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    tfootTrClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  };
  var tfootMixin = extend({
    props: props$c,
    methods: {
      renderTFootCustom: function renderTFootCustom() {
        var h = this.$createElement;
        if (this.hasNormalizedSlot(SLOT_NAME_CUSTOM_FOOT)) {
          return h(BTfoot, {
            class: this.tfootClass || null,
            props: {
              footVariant: this.footVariant || this.headVariant || null
            },
            key: "bv-tfoot-custom"
          }, this.normalizeSlot(SLOT_NAME_CUSTOM_FOOT, {
            items: this.computedItems.slice(),
            fields: this.computedFields.slice(),
            columns: this.computedFields.length
          }));
        }
        return h();
      },
      renderTfoot: function renderTfoot() {
        return this.footClone ? this.renderThead(true) : this.renderTFootCustom();
      }
    }
  });
  function ownKeys$b(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
        _defineProperty$b(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$b(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$b = makePropsConfigurable({
    // Also sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
    // Supported values: 'lite', 'dark', or `null`
    headVariant: makeProp(PROP_TYPE_STRING)
  }, NAME_THEAD);
  var BThead = /* @__PURE__ */ extend({
    name: NAME_THEAD,
    mixins: [attrsMixin, listenersMixin, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTableRowGroup: function getBvTableRowGroup() {
          return _this;
        }
      };
    },
    inject: {
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      getBvTable: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    inheritAttrs: false,
    props: props$b,
    computed: {
      bvTable: function bvTable() {
        return this.getBvTable();
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isThead: function isThead() {
        return true;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isDark: function isDark() {
        return this.bvTable.dark;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isStacked: function isStacked() {
        return this.bvTable.isStacked;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      isResponsive: function isResponsive() {
        return this.bvTable.isResponsive;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      // Sticky headers only apply to cells in table `thead`
      isStickyHeader: function isStickyHeader() {
        return !this.isStacked && this.bvTable.stickyHeader;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      // Needed to handle header background classes, due to lack of
      // background color inheritance with Bootstrap v4 table CSS
      hasStickyHeader: function hasStickyHeader() {
        return !this.isStacked && this.bvTable.stickyHeader;
      },
      // Sniffed by `<b-tr>` / `<b-td>` / `<b-th>`
      tableVariant: function tableVariant() {
        return this.bvTable.tableVariant;
      },
      theadClasses: function theadClasses() {
        return [this.headVariant ? "thead-".concat(this.headVariant) : null];
      },
      theadAttrs: function theadAttrs() {
        return _objectSpread$b({
          role: "rowgroup"
        }, this.bvAttrs);
      }
    },
    render: function render(h) {
      return h("thead", {
        class: this.theadClasses,
        attrs: this.theadAttrs,
        // Pass down any native listeners
        on: this.bvListeners
      }, this.normalizeSlot());
    }
  });
  function _toConsumableArray$2(arr) {
    return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$2();
  }
  function _nonIterableSpread$2() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }
  function _iterableToArray$2(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles$2(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function ownKeys$a(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
        _defineProperty$a(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$a(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var getHeadSlotName = function getHeadSlotName2(value) {
    return "head(".concat(value || "", ")");
  };
  var getFootSlotName = function getFootSlotName2(value) {
    return "foot(".concat(value || "", ")");
  };
  var props$a = {
    // Any Bootstrap theme variant (or custom)
    headRowVariant: makeProp(PROP_TYPE_STRING),
    // 'light', 'dark' or `null` (or custom)
    headVariant: makeProp(PROP_TYPE_STRING),
    theadClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    theadTrClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)
  };
  var theadMixin = extend({
    props: props$a,
    methods: {
      fieldClasses: function fieldClasses(field) {
        return [field.class ? field.class : "", field.thClass ? field.thClass : ""];
      },
      headClicked: function headClicked(event2, field, isFoot) {
        if (this.stopIfBusy && this.stopIfBusy(event2)) {
          return;
        } else if (filterEvent(event2)) {
          return;
        } else if (textSelectionActive(this.$el)) {
          return;
        }
        stopEvent(event2);
        this.$emit(EVENT_NAME_HEAD_CLICKED, field.key, field, event2, isFoot);
      },
      renderThead: function renderThead() {
        var _this = this;
        var isFoot = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var _safeVueInstance = safeVueInstance(this), fields = _safeVueInstance.computedFields, isSortable = _safeVueInstance.isSortable, isSelectable = _safeVueInstance.isSelectable, headVariant = _safeVueInstance.headVariant, footVariant = _safeVueInstance.footVariant, headRowVariant = _safeVueInstance.headRowVariant, footRowVariant = _safeVueInstance.footRowVariant;
        var h = this.$createElement;
        if (this.isStackedAlways || fields.length === 0) {
          return h();
        }
        var hasHeadClickListener = isSortable || this.hasListener(EVENT_NAME_HEAD_CLICKED);
        var selectAllRows = isSelectable ? this.selectAllRows : noop;
        var clearSelected = isSelectable ? this.clearSelected : noop;
        var makeCell = function makeCell2(field, colIndex) {
          var label = field.label, labelHtml = field.labelHtml, variant = field.variant, stickyColumn = field.stickyColumn, key = field.key;
          var ariaLabel = null;
          if (!field.label.trim() && !field.headerTitle) {
            ariaLabel = startCase(field.key);
          }
          var on = {};
          if (hasHeadClickListener) {
            on.click = function(event2) {
              _this.headClicked(event2, field, isFoot);
            };
            on.keydown = function(event2) {
              var keyCode = event2.keyCode;
              if (keyCode === CODE_ENTER || keyCode === CODE_SPACE) {
                _this.headClicked(event2, field, isFoot);
              }
            };
          }
          var sortAttrs = isSortable ? _this.sortTheadThAttrs(key, field, isFoot) : {};
          var sortClass = isSortable ? _this.sortTheadThClasses(key, field, isFoot) : null;
          var sortLabel = isSortable ? _this.sortTheadThLabel(key, field, isFoot) : null;
          var data = {
            class: [{
              // We need to make the header cell relative when we have
              // a `.sr-only` sort label to work around overflow issues
              "position-relative": sortLabel
            }, _this.fieldClasses(field), sortClass],
            props: {
              variant,
              stickyColumn
            },
            style: field.thStyle || {},
            attrs: _objectSpread$a(_objectSpread$a({
              // We only add a `tabindex` of `0` if there is a head-clicked listener
              // and the current field is sortable
              tabindex: hasHeadClickListener && field.sortable ? "0" : null,
              abbr: field.headerAbbr || null,
              title: field.headerTitle || null,
              "aria-colindex": colIndex + 1,
              "aria-label": ariaLabel
            }, _this.getThValues(null, key, field.thAttr, isFoot ? "foot" : "head", {})), sortAttrs),
            on,
            key
          };
          var slotNames = [getHeadSlotName(key), getHeadSlotName(key.toLowerCase()), getHeadSlotName()];
          if (isFoot) {
            slotNames = [getFootSlotName(key), getFootSlotName(key.toLowerCase()), getFootSlotName()].concat(_toConsumableArray$2(slotNames));
          }
          var scope2 = {
            label,
            column: key,
            field,
            isFoot,
            // Add in row select methods
            selectAllRows,
            clearSelected
          };
          var $content = _this.normalizeSlot(slotNames, scope2) || h("div", {
            domProps: htmlOrText(labelHtml, label)
          });
          var $srLabel = sortLabel ? h("span", {
            staticClass: "sr-only"
          }, " (".concat(sortLabel, ")")) : null;
          return h(BTh, data, [$content, $srLabel].filter(identity));
        };
        var $cells = fields.map(makeCell).filter(identity);
        var $trs = [];
        if (isFoot) {
          $trs.push(h(BTr, {
            class: this.tfootTrClass,
            props: {
              variant: isUndefinedOrNull(footRowVariant) ? headRowVariant : (
                /* istanbul ignore next */
                footRowVariant
              )
            }
          }, $cells));
        } else {
          var scope = {
            columns: fields.length,
            fields,
            // Add in row select methods
            selectAllRows,
            clearSelected
          };
          $trs.push(this.normalizeSlot(SLOT_NAME_THEAD_TOP, scope) || h());
          $trs.push(h(BTr, {
            class: this.theadTrClass,
            props: {
              variant: headRowVariant
            }
          }, $cells));
        }
        return h(isFoot ? BTfoot : BThead, {
          class: (isFoot ? this.tfootClass : this.theadClass) || null,
          props: isFoot ? {
            footVariant: footVariant || headVariant || null
          } : {
            headVariant: headVariant || null
          },
          key: isFoot ? "bv-tfoot" : "bv-thead"
        }, $trs);
      }
    }
  });
  var props$9 = {};
  var topRowMixin = extend({
    methods: {
      renderTopRow: function renderTopRow() {
        var fields = this.computedFields, stacked = this.stacked, tbodyTrClass = this.tbodyTrClass, tbodyTrAttr = this.tbodyTrAttr;
        var h = this.$createElement;
        if (!this.hasNormalizedSlot(SLOT_NAME_TOP_ROW) || stacked === true || stacked === "") {
          return h();
        }
        return h(BTr, {
          staticClass: "b-table-top-row",
          class: [isFunction$1(tbodyTrClass) ? tbodyTrClass(null, "row-top") : tbodyTrClass],
          attrs: isFunction$1(tbodyTrAttr) ? tbodyTrAttr(null, "row-top") : tbodyTrAttr,
          key: "b-top-row"
        }, [this.normalizeSlot(SLOT_NAME_TOP_ROW, {
          columns: fields.length,
          fields
        })]);
      }
    }
  });
  function ownKeys$9(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$9(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty$9(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$9(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$8 = makePropsConfigurable(sortKeys(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, props$25), props$v), props$t), props$s), props$r), props$q), props$p), props$o), props$n), props$m), props$l), props$k), props$j), props$i), props$e), props$c), props$a), props$9)), NAME_TABLE);
  var BTable = /* @__PURE__ */ extend({
    name: NAME_TABLE,
    // Order of mixins is important!
    // They are merged from first to last, followed by this component
    mixins: [
      // General mixins
      attrsMixin,
      hasListenerMixin,
      idMixin,
      normalizeSlotMixin,
      // Required table mixins
      itemsMixin,
      tableRendererMixin,
      stackedMixin,
      theadMixin,
      tfootMixin,
      tbodyMixin,
      // Table features mixins
      stackedMixin,
      filteringMixin,
      sortingMixin,
      paginationMixin,
      captionMixin,
      colgroupMixin,
      selectableMixin,
      emptyMixin,
      topRowMixin,
      bottomRowMixin,
      busyMixin,
      providerMixin
    ],
    props: props$8
    // Render function is provided by `tableRendererMixin`
  });
  function ownKeys$8(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$8(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty$8(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$8(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$7 = makePropsConfigurable(sortKeys(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8(_objectSpread$8({}, props$25), props$s), props$r), props$o), props$j), props$i), props$e), props$c), props$a)), NAME_TABLE_LITE);
  var BTableLite = /* @__PURE__ */ extend({
    name: NAME_TABLE_LITE,
    // Order of mixins is important!
    // They are merged from first to last, followed by this component
    mixins: [
      // General mixins
      attrsMixin,
      hasListenerMixin,
      idMixin,
      normalizeSlotMixin,
      // Required table mixins
      itemsMixin,
      tableRendererMixin,
      stackedMixin,
      theadMixin,
      tfootMixin,
      tbodyMixin,
      // Table features mixins
      // These are pretty lightweight, and are useful for lightweight tables
      captionMixin,
      colgroupMixin
    ],
    props: props$7
    // Render function is provided by `tableRendererMixin`
  });
  function ownKeys$7(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$7(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty$7(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$7(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var props$6 = makePropsConfigurable(sortKeys(_objectSpread$7(_objectSpread$7(_objectSpread$7({}, props$25), props$j), props$i)), NAME_TABLE_SIMPLE);
  var BTableSimple = /* @__PURE__ */ extend({
    name: NAME_TABLE_SIMPLE,
    // Order of mixins is important!
    // They are merged from first to last, followed by this component
    mixins: [
      // General mixins
      attrsMixin,
      hasListenerMixin,
      idMixin,
      normalizeSlotMixin,
      // Required table mixins
      tableRendererMixin,
      // Table features mixins
      // Stacked requires extra handling by users via
      // the table cell `stacked-heading` prop
      stackedMixin
    ],
    props: props$6,
    computed: {
      isTableSimple: function isTableSimple() {
        return true;
      }
    }
    // Render function is provided by `tableRendererMixin`
  });
  var TableLitePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTableLite
    }
  });
  var TableSimplePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTableSimple,
      BTbody,
      BThead,
      BTfoot,
      BTr,
      BTd,
      BTh
    }
  });
  var TablePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTable
    },
    plugins: {
      TableLitePlugin,
      TableSimplePlugin
    }
  });
  function ownKeys$6(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$6(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty$6(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$6(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var isPositiveNumber = function isPositiveNumber2(value) {
    return value > 0;
  };
  var props$5 = makePropsConfigurable({
    animation: makeProp(PROP_TYPE_STRING),
    columns: makeProp(PROP_TYPE_NUMBER, 5, isPositiveNumber),
    hideHeader: makeProp(PROP_TYPE_BOOLEAN, false),
    rows: makeProp(PROP_TYPE_NUMBER, 3, isPositiveNumber),
    showFooter: makeProp(PROP_TYPE_BOOLEAN, false),
    tableProps: makeProp(PROP_TYPE_OBJECT, {})
  }, NAME_SKELETON_TABLE);
  var BSkeletonTable = /* @__PURE__ */ extend({
    name: NAME_SKELETON_TABLE,
    functional: true,
    props: props$5,
    render: function render(h, _ref) {
      var data = _ref.data, props2 = _ref.props;
      var animation = props2.animation, columns = props2.columns;
      var $th = h("th", [h(BSkeleton, {
        props: {
          animation
        }
      })]);
      var $thTr = h("tr", createArray(columns, $th));
      var $td = h("td", [h(BSkeleton, {
        props: {
          width: "75%",
          animation
        }
      })]);
      var $tdTr = h("tr", createArray(columns, $td));
      var $tbody = h("tbody", createArray(props2.rows, $tdTr));
      var $thead = !props2.hideHeader ? h("thead", [$thTr]) : h();
      var $tfoot = props2.showFooter ? h("tfoot", [$thTr]) : h();
      return h(BTableSimple, a(data, {
        props: _objectSpread$6({}, props2.tableProps)
      }), [$thead, $tbody, $tfoot]);
    }
  });
  var props$4 = makePropsConfigurable({
    loading: makeProp(PROP_TYPE_BOOLEAN, false)
  }, NAME_SKELETON_WRAPPER);
  var BSkeletonWrapper = /* @__PURE__ */ extend({
    name: NAME_SKELETON_WRAPPER,
    functional: true,
    props: props$4,
    render: function render(h, _ref) {
      var data = _ref.data, props2 = _ref.props, slots = _ref.slots, scopedSlots = _ref.scopedSlots;
      var $slots = slots();
      var $scopedSlots = scopedSlots || {};
      var slotScope = {};
      if (props2.loading) {
        return h("div", a(data, {
          attrs: {
            role: "alert",
            "aria-live": "polite",
            "aria-busy": true
          },
          staticClass: "b-skeleton-wrapper",
          key: "loading"
        }), normalizeSlot(SLOT_NAME_LOADING, slotScope, $scopedSlots, $slots));
      }
      return normalizeSlot(SLOT_NAME_DEFAULT, slotScope, $scopedSlots, $slots);
    }
  });
  var SkeletonPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BSkeleton,
      BSkeletonIcon,
      BSkeletonImg,
      BSkeletonTable,
      BSkeletonWrapper
    }
  });
  var SpinnerPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BSpinner
    }
  });
  var _watch$2;
  function ownKeys$5(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$5(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty$5(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$5(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin$1 = makeModelMixin("value", {
    type: PROP_TYPE_NUMBER
  }), modelMixin$1 = _makeModelMixin$1.mixin, modelProps$1 = _makeModelMixin$1.props, MODEL_PROP_NAME$1 = _makeModelMixin$1.prop, MODEL_EVENT_NAME$1 = _makeModelMixin$1.event;
  var notDisabled = function notDisabled2(tab) {
    return !tab.disabled;
  };
  var BVTabButton = /* @__PURE__ */ extend({
    name: NAME_TAB_BUTTON_HELPER,
    inject: {
      getBvTabs: {
        default: (
          /* istanbul ignore next */
          function _default() {
            return function() {
              return {};
            };
          }
        )
      }
    },
    props: {
      controls: makeProp(PROP_TYPE_STRING),
      id: makeProp(PROP_TYPE_STRING),
      noKeyNav: makeProp(PROP_TYPE_BOOLEAN, false),
      posInSet: makeProp(PROP_TYPE_NUMBER),
      setSize: makeProp(PROP_TYPE_NUMBER),
      // Reference to the child <b-tab> instance
      tab: makeProp(),
      tabIndex: makeProp(PROP_TYPE_NUMBER)
    },
    computed: {
      bvTabs: function bvTabs() {
        return this.getBvTabs();
      }
    },
    methods: {
      focus: function focus() {
        attemptFocus(this.$refs.link);
      },
      handleEvent: function handleEvent(event2) {
        if (this.tab.disabled) {
          return;
        }
        var type = event2.type, keyCode = event2.keyCode, shiftKey = event2.shiftKey;
        if (type === "click") {
          stopEvent(event2);
          this.$emit(EVENT_NAME_CLICK, event2);
        } else if (type === "keydown" && keyCode === CODE_SPACE) {
          stopEvent(event2);
          this.$emit(EVENT_NAME_CLICK, event2);
        } else if (type === "keydown" && !this.noKeyNav) {
          if ([CODE_UP, CODE_LEFT, CODE_HOME].indexOf(keyCode) !== -1) {
            stopEvent(event2);
            if (shiftKey || keyCode === CODE_HOME) {
              this.$emit(EVENT_NAME_FIRST, event2);
            } else {
              this.$emit(EVENT_NAME_PREV, event2);
            }
          } else if ([CODE_DOWN, CODE_RIGHT, CODE_END].indexOf(keyCode) !== -1) {
            stopEvent(event2);
            if (shiftKey || keyCode === CODE_END) {
              this.$emit(EVENT_NAME_LAST, event2);
            } else {
              this.$emit(EVENT_NAME_NEXT, event2);
            }
          }
        }
      }
    },
    render: function render(h) {
      var id = this.id, tabIndex = this.tabIndex, setSize = this.setSize, posInSet = this.posInSet, controls = this.controls, handleEvent = this.handleEvent;
      var _this$tab = this.tab, title = _this$tab.title, localActive = _this$tab.localActive, disabled = _this$tab.disabled, titleItemClass = _this$tab.titleItemClass, titleLinkClass = _this$tab.titleLinkClass, titleLinkAttributes = _this$tab.titleLinkAttributes;
      var $link = h(BLink, {
        staticClass: "nav-link",
        class: [
          {
            active: localActive && !disabled,
            disabled
          },
          titleLinkClass,
          // Apply <b-tabs> `activeNavItemClass` styles when the tab is active
          localActive ? this.bvTabs.activeNavItemClass : null
        ],
        props: {
          disabled
        },
        attrs: _objectSpread$5(_objectSpread$5({}, titleLinkAttributes), {}, {
          id,
          role: "tab",
          // Roving tab index when keynav enabled
          tabindex: tabIndex,
          "aria-selected": localActive && !disabled ? "true" : "false",
          "aria-setsize": setSize,
          "aria-posinset": posInSet,
          "aria-controls": controls
        }),
        on: {
          click: handleEvent,
          keydown: handleEvent
        },
        ref: "link"
      }, [this.tab.normalizeSlot(SLOT_NAME_TITLE) || title]);
      return h("li", {
        staticClass: "nav-item",
        class: [titleItemClass],
        attrs: {
          role: "presentation"
        }
      }, [$link]);
    }
  });
  var navProps = omit(props$U, ["tabs", "isNavBar", "cardHeader"]);
  var props$3 = makePropsConfigurable(sortKeys(_objectSpread$5(_objectSpread$5(_objectSpread$5(_objectSpread$5({}, props$25), modelProps$1), navProps), {}, {
    // Only applied to the currently active `<b-nav-item>`
    activeNavItemClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // Only applied to the currently active `<b-tab>`
    // This prop is sniffed by the `<b-tab>` child
    activeTabClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    card: makeProp(PROP_TYPE_BOOLEAN, false),
    contentClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    // Synonym for 'bottom'
    end: makeProp(PROP_TYPE_BOOLEAN, false),
    // This prop is sniffed by the `<b-tab>` child
    lazy: makeProp(PROP_TYPE_BOOLEAN, false),
    navClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    navWrapperClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    noKeyNav: makeProp(PROP_TYPE_BOOLEAN, false),
    noNavStyle: makeProp(PROP_TYPE_BOOLEAN, false),
    tag: makeProp(PROP_TYPE_STRING, "div")
  })), NAME_TABS);
  var BTabs = /* @__PURE__ */ extend({
    name: NAME_TABS,
    mixins: [idMixin, modelMixin$1, normalizeSlotMixin],
    provide: function provide() {
      var _this = this;
      return {
        getBvTabs: function getBvTabs() {
          return _this;
        }
      };
    },
    props: props$3,
    data: function data() {
      return {
        // Index of current tab
        currentTab: toInteger(this[MODEL_PROP_NAME$1], -1),
        // Array of direct child `<b-tab>` instances, in DOM order
        tabs: [],
        // Array of child instances registered (for triggering reactive updates)
        registeredTabs: []
      };
    },
    computed: {
      fade: function fade() {
        return !this.noFade;
      },
      localNavClass: function localNavClass() {
        var classes = [];
        if (this.card && this.vertical) {
          classes.push("card-header", "h-100", "border-bottom-0", "rounded-0");
        }
        return [].concat(classes, [this.navClass]);
      }
    },
    watch: (_watch$2 = {}, _defineProperty$5(_watch$2, MODEL_PROP_NAME$1, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        newValue = toInteger(newValue, -1);
        oldValue = toInteger(oldValue, 0);
        var $tab = this.tabs[newValue];
        if ($tab && !$tab.disabled) {
          this.activateTab($tab);
        } else {
          if (newValue < oldValue) {
            this.previousTab();
          } else {
            this.nextTab();
          }
        }
      }
    }), _defineProperty$5(_watch$2, "currentTab", function currentTab(newValue) {
      var index = -1;
      this.tabs.forEach(function($tab, i) {
        if (i === newValue && !$tab.disabled) {
          $tab.localActive = true;
          index = i;
        } else {
          $tab.localActive = false;
        }
      });
      this.$emit(MODEL_EVENT_NAME$1, index);
    }), _defineProperty$5(_watch$2, "tabs", function tabs(newValue, oldValue) {
      var _this2 = this;
      if (!looseEqual(newValue.map(function($tab) {
        return $tab[COMPONENT_UID_KEY];
      }), oldValue.map(function($tab) {
        return $tab[COMPONENT_UID_KEY];
      }))) {
        this.$nextTick(function() {
          _this2.$emit(EVENT_NAME_CHANGED, newValue.slice(), oldValue.slice());
        });
      }
    }), _defineProperty$5(_watch$2, "registeredTabs", function registeredTabs() {
      this.updateTabs();
    }), _watch$2),
    created: function created() {
      this.$_observer = null;
    },
    mounted: function mounted() {
      this.setObserver(true);
    },
    beforeDestroy: function beforeDestroy() {
      this.setObserver(false);
      this.tabs = [];
    },
    methods: {
      registerTab: function registerTab($tab) {
        if (!arrayIncludes(this.registeredTabs, $tab)) {
          this.registeredTabs.push($tab);
        }
      },
      unregisterTab: function unregisterTab($tab) {
        this.registeredTabs = this.registeredTabs.slice().filter(function($t) {
          return $t !== $tab;
        });
      },
      // DOM observer is needed to detect changes in order of tabs
      setObserver: function setObserver() {
        var _this3 = this;
        var on = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        this.$_observer && this.$_observer.disconnect();
        this.$_observer = null;
        if (on) {
          var handler = function handler2() {
            _this3.$nextTick(function() {
              requestAF(function() {
                _this3.updateTabs();
              });
            });
          };
          this.$_observer = observeDom(this.$refs.content, handler, {
            childList: true,
            subtree: false,
            attributes: true,
            attributeFilter: ["id"]
          });
        }
      },
      getTabs: function getTabs() {
        var $tabs = this.registeredTabs;
        var order = [];
        if (IS_BROWSER && $tabs.length > 0) {
          var selector = $tabs.map(function($tab) {
            return "#".concat($tab.safeId());
          }).join(", ");
          order = selectAll(selector, this.$el).map(function($el) {
            return $el.id;
          }).filter(identity);
        }
        return stableSort$1($tabs, function(a2, b) {
          return order.indexOf(a2.safeId()) - order.indexOf(b.safeId());
        });
      },
      updateTabs: function updateTabs() {
        var $tabs = this.getTabs();
        var tabIndex = $tabs.indexOf($tabs.slice().reverse().find(function($tab) {
          return $tab.localActive && !$tab.disabled;
        }));
        if (tabIndex < 0) {
          var currentTab = this.currentTab;
          if (currentTab >= $tabs.length) {
            tabIndex = $tabs.indexOf($tabs.slice().reverse().find(notDisabled));
          } else if ($tabs[currentTab] && !$tabs[currentTab].disabled) {
            tabIndex = currentTab;
          }
        }
        if (tabIndex < 0) {
          tabIndex = $tabs.indexOf($tabs.find(notDisabled));
        }
        $tabs.forEach(function($tab, index) {
          $tab.localActive = index === tabIndex;
        });
        this.tabs = $tabs;
        this.currentTab = tabIndex;
      },
      // Find a button that controls a tab, given the tab reference
      // Returns the button vm instance
      getButtonForTab: function getButtonForTab($tab) {
        return (this.$refs.buttons || []).find(function($btn) {
          return $btn.tab === $tab;
        });
      },
      // Force a button to re-render its content, given a `<b-tab>` instance
      // Called by `<b-tab>` on `update()`
      updateButton: function updateButton($tab) {
        var $button = this.getButtonForTab($tab);
        if ($button && $button.$forceUpdate) {
          $button.$forceUpdate();
        }
      },
      // Activate a tab given a `<b-tab>` instance
      // Also accessed by `<b-tab>`
      activateTab: function activateTab($tab) {
        var currentTab = this.currentTab, $tabs = this.tabs;
        var result = false;
        if ($tab) {
          var index = $tabs.indexOf($tab);
          if (index !== currentTab && index > -1 && !$tab.disabled) {
            var tabEvent = new BvEvent(EVENT_NAME_ACTIVATE_TAB, {
              cancelable: true,
              vueTarget: this,
              componentId: this.safeId()
            });
            this.$emit(tabEvent.type, index, currentTab, tabEvent);
            if (!tabEvent.defaultPrevented) {
              this.currentTab = index;
              result = true;
            }
          }
        }
        if (!result && this[MODEL_PROP_NAME$1] !== currentTab) {
          this.$emit(MODEL_EVENT_NAME$1, currentTab);
        }
        return result;
      },
      // Deactivate a tab given a `<b-tab>` instance
      // Accessed by `<b-tab>`
      deactivateTab: function deactivateTab($tab) {
        if ($tab) {
          return this.activateTab(this.tabs.filter(function($t) {
            return $t !== $tab;
          }).find(notDisabled));
        }
        return false;
      },
      // Focus a tab button given its `<b-tab>` instance
      focusButton: function focusButton($tab) {
        var _this4 = this;
        this.$nextTick(function() {
          attemptFocus(_this4.getButtonForTab($tab));
        });
      },
      // Emit a click event on a specified `<b-tab>` component instance
      emitTabClick: function emitTabClick(tab, event2) {
        if (isEvent(event2) && tab && tab.$emit && !tab.disabled) {
          tab.$emit(EVENT_NAME_CLICK, event2);
        }
      },
      // Click handler
      clickTab: function clickTab($tab, event2) {
        this.activateTab($tab);
        this.emitTabClick($tab, event2);
      },
      // Move to first non-disabled tab
      firstTab: function firstTab(focus) {
        var $tab = this.tabs.find(notDisabled);
        if (this.activateTab($tab) && focus) {
          this.focusButton($tab);
          this.emitTabClick($tab, focus);
        }
      },
      // Move to previous non-disabled tab
      previousTab: function previousTab(focus) {
        var currentIndex = mathMax(this.currentTab, 0);
        var $tab = this.tabs.slice(0, currentIndex).reverse().find(notDisabled);
        if (this.activateTab($tab) && focus) {
          this.focusButton($tab);
          this.emitTabClick($tab, focus);
        }
      },
      // Move to next non-disabled tab
      nextTab: function nextTab(focus) {
        var currentIndex = mathMax(this.currentTab, -1);
        var $tab = this.tabs.slice(currentIndex + 1).find(notDisabled);
        if (this.activateTab($tab) && focus) {
          this.focusButton($tab);
          this.emitTabClick($tab, focus);
        }
      },
      // Move to last non-disabled tab
      lastTab: function lastTab(focus) {
        var $tab = this.tabs.slice().reverse().find(notDisabled);
        if (this.activateTab($tab) && focus) {
          this.focusButton($tab);
          this.emitTabClick($tab, focus);
        }
      }
    },
    render: function render(h) {
      var _this5 = this;
      var align = this.align, card = this.card, end = this.end, fill = this.fill, firstTab = this.firstTab, justified = this.justified, lastTab = this.lastTab, nextTab = this.nextTab, noKeyNav = this.noKeyNav, noNavStyle = this.noNavStyle, pills = this.pills, previousTab = this.previousTab, small = this.small, $tabs = this.tabs, vertical = this.vertical;
      var $activeTab = $tabs.find(function($tab) {
        return $tab.localActive && !$tab.disabled;
      });
      var $fallbackTab = $tabs.find(function($tab) {
        return !$tab.disabled;
      });
      var $buttons = $tabs.map(function($tab, index) {
        var _on;
        var safeId = $tab.safeId;
        var tabIndex = null;
        if (!noKeyNav) {
          tabIndex = -1;
          if ($tab === $activeTab || !$activeTab && $tab === $fallbackTab) {
            tabIndex = null;
          }
        }
        return h(BVTabButton, _defineProperty$5({
          props: {
            controls: safeId ? safeId() : null,
            id: $tab.controlledBy || (safeId ? safeId("_BV_tab_button_") : null),
            noKeyNav,
            posInSet: index + 1,
            setSize: $tabs.length,
            tab: $tab,
            tabIndex
          },
          on: (_on = {}, _defineProperty$5(_on, EVENT_NAME_CLICK, function(event2) {
            _this5.clickTab($tab, event2);
          }), _defineProperty$5(_on, EVENT_NAME_FIRST, firstTab), _defineProperty$5(_on, EVENT_NAME_PREV, previousTab), _defineProperty$5(_on, EVENT_NAME_NEXT, nextTab), _defineProperty$5(_on, EVENT_NAME_LAST, lastTab), _on),
          key: $tab[COMPONENT_UID_KEY] || index,
          ref: "buttons"
        }, REF_FOR_KEY, true));
      });
      var $nav = h(BNav, {
        class: this.localNavClass,
        attrs: {
          role: "tablist",
          id: this.safeId("_BV_tab_controls_")
        },
        props: {
          fill,
          justified,
          align,
          tabs: !noNavStyle && !pills,
          pills: !noNavStyle && pills,
          vertical,
          small,
          cardHeader: card && !vertical
        },
        ref: "nav"
      }, [this.normalizeSlot(SLOT_NAME_TABS_START) || h(), $buttons, this.normalizeSlot(SLOT_NAME_TABS_END) || h()]);
      $nav = h("div", {
        class: [{
          "card-header": card && !vertical && !end,
          "card-footer": card && !vertical && end,
          "col-auto": vertical
        }, this.navWrapperClass],
        key: "bv-tabs-nav"
      }, [$nav]);
      var $children = this.normalizeSlot() || [];
      var $empty = h();
      if ($children.length === 0) {
        $empty = h("div", {
          class: ["tab-pane", "active", {
            "card-body": card
          }],
          key: "bv-empty-tab"
        }, this.normalizeSlot(SLOT_NAME_EMPTY));
      }
      var $content = h("div", {
        staticClass: "tab-content",
        class: [{
          col: vertical
        }, this.contentClass],
        attrs: {
          id: this.safeId("_BV_tab_container_")
        },
        key: "bv-content",
        ref: "content"
      }, [$children, $empty]);
      return h(this.tag, {
        staticClass: "tabs",
        class: {
          row: vertical,
          "no-gutters": vertical && card
        },
        attrs: {
          id: this.safeId()
        }
      }, [end ? $content : h(), $nav, end ? h() : $content]);
    }
  });
  var _objectSpread2, _watch$1;
  function ownKeys$4(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$4(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty$4(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$4(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var MODEL_PROP_NAME_ACTIVE = "active";
  var MODEL_EVENT_NAME_ACTIVE = MODEL_EVENT_NAME_PREFIX + MODEL_PROP_NAME_ACTIVE;
  var props$2 = makePropsConfigurable(sortKeys(_objectSpread$4(_objectSpread$4({}, props$25), {}, (_objectSpread2 = {}, _defineProperty$4(_objectSpread2, MODEL_PROP_NAME_ACTIVE, makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$4(_objectSpread2, "buttonId", makeProp(PROP_TYPE_STRING)), _defineProperty$4(_objectSpread2, "disabled", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$4(_objectSpread2, "lazy", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$4(_objectSpread2, "noBody", makeProp(PROP_TYPE_BOOLEAN, false)), _defineProperty$4(_objectSpread2, "tag", makeProp(PROP_TYPE_STRING, "div")), _defineProperty$4(_objectSpread2, "title", makeProp(PROP_TYPE_STRING)), _defineProperty$4(_objectSpread2, "titleItemClass", makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)), _defineProperty$4(_objectSpread2, "titleLinkAttributes", makeProp(PROP_TYPE_OBJECT)), _defineProperty$4(_objectSpread2, "titleLinkClass", makeProp(PROP_TYPE_ARRAY_OBJECT_STRING)), _objectSpread2))), NAME_TAB);
  var BTab = /* @__PURE__ */ extend({
    name: NAME_TAB,
    mixins: [idMixin, normalizeSlotMixin],
    inject: {
      getBvTabs: {
        default: function _default() {
          return function() {
            return {};
          };
        }
      }
    },
    props: props$2,
    data: function data() {
      return {
        localActive: this[MODEL_PROP_NAME_ACTIVE] && !this.disabled
      };
    },
    computed: {
      bvTabs: function bvTabs() {
        return this.getBvTabs();
      },
      // For parent sniffing of child
      _isTab: function _isTab() {
        return true;
      },
      tabClasses: function tabClasses() {
        var active = this.localActive, disabled = this.disabled;
        return [
          {
            active,
            disabled,
            "card-body": this.bvTabs.card && !this.noBody
          },
          // Apply <b-tabs> `activeTabClass` styles when this tab is active
          active ? this.bvTabs.activeTabClass : null
        ];
      },
      controlledBy: function controlledBy() {
        return this.buttonId || this.safeId("__BV_tab_button__");
      },
      computedNoFade: function computedNoFade() {
        return !(this.bvTabs.fade || false);
      },
      computedLazy: function computedLazy() {
        return this.bvTabs.lazy || this.lazy;
      }
    },
    watch: (_watch$1 = {}, _defineProperty$4(_watch$1, MODEL_PROP_NAME_ACTIVE, function(newValue, oldValue) {
      if (newValue !== oldValue) {
        if (newValue) {
          this.activate();
        } else {
          if (!this.deactivate()) {
            this.$emit(MODEL_EVENT_NAME_ACTIVE, this.localActive);
          }
        }
      }
    }), _defineProperty$4(_watch$1, "disabled", function disabled(newValue, oldValue) {
      if (newValue !== oldValue) {
        var firstTab = this.bvTabs.firstTab;
        if (newValue && this.localActive && firstTab) {
          this.localActive = false;
          firstTab();
        }
      }
    }), _defineProperty$4(_watch$1, "localActive", function localActive(newValue) {
      this.$emit(MODEL_EVENT_NAME_ACTIVE, newValue);
    }), _watch$1),
    mounted: function mounted() {
      this.registerTab();
    },
    updated: function updated2() {
      var updateButton = this.bvTabs.updateButton;
      if (updateButton && this.hasNormalizedSlot(SLOT_NAME_TITLE)) {
        updateButton(this);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.unregisterTab();
    },
    methods: {
      // Private methods
      registerTab: function registerTab() {
        var registerTab2 = this.bvTabs.registerTab;
        if (registerTab2) {
          registerTab2(this);
        }
      },
      unregisterTab: function unregisterTab() {
        var unregisterTab2 = this.bvTabs.unregisterTab;
        if (unregisterTab2) {
          unregisterTab2(this);
        }
      },
      // Public methods
      activate: function activate() {
        var activateTab = this.bvTabs.activateTab;
        return activateTab && !this.disabled ? activateTab(this) : false;
      },
      deactivate: function deactivate() {
        var deactivateTab = this.bvTabs.deactivateTab;
        return deactivateTab && this.localActive ? deactivateTab(this) : false;
      }
    },
    render: function render(h) {
      var localActive = this.localActive;
      var $content = h(
        this.tag,
        {
          staticClass: "tab-pane",
          class: this.tabClasses,
          directives: [{
            name: "show",
            value: localActive
          }],
          attrs: {
            role: "tabpanel",
            id: this.safeId(),
            "aria-hidden": localActive ? "false" : "true",
            "aria-labelledby": this.controlledBy || null
          },
          ref: "panel"
        },
        // Render content lazily if requested
        [localActive || !this.computedLazy ? this.normalizeSlot() : h()]
      );
      return h(BVTransition, {
        props: {
          mode: "out-in",
          noFade: this.computedNoFade
        }
      }, [$content]);
    }
  });
  var TabsPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTabs,
      BTab
    }
  });
  var TimePlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTime
    }
  });
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
  }
  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
      return arr2;
    }
  }
  function _iterableToArray$1(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }
  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }
  var inBrowser = typeof window !== "undefined";
  function freeze(item) {
    if (Array.isArray(item) || _typeof(item) === "object") {
      return Object.freeze(item);
    }
    return item;
  }
  function combinePassengers(transports2) {
    var slotProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return transports2.reduce(function(passengers, transport) {
      var temp = transport.passengers[0];
      var newPassengers = typeof temp === "function" ? temp(slotProps) : transport.passengers;
      return passengers.concat(newPassengers);
    }, []);
  }
  function stableSort(array, compareFn) {
    return array.map(function(v, idx) {
      return [idx, v];
    }).sort(function(a2, b) {
      return compareFn(a2[1], b[1]) || a2[0] - b[0];
    }).map(function(c) {
      return c[1];
    });
  }
  function pick(obj, keys2) {
    return keys2.reduce(function(acc, key) {
      if (obj.hasOwnProperty(key)) {
        acc[key] = obj[key];
      }
      return acc;
    }, {});
  }
  var transports = {};
  var targets = {};
  var sources = {};
  var Wormhole = Vue2.extend({
    data: function data() {
      return {
        transports,
        targets,
        sources,
        trackInstances: inBrowser
      };
    },
    methods: {
      open: function open(transport) {
        if (!inBrowser) return;
        var to = transport.to, from2 = transport.from, passengers = transport.passengers, _transport$order = transport.order, order = _transport$order === void 0 ? Infinity : _transport$order;
        if (!to || !from2 || !passengers) return;
        var newTransport = {
          to,
          from: from2,
          passengers: freeze(passengers),
          order
        };
        var keys2 = Object.keys(this.transports);
        if (keys2.indexOf(to) === -1) {
          Vue2.set(this.transports, to, []);
        }
        var currentIndex = this.$_getTransportIndex(newTransport);
        var newTransports = this.transports[to].slice(0);
        if (currentIndex === -1) {
          newTransports.push(newTransport);
        } else {
          newTransports[currentIndex] = newTransport;
        }
        this.transports[to] = stableSort(newTransports, function(a2, b) {
          return a2.order - b.order;
        });
      },
      close: function close(transport) {
        var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var to = transport.to, from2 = transport.from;
        if (!to || !from2 && force === false) return;
        if (!this.transports[to]) {
          return;
        }
        if (force) {
          this.transports[to] = [];
        } else {
          var index = this.$_getTransportIndex(transport);
          if (index >= 0) {
            var newTransports = this.transports[to].slice(0);
            newTransports.splice(index, 1);
            this.transports[to] = newTransports;
          }
        }
      },
      registerTarget: function registerTarget(target, vm, force) {
        if (!inBrowser) return;
        if (this.trackInstances && !force && this.targets[target]) {
          console.warn("[portal-vue]: Target ".concat(target, " already exists"));
        }
        this.$set(this.targets, target, Object.freeze([vm]));
      },
      unregisterTarget: function unregisterTarget(target) {
        this.$delete(this.targets, target);
      },
      registerSource: function registerSource(source, vm, force) {
        if (!inBrowser) return;
        if (this.trackInstances && !force && this.sources[source]) {
          console.warn("[portal-vue]: source ".concat(source, " already exists"));
        }
        this.$set(this.sources, source, Object.freeze([vm]));
      },
      unregisterSource: function unregisterSource(source) {
        this.$delete(this.sources, source);
      },
      hasTarget: function hasTarget(to) {
        return !!(this.targets[to] && this.targets[to][0]);
      },
      hasSource: function hasSource(to) {
        return !!(this.sources[to] && this.sources[to][0]);
      },
      hasContentFor: function hasContentFor(to) {
        return !!this.transports[to] && !!this.transports[to].length;
      },
      // Internal
      $_getTransportIndex: function $_getTransportIndex(_ref) {
        var to = _ref.to, from2 = _ref.from;
        for (var i in this.transports[to]) {
          if (this.transports[to][i].from === from2) {
            return +i;
          }
        }
        return -1;
      }
    }
  });
  var wormhole = new Wormhole(transports);
  var _id = 1;
  var Portal = Vue2.extend({
    name: "portal",
    props: {
      disabled: {
        type: Boolean
      },
      name: {
        type: String,
        default: function _default() {
          return String(_id++);
        }
      },
      order: {
        type: Number,
        default: 0
      },
      slim: {
        type: Boolean
      },
      slotProps: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      tag: {
        type: String,
        default: "DIV"
      },
      to: {
        type: String,
        default: function _default() {
          return String(Math.round(Math.random() * 1e7));
        }
      }
    },
    created: function created() {
      var _this = this;
      this.$nextTick(function() {
        wormhole.registerSource(_this.name, _this);
      });
    },
    mounted: function mounted() {
      if (!this.disabled) {
        this.sendUpdate();
      }
    },
    updated: function updated2() {
      if (this.disabled) {
        this.clear();
      } else {
        this.sendUpdate();
      }
    },
    beforeDestroy: function beforeDestroy() {
      wormhole.unregisterSource(this.name);
      this.clear();
    },
    watch: {
      to: function to(newValue, oldValue) {
        oldValue && oldValue !== newValue && this.clear(oldValue);
        this.sendUpdate();
      }
    },
    methods: {
      clear: function clear(target) {
        var closer = {
          from: this.name,
          to: target || this.to
        };
        wormhole.close(closer);
      },
      normalizeSlots: function normalizeSlots() {
        return this.$scopedSlots.default ? [this.$scopedSlots.default] : this.$slots.default;
      },
      normalizeOwnChildren: function normalizeOwnChildren(children) {
        return typeof children === "function" ? children(this.slotProps) : children;
      },
      sendUpdate: function sendUpdate() {
        var slotContent = this.normalizeSlots();
        if (slotContent) {
          var transport = {
            from: this.name,
            to: this.to,
            passengers: _toConsumableArray$1(slotContent),
            order: this.order
          };
          wormhole.open(transport);
        } else {
          this.clear();
        }
      }
    },
    render: function render(h) {
      var children = this.$slots.default || this.$scopedSlots.default || [];
      var Tag = this.tag;
      if (this.disabled) {
        return children.length <= 1 && this.slim ? this.normalizeOwnChildren(children)[0] : h(Tag, [this.normalizeOwnChildren(children)]);
      } else {
        return this.slim ? h() : h(Tag, {
          class: {
            "v-portal": true
          },
          style: {
            display: "none"
          },
          key: "v-portal-placeholder"
        });
      }
    }
  });
  var PortalTarget = Vue2.extend({
    name: "portalTarget",
    props: {
      multiple: {
        type: Boolean,
        default: false
      },
      name: {
        type: String,
        required: true
      },
      slim: {
        type: Boolean,
        default: false
      },
      slotProps: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      tag: {
        type: String,
        default: "div"
      },
      transition: {
        type: [String, Object, Function]
      }
    },
    data: function data() {
      return {
        transports: wormhole.transports,
        firstRender: true
      };
    },
    created: function created() {
      var _this = this;
      this.$nextTick(function() {
        wormhole.registerTarget(_this.name, _this);
      });
    },
    watch: {
      ownTransports: function ownTransports() {
        this.$emit("change", this.children().length > 0);
      },
      name: function name(newVal, oldVal) {
        wormhole.unregisterTarget(oldVal);
        wormhole.registerTarget(newVal, this);
      }
    },
    mounted: function mounted() {
      var _this2 = this;
      if (this.transition) {
        this.$nextTick(function() {
          _this2.firstRender = false;
        });
      }
    },
    beforeDestroy: function beforeDestroy() {
      wormhole.unregisterTarget(this.name);
    },
    computed: {
      ownTransports: function ownTransports() {
        var transports2 = this.transports[this.name] || [];
        if (this.multiple) {
          return transports2;
        }
        return transports2.length === 0 ? [] : [transports2[transports2.length - 1]];
      },
      passengers: function passengers() {
        return combinePassengers(this.ownTransports, this.slotProps);
      }
    },
    methods: {
      // can't be a computed prop because it has to "react" to $slot changes.
      children: function children() {
        return this.passengers.length !== 0 ? this.passengers : this.$scopedSlots.default ? this.$scopedSlots.default(this.slotProps) : this.$slots.default || [];
      },
      // can't be a computed prop because it has to "react" to this.children().
      noWrapper: function noWrapper() {
        var noWrapper2 = this.slim && !this.transition;
        if (noWrapper2 && this.children().length > 1) {
          console.warn("[portal-vue]: PortalTarget with `slim` option received more than one child element.");
        }
        return noWrapper2;
      }
    },
    render: function render(h) {
      var noWrapper = this.noWrapper();
      var children = this.children();
      var Tag = this.transition || this.tag;
      return noWrapper ? children[0] : this.slim && !Tag ? h() : h(Tag, {
        props: {
          // if we have a transition component, pass the tag if it exists
          tag: this.transition && this.tag ? this.tag : void 0
        },
        class: {
          "vue-portal-target": true
        }
      }, children);
    }
  });
  var _id$1 = 0;
  var portalProps = ["disabled", "name", "order", "slim", "slotProps", "tag", "to"];
  var targetProps = ["multiple", "transition"];
  Vue2.extend({
    name: "MountingPortal",
    inheritAttrs: false,
    props: {
      append: {
        type: [Boolean, String]
      },
      bail: {
        type: Boolean
      },
      mountTo: {
        type: String,
        required: true
      },
      // Portal
      disabled: {
        type: Boolean
      },
      // name for the portal
      name: {
        type: String,
        default: function _default() {
          return "mounted_" + String(_id$1++);
        }
      },
      order: {
        type: Number,
        default: 0
      },
      slim: {
        type: Boolean
      },
      slotProps: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      tag: {
        type: String,
        default: "DIV"
      },
      // name for the target
      to: {
        type: String,
        default: function _default() {
          return String(Math.round(Math.random() * 1e7));
        }
      },
      // Target
      multiple: {
        type: Boolean,
        default: false
      },
      targetSlim: {
        type: Boolean
      },
      targetSlotProps: {
        type: Object,
        default: function _default() {
          return {};
        }
      },
      targetTag: {
        type: String,
        default: "div"
      },
      transition: {
        type: [String, Object, Function]
      }
    },
    created: function created() {
      if (typeof document === "undefined") return;
      var el = document.querySelector(this.mountTo);
      if (!el) {
        console.error("[portal-vue]: Mount Point '".concat(this.mountTo, "' not found in document"));
        return;
      }
      var props2 = this.$props;
      if (wormhole.targets[props2.name]) {
        if (props2.bail) {
          console.warn("[portal-vue]: Target ".concat(props2.name, " is already mounted.\n        Aborting because 'bail: true' is set"));
        } else {
          this.portalTarget = wormhole.targets[props2.name];
        }
        return;
      }
      var append = props2.append;
      if (append) {
        var type = typeof append === "string" ? append : "DIV";
        var mountEl = document.createElement(type);
        el.appendChild(mountEl);
        el = mountEl;
      }
      var _props2 = pick(this.$props, targetProps);
      _props2.slim = this.targetSlim;
      _props2.tag = this.targetTag;
      _props2.slotProps = this.targetSlotProps;
      _props2.name = this.to;
      this.portalTarget = new PortalTarget({
        el,
        parent: this.$parent || this,
        propsData: _props2
      });
    },
    beforeDestroy: function beforeDestroy() {
      var target = this.portalTarget;
      if (this.append) {
        var el = target.$el;
        el.parentNode.removeChild(el);
      }
      target.$destroy();
    },
    render: function render(h) {
      if (!this.portalTarget) {
        console.warn("[portal-vue] Target wasn't mounted");
        return h();
      }
      if (!this.$scopedSlots.manual) {
        var props2 = pick(this.$props, portalProps);
        return h(Portal, {
          props: props2,
          attrs: this.$attrs,
          on: this.$listeners,
          scopedSlots: this.$scopedSlots
        }, this.$slots.default);
      }
      var content = this.$scopedSlots.manual({
        to: this.to
      });
      if (Array.isArray(content)) {
        content = content[0];
      }
      if (!content) return h();
      return content;
    }
  });
  var DefaultTransition = /* @__PURE__ */ extend({
    mixins: [normalizeSlotMixin],
    data: function data() {
      return {
        // Transition classes base name
        name: "b-toaster"
      };
    },
    methods: {
      onAfterEnter: function onAfterEnter2(el) {
        var _this = this;
        requestAF(function() {
          removeClass(el, "".concat(_this.name, "-enter-to"));
        });
      }
    },
    render: function render(h) {
      return h("transition-group", {
        props: {
          tag: "div",
          name: this.name
        },
        on: {
          afterEnter: this.onAfterEnter
        }
      }, this.normalizeSlot());
    }
  });
  var props$1 = makePropsConfigurable({
    // Allowed: 'true' or 'false' or `null`
    ariaAtomic: makeProp(PROP_TYPE_STRING),
    ariaLive: makeProp(PROP_TYPE_STRING),
    name: makeProp(PROP_TYPE_STRING, void 0, true),
    // Required
    // Aria role
    role: makeProp(PROP_TYPE_STRING)
  }, NAME_TOASTER);
  var BToaster = /* @__PURE__ */ extend({
    name: NAME_TOASTER,
    mixins: [listenOnRootMixin],
    props: props$1,
    data: function data() {
      return {
        // We don't render on SSR or if a an existing target found
        doRender: false,
        dead: false,
        // Toaster names cannot change once created
        staticName: this.name
      };
    },
    beforeMount: function beforeMount() {
      var name = this.name;
      this.staticName = name;
      if (wormhole.hasTarget(name)) {
        warn('A "<portal-target>" with name "'.concat(name, '" already exists in the document.'), NAME_TOASTER);
        this.dead = true;
      } else {
        this.doRender = true;
      }
    },
    beforeDestroy: function beforeDestroy() {
      if (this.doRender) {
        this.emitOnRoot(getRootEventName(NAME_TOASTER, EVENT_NAME_DESTROYED), this.name);
      }
    },
    destroyed: function destroyed() {
      var $el = this.$el;
      if ($el && $el.parentNode) {
        $el.parentNode.removeChild($el);
      }
    },
    render: function render(h) {
      var $toaster = h("div", {
        class: ["d-none", {
          "b-dead-toaster": this.dead
        }]
      });
      if (this.doRender) {
        var $target = h(PortalTarget, {
          staticClass: "b-toaster-slot",
          props: {
            name: this.staticName,
            multiple: true,
            tag: "div",
            slim: false,
            // transition: this.transition || DefaultTransition
            transition: DefaultTransition
          }
        });
        $toaster = h("div", {
          staticClass: "b-toaster",
          class: [this.staticName],
          attrs: {
            id: this.staticName,
            // Fallback to null to make sure attribute doesn't exist
            role: this.role || null,
            "aria-live": this.ariaLive,
            "aria-atomic": this.ariaAtomic
          }
        }, [$target]);
      }
      return $toaster;
    }
  });
  var _watch;
  function ownKeys$3(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$3(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty$3(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$3(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var _makeModelMixin = makeModelMixin("visible", {
    type: PROP_TYPE_BOOLEAN,
    defaultValue: false,
    event: EVENT_NAME_CHANGE
  }), modelMixin = _makeModelMixin.mixin, modelProps = _makeModelMixin.props, MODEL_PROP_NAME = _makeModelMixin.prop, MODEL_EVENT_NAME = _makeModelMixin.event;
  var MIN_DURATION = 1e3;
  var linkProps = pick$1(props$2f, ["href", "to"]);
  var props = makePropsConfigurable(sortKeys(_objectSpread$3(_objectSpread$3(_objectSpread$3(_objectSpread$3({}, props$25), modelProps), linkProps), {}, {
    appendToast: makeProp(PROP_TYPE_BOOLEAN, false),
    autoHideDelay: makeProp(PROP_TYPE_NUMBER_STRING, 5e3),
    bodyClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    headerTag: makeProp(PROP_TYPE_STRING, "header"),
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: makeProp(PROP_TYPE_BOOLEAN, false),
    noAutoHide: makeProp(PROP_TYPE_BOOLEAN, false),
    noCloseButton: makeProp(PROP_TYPE_BOOLEAN, false),
    noFade: makeProp(PROP_TYPE_BOOLEAN, false),
    noHoverPause: makeProp(PROP_TYPE_BOOLEAN, false),
    solid: makeProp(PROP_TYPE_BOOLEAN, false),
    // Render the toast in place, rather than in a portal-target
    static: makeProp(PROP_TYPE_BOOLEAN, false),
    title: makeProp(PROP_TYPE_STRING),
    toastClass: makeProp(PROP_TYPE_ARRAY_OBJECT_STRING),
    toaster: makeProp(PROP_TYPE_STRING, "b-toaster-top-right"),
    variant: makeProp(PROP_TYPE_STRING)
  })), NAME_TOAST);
  var BToast = /* @__PURE__ */ extend({
    name: NAME_TOAST,
    mixins: [attrsMixin, idMixin, modelMixin, listenOnRootMixin, normalizeSlotMixin, scopedStyleMixin],
    inheritAttrs: false,
    props,
    data: function data() {
      return {
        isMounted: false,
        doRender: false,
        localShow: false,
        isTransitioning: false,
        isHiding: false,
        order: 0,
        dismissStarted: 0,
        resumeDismiss: 0
      };
    },
    computed: {
      toastClasses: function toastClasses() {
        var appendToast = this.appendToast, variant = this.variant;
        return _defineProperty$3({
          "b-toast-solid": this.solid,
          "b-toast-append": appendToast,
          "b-toast-prepend": !appendToast
        }, "b-toast-".concat(variant), variant);
      },
      slotScope: function slotScope() {
        var hide2 = this.hide;
        return {
          hide: hide2
        };
      },
      computedDuration: function computedDuration() {
        return mathMax(toInteger(this.autoHideDelay, 0), MIN_DURATION);
      },
      computedToaster: function computedToaster() {
        return String(this.toaster);
      },
      transitionHandlers: function transitionHandlers() {
        return {
          beforeEnter: this.onBeforeEnter,
          afterEnter: this.onAfterEnter,
          beforeLeave: this.onBeforeLeave,
          afterLeave: this.onAfterLeave
        };
      },
      computedAttrs: function computedAttrs() {
        return _objectSpread$3(_objectSpread$3({}, this.bvAttrs), {}, {
          id: this.safeId(),
          tabindex: "0"
        });
      }
    },
    watch: (_watch = {}, _defineProperty$3(_watch, MODEL_PROP_NAME, function(newValue) {
      this[newValue ? "show" : "hide"]();
    }), _defineProperty$3(_watch, "localShow", function localShow(newValue) {
      if (newValue !== this[MODEL_PROP_NAME]) {
        this.$emit(MODEL_EVENT_NAME, newValue);
      }
    }), _defineProperty$3(_watch, "toaster", function toaster() {
      this.$nextTick(this.ensureToaster);
    }), _defineProperty$3(_watch, "static", function _static(newValue) {
      if (newValue && this.localShow) {
        this.ensureToaster();
      }
    }), _watch),
    created: function created() {
      this.$_dismissTimer = null;
    },
    mounted: function mounted() {
      var _this = this;
      this.isMounted = true;
      this.$nextTick(function() {
        if (_this[MODEL_PROP_NAME]) {
          requestAF(function() {
            _this.show();
          });
        }
      });
      this.listenOnRoot(getRootActionEventName(NAME_TOAST, EVENT_NAME_SHOW), function(id) {
        if (id === _this.safeId()) {
          _this.show();
        }
      });
      this.listenOnRoot(getRootActionEventName(NAME_TOAST, EVENT_NAME_HIDE), function(id) {
        if (!id || id === _this.safeId()) {
          _this.hide();
        }
      });
      this.listenOnRoot(getRootEventName(NAME_TOASTER, EVENT_NAME_DESTROYED), function(toaster) {
        if (toaster === _this.computedToaster) {
          _this.hide();
        }
      });
    },
    beforeDestroy: function beforeDestroy() {
      this.clearDismissTimer();
    },
    methods: {
      show: function show() {
        var _this2 = this;
        if (!this.localShow) {
          this.ensureToaster();
          var showEvent = this.buildEvent(EVENT_NAME_SHOW);
          this.emitEvent(showEvent);
          this.dismissStarted = this.resumeDismiss = 0;
          this.order = Date.now() * (this.appendToast ? 1 : -1);
          this.isHiding = false;
          this.doRender = true;
          this.$nextTick(function() {
            requestAF(function() {
              _this2.localShow = true;
            });
          });
        }
      },
      hide: function hide2() {
        var _this3 = this;
        if (this.localShow) {
          var hideEvent = this.buildEvent(EVENT_NAME_HIDE);
          this.emitEvent(hideEvent);
          this.setHoverHandler(false);
          this.dismissStarted = this.resumeDismiss = 0;
          this.clearDismissTimer();
          this.isHiding = true;
          requestAF(function() {
            _this3.localShow = false;
          });
        }
      },
      buildEvent: function buildEvent(type) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        return new BvEvent(type, _objectSpread$3(_objectSpread$3({
          cancelable: false,
          target: this.$el || null,
          relatedTarget: null
        }, options), {}, {
          vueTarget: this,
          componentId: this.safeId()
        }));
      },
      emitEvent: function emitEvent(bvEvent) {
        var type = bvEvent.type;
        this.emitOnRoot(getRootEventName(NAME_TOAST, type), bvEvent);
        this.$emit(type, bvEvent);
      },
      ensureToaster: function ensureToaster() {
        if (this.static) {
          return;
        }
        var computedToaster = this.computedToaster;
        if (!wormhole.hasTarget(computedToaster)) {
          var div = document.createElement("div");
          document.body.appendChild(div);
          var toaster = createNewChildComponent(this.bvEventRoot, BToaster, {
            propsData: {
              name: computedToaster
            }
          });
          toaster.$mount(div);
        }
      },
      startDismissTimer: function startDismissTimer() {
        this.clearDismissTimer();
        if (!this.noAutoHide) {
          this.$_dismissTimer = setTimeout(this.hide, this.resumeDismiss || this.computedDuration);
          this.dismissStarted = Date.now();
          this.resumeDismiss = 0;
        }
      },
      clearDismissTimer: function clearDismissTimer() {
        clearTimeout(this.$_dismissTimer);
        this.$_dismissTimer = null;
      },
      setHoverHandler: function setHoverHandler(on) {
        var el = this.$refs["b-toast"];
        eventOnOff(on, el, "mouseenter", this.onPause, EVENT_OPTIONS_NO_CAPTURE);
        eventOnOff(on, el, "mouseleave", this.onUnPause, EVENT_OPTIONS_NO_CAPTURE);
      },
      onPause: function onPause() {
        if (this.noAutoHide || this.noHoverPause || !this.$_dismissTimer || this.resumeDismiss) {
          return;
        }
        var passed = Date.now() - this.dismissStarted;
        if (passed > 0) {
          this.clearDismissTimer();
          this.resumeDismiss = mathMax(this.computedDuration - passed, MIN_DURATION);
        }
      },
      onUnPause: function onUnPause() {
        if (this.noAutoHide || this.noHoverPause || !this.resumeDismiss) {
          this.resumeDismiss = this.dismissStarted = 0;
          return;
        }
        this.startDismissTimer();
      },
      onLinkClick: function onLinkClick() {
        var _this4 = this;
        this.$nextTick(function() {
          requestAF(function() {
            _this4.hide();
          });
        });
      },
      onBeforeEnter: function onBeforeEnter() {
        this.isTransitioning = true;
      },
      onAfterEnter: function onAfterEnter2() {
        this.isTransitioning = false;
        var hiddenEvent = this.buildEvent(EVENT_NAME_SHOWN);
        this.emitEvent(hiddenEvent);
        this.startDismissTimer();
        this.setHoverHandler(true);
      },
      onBeforeLeave: function onBeforeLeave() {
        this.isTransitioning = true;
      },
      onAfterLeave: function onAfterLeave2() {
        this.isTransitioning = false;
        this.order = 0;
        this.resumeDismiss = this.dismissStarted = 0;
        var hiddenEvent = this.buildEvent(EVENT_NAME_HIDDEN);
        this.emitEvent(hiddenEvent);
        this.doRender = false;
      },
      // Render helper for generating the toast
      makeToast: function makeToast(h) {
        var _this5 = this;
        var title = this.title, slotScope = this.slotScope;
        var link = isLink$1(this);
        var $headerContent = [];
        var $title = this.normalizeSlot(SLOT_NAME_TOAST_TITLE, slotScope);
        if ($title) {
          $headerContent.push($title);
        } else if (title) {
          $headerContent.push(h("strong", {
            staticClass: "mr-2"
          }, title));
        }
        if (!this.noCloseButton) {
          $headerContent.push(h(BButtonClose, {
            staticClass: "ml-auto mb-1",
            on: {
              click: function click() {
                _this5.hide();
              }
            }
          }));
        }
        var $header = h();
        if ($headerContent.length > 0) {
          $header = h(this.headerTag, {
            staticClass: "toast-header",
            class: this.headerClass
          }, $headerContent);
        }
        var $body = h(link ? BLink : "div", {
          staticClass: "toast-body",
          class: this.bodyClass,
          props: link ? pluckProps(linkProps, this) : {},
          on: link ? {
            click: this.onLinkClick
          } : {}
        }, this.normalizeSlot(SLOT_NAME_DEFAULT, slotScope));
        return h("div", {
          staticClass: "toast",
          class: this.toastClass,
          attrs: this.computedAttrs,
          key: "toast-".concat(this[COMPONENT_UID_KEY]),
          ref: "toast"
        }, [$header, $body]);
      }
    },
    render: function render(h) {
      if (!this.doRender || !this.isMounted) {
        return h();
      }
      var order = this.order, isStatic = this.static, isHiding = this.isHiding, isStatus = this.isStatus;
      var name = "b-toast-".concat(this[COMPONENT_UID_KEY]);
      var $toast = h("div", {
        staticClass: "b-toast",
        class: this.toastClasses,
        attrs: _objectSpread$3(_objectSpread$3({}, isStatic ? {} : this.scopedStyleAttrs), {}, {
          id: this.safeId("_toast_outer"),
          role: isHiding ? null : isStatus ? "status" : "alert",
          "aria-live": isHiding ? null : isStatus ? "polite" : "assertive",
          "aria-atomic": isHiding ? null : "true"
        }),
        key: name,
        ref: "b-toast"
      }, [h(BVTransition, {
        props: {
          noFade: this.noFade
        },
        on: this.transitionHandlers
      }, [this.localShow ? this.makeToast(h) : h()])]);
      return h(Portal, {
        props: {
          name,
          to: this.computedToaster,
          order,
          slim: true,
          disabled: isStatic
        }
      }, [$toast]);
    }
  });
  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties$1(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    _defineProperties$1(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function ownKeys$2(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty$2(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var PROP_NAME = "$bvToast";
  var PROP_NAME_PRIV = "_bv__toast";
  var BASE_PROPS = ["id"].concat(_toConsumableArray(keys(omit(props, ["static", "visible"]))));
  var propsToSlots = {
    toastContent: "default",
    title: "toast-title"
  };
  var filterOptions = function filterOptions2(options) {
    return BASE_PROPS.reduce(function(memo, key) {
      if (!isUndefined(options[key])) {
        memo[key] = options[key];
      }
      return memo;
    }, {});
  };
  var plugin = function plugin2(Vue3) {
    var BVToastPop = Vue3.extend({
      name: NAME_TOAST_POP,
      extends: BToast,
      mixins: [useParentMixin],
      destroyed: function destroyed() {
        var $el = this.$el;
        if ($el && $el.parentNode) {
          $el.parentNode.removeChild($el);
        }
      },
      mounted: function mounted() {
        var _this = this;
        var handleDestroy = function handleDestroy2() {
          _this.localShow = false;
          _this.doRender = false;
          _this.$nextTick(function() {
            _this.$nextTick(function() {
              requestAF(function() {
                _this.$destroy();
              });
            });
          });
        };
        this.bvParent.$once(HOOK_EVENT_NAME_DESTROYED, handleDestroy);
        this.$once(EVENT_NAME_HIDDEN, handleDestroy);
        this.listenOnRoot(getRootEventName(NAME_TOASTER, EVENT_NAME_DESTROYED), function(toaster) {
          if (toaster === _this.toaster) {
            handleDestroy();
          }
        });
      }
    });
    var makeToast = function makeToast2(props2, parent) {
      if (warnNotClient(PROP_NAME)) {
        return;
      }
      var toast = createNewChildComponent(parent, BVToastPop, {
        // We set parent as the local VM so these toasts can emit events on the
        // app `$root`, and it ensures `BToast` is destroyed when parent is destroyed
        propsData: _objectSpread$2(_objectSpread$2(_objectSpread$2({}, filterOptions(getComponentConfig(NAME_TOAST))), omit(props2, keys(propsToSlots))), {}, {
          // Props that can't be overridden
          static: false,
          visible: true
        })
      });
      keys(propsToSlots).forEach(function(prop2) {
        var value = props2[prop2];
        if (!isUndefined(value)) {
          if (prop2 === "title" && isString(value)) {
            value = [parent.$createElement("strong", {
              class: "mr-2"
            }, value)];
          }
          toast.$slots[propsToSlots[prop2]] = concat(value);
        }
      });
      var div = document.createElement("div");
      document.body.appendChild(div);
      toast.$mount(div);
    };
    var BvToast = /* @__PURE__ */ function() {
      function BvToast2(vm) {
        _classCallCheck$1(this, BvToast2);
        assign(this, {
          _vm: vm,
          _root: getEventRoot(vm)
        });
        defineProperties(this, {
          _vm: readonlyDescriptor(),
          _root: readonlyDescriptor()
        });
      }
      _createClass$1(BvToast2, [{
        key: "toast",
        value: function toast(content) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!content || warnNotClient(PROP_NAME)) {
            return;
          }
          makeToast(_objectSpread$2(_objectSpread$2({}, filterOptions(options)), {}, {
            toastContent: content
          }), this._vm);
        }
        // shows a `<b-toast>` component with the specified ID
      }, {
        key: "show",
        value: function show(id) {
          if (id) {
            this._root.$emit(getRootActionEventName(NAME_TOAST, EVENT_NAME_SHOW), id);
          }
        }
        // Hide a toast with specified ID, or if not ID all toasts
      }, {
        key: "hide",
        value: function hide2() {
          var id = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          this._root.$emit(getRootActionEventName(NAME_TOAST, EVENT_NAME_HIDE), id);
        }
      }]);
      return BvToast2;
    }();
    Vue3.mixin({
      beforeCreate: function beforeCreate() {
        this[PROP_NAME_PRIV] = new BvToast(this);
      }
    });
    if (!hasOwnProperty(Vue3.prototype, PROP_NAME)) {
      defineProperty$1(Vue3.prototype, PROP_NAME, {
        get: function get2() {
          if (!this || !this[PROP_NAME_PRIV]) {
            warn('"'.concat(PROP_NAME, '" must be accessed from a Vue instance "this" context.'), NAME_TOAST);
          }
          return this[PROP_NAME_PRIV];
        }
      });
    }
  };
  var BVToastPlugin = /* @__PURE__ */ pluginFactory({
    plugins: {
      plugin
    }
  });
  var ToastPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BToast,
      BToaster
    },
    // $bvToast injection
    plugins: {
      BVToastPlugin
    }
  });
  function ownKeys$1(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread$1(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var BV_TOOLTIP = "__BV_Tooltip__";
  var DefaultTrigger = "hover focus";
  var validTriggers = {
    focus: true,
    hover: true,
    click: true,
    blur: true,
    manual: true
  };
  var htmlRE = /^html$/i;
  var noninteractiveRE = /^noninteractive$/i;
  var noFadeRE = /^nofade$/i;
  var placementRE = /^(auto|top(left|right)?|bottom(left|right)?|left(top|bottom)?|right(top|bottom)?)$/i;
  var boundaryRE = /^(window|viewport|scrollParent)$/i;
  var delayRE = /^d\d+$/i;
  var delayShowRE = /^ds\d+$/i;
  var delayHideRE = /^dh\d+$/i;
  var offsetRE$1 = /^o-?\d+$/i;
  var variantRE = /^v-.+$/i;
  var spacesRE = /\s+/;
  var parseBindings$1 = function parseBindings2(bindings, vnode) {
    var config = {
      title: void 0,
      trigger: "",
      // Default set below if needed
      placement: "top",
      fallbackPlacement: "flip",
      container: false,
      // Default of body
      animation: true,
      offset: 0,
      id: null,
      html: false,
      interactive: true,
      disabled: false,
      delay: getComponentConfig(NAME_TOOLTIP, "delay", 50),
      boundary: String(getComponentConfig(NAME_TOOLTIP, "boundary", "scrollParent")),
      boundaryPadding: toInteger(getComponentConfig(NAME_TOOLTIP, "boundaryPadding", 5), 0),
      variant: getComponentConfig(NAME_TOOLTIP, "variant"),
      customClass: getComponentConfig(NAME_TOOLTIP, "customClass")
    };
    if (isString(bindings.value) || isNumber(bindings.value)) {
      config.title = bindings.value;
    } else if (isFunction$1(bindings.value)) {
      config.title = bindings.value;
    } else if (isPlainObject(bindings.value)) {
      config = _objectSpread$1(_objectSpread$1({}, config), bindings.value);
    }
    if (isUndefined(config.title)) {
      var attrs = isVue3 ? vnode.props : (vnode.data || {}).attrs;
      config.title = attrs && !isUndefinedOrNull(attrs.title) ? attrs.title : void 0;
    }
    if (!isPlainObject(config.delay)) {
      config.delay = {
        show: toInteger(config.delay, 0),
        hide: toInteger(config.delay, 0)
      };
    }
    if (bindings.arg) {
      config.container = "#".concat(bindings.arg);
    }
    keys(bindings.modifiers).forEach(function(mod) {
      if (htmlRE.test(mod)) {
        config.html = true;
      } else if (noninteractiveRE.test(mod)) {
        config.interactive = false;
      } else if (noFadeRE.test(mod)) {
        config.animation = false;
      } else if (placementRE.test(mod)) {
        config.placement = mod;
      } else if (boundaryRE.test(mod)) {
        mod = mod === "scrollparent" ? "scrollParent" : mod;
        config.boundary = mod;
      } else if (delayRE.test(mod)) {
        var delay = toInteger(mod.slice(1), 0);
        config.delay.show = delay;
        config.delay.hide = delay;
      } else if (delayShowRE.test(mod)) {
        config.delay.show = toInteger(mod.slice(2), 0);
      } else if (delayHideRE.test(mod)) {
        config.delay.hide = toInteger(mod.slice(2), 0);
      } else if (offsetRE$1.test(mod)) {
        config.offset = toInteger(mod.slice(1), 0);
      } else if (variantRE.test(mod)) {
        config.variant = mod.slice(2) || null;
      }
    });
    var selectedTriggers = {};
    concat(config.trigger || "").filter(identity).join(" ").trim().toLowerCase().split(spacesRE).forEach(function(trigger) {
      if (validTriggers[trigger]) {
        selectedTriggers[trigger] = true;
      }
    });
    keys(bindings.modifiers).forEach(function(mod) {
      mod = mod.toLowerCase();
      if (validTriggers[mod]) {
        selectedTriggers[mod] = true;
      }
    });
    config.trigger = keys(selectedTriggers).join(" ");
    if (config.trigger === "blur") {
      config.trigger = "focus";
    }
    if (!config.trigger) {
      config.trigger = DefaultTrigger;
    }
    return config;
  };
  var applyTooltip = function applyTooltip2(el, bindings, vnode) {
    if (!IS_BROWSER) {
      return;
    }
    var config = parseBindings$1(bindings, vnode);
    if (!el[BV_TOOLTIP]) {
      var parent = getInstanceFromDirective(vnode, bindings);
      el[BV_TOOLTIP] = createNewChildComponent(parent, BVTooltip, {
        // Add the parent's scoped style attribute data
        _scopeId: getScopeId(parent, void 0)
      });
      el[BV_TOOLTIP].__bv_prev_data__ = {};
      el[BV_TOOLTIP].$on(EVENT_NAME_SHOW, function() {
        if (isFunction$1(config.title)) {
          el[BV_TOOLTIP].updateData({
            title: config.title(el)
          });
        }
      });
    }
    var data = {
      title: config.title,
      triggers: config.trigger,
      placement: config.placement,
      fallbackPlacement: config.fallbackPlacement,
      variant: config.variant,
      customClass: config.customClass,
      container: config.container,
      boundary: config.boundary,
      delay: config.delay,
      offset: config.offset,
      noFade: !config.animation,
      id: config.id,
      interactive: config.interactive,
      disabled: config.disabled,
      html: config.html
    };
    var oldData = el[BV_TOOLTIP].__bv_prev_data__;
    el[BV_TOOLTIP].__bv_prev_data__ = data;
    if (!looseEqual(data, oldData)) {
      var newData = {
        target: el
      };
      keys(data).forEach(function(prop2) {
        if (data[prop2] !== oldData[prop2]) {
          newData[prop2] = prop2 === "title" && isFunction$1(data[prop2]) ? data[prop2](el) : data[prop2];
        }
      });
      el[BV_TOOLTIP].updateData(newData);
    }
  };
  var removeTooltip = function removeTooltip2(el) {
    if (el[BV_TOOLTIP]) {
      el[BV_TOOLTIP].$destroy();
      el[BV_TOOLTIP] = null;
    }
    delete el[BV_TOOLTIP];
  };
  var VBTooltip = {
    bind: function bind2(el, bindings, vnode) {
      applyTooltip(el, bindings, vnode);
    },
    // We use `componentUpdated` here instead of `update`, as the former
    // waits until the containing component and children have finished updating
    componentUpdated: function componentUpdated2(el, bindings, vnode) {
      nextTick(function() {
        applyTooltip(el, bindings, vnode);
      });
    },
    unbind: function unbind2(el) {
      removeTooltip(el);
    }
  };
  var VBTooltipPlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBTooltip
    }
  });
  var TooltipPlugin = /* @__PURE__ */ pluginFactory({
    components: {
      BTooltip
    },
    plugins: {
      VBTooltipPlugin
    }
  });
  var componentsPlugin = /* @__PURE__ */ pluginFactory({
    plugins: {
      AlertPlugin,
      AspectPlugin,
      AvatarPlugin,
      BadgePlugin,
      BreadcrumbPlugin,
      ButtonPlugin,
      ButtonGroupPlugin,
      ButtonToolbarPlugin,
      CalendarPlugin,
      CardPlugin,
      CarouselPlugin,
      CollapsePlugin,
      DropdownPlugin,
      EmbedPlugin,
      FormPlugin,
      FormCheckboxPlugin,
      FormDatepickerPlugin,
      FormFilePlugin,
      FormGroupPlugin,
      FormInputPlugin,
      FormRadioPlugin,
      FormRatingPlugin,
      FormSelectPlugin,
      FormSpinbuttonPlugin,
      FormTagsPlugin,
      FormTextareaPlugin,
      FormTimepickerPlugin,
      ImagePlugin,
      InputGroupPlugin,
      JumbotronPlugin,
      LayoutPlugin,
      LinkPlugin,
      ListGroupPlugin,
      MediaPlugin,
      ModalPlugin,
      NavPlugin,
      NavbarPlugin,
      OverlayPlugin,
      PaginationPlugin,
      PaginationNavPlugin,
      PopoverPlugin,
      ProgressPlugin,
      SidebarPlugin,
      SkeletonPlugin,
      SpinnerPlugin,
      TablePlugin,
      TabsPlugin,
      TimePlugin,
      ToastPlugin,
      TooltipPlugin
    }
  });
  var VBHoverPlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBHover
    }
  });
  var VBModalPlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBModal
    }
  });
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    _defineProperties(Constructor.prototype, protoProps);
    _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  var NAME$1 = "v-b-scrollspy";
  var CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
  var CLASS_NAME_ACTIVE = "active";
  var SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
  var SELECTOR_NAV_LINKS = ".nav-link";
  var SELECTOR_NAV_ITEMS = ".nav-item";
  var SELECTOR_LIST_ITEMS = ".list-group-item";
  var SELECTOR_DROPDOWN = ".dropdown, .dropup";
  var SELECTOR_DROPDOWN_ITEMS = ".dropdown-item";
  var SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
  var ROOT_EVENT_NAME_ACTIVATE = getRootEventName("BVScrollspy", "activate");
  var METHOD_OFFSET = "offset";
  var METHOD_POSITION = "position";
  var Default = {
    element: "body",
    offset: 10,
    method: "auto",
    throttle: 75
  };
  var DefaultType = {
    element: "(string|element|component)",
    offset: "number",
    method: "string",
    throttle: "number"
  };
  var TransitionEndEvents = ["webkitTransitionEnd", "transitionend", "otransitionend", "oTransitionEnd"];
  var toType = function toType2(obj) {
    return toString$1(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  };
  var typeCheckConfig = function typeCheckConfig2(componentName, config, configTypes) {
    for (var property in configTypes) {
      if (hasOwnProperty(configTypes, property)) {
        var expectedTypes = configTypes[property];
        var value = config[property];
        var valueType = value && isElement(value) ? "element" : toType(value);
        valueType = value && value._isVue ? "component" : valueType;
        if (!new RegExp(expectedTypes).test(valueType)) {
          warn("".concat(componentName, ': Option "').concat(property, '" provided type "').concat(valueType, '" but expected type "').concat(expectedTypes, '"'));
        }
      }
    }
  };
  var BVScrollspy = /* @__PURE__ */ function() {
    function BVScrollspy2(element, config, $root) {
      _classCallCheck(this, BVScrollspy2);
      this.$el = element;
      this.$scroller = null;
      this.$selector = [SELECTOR_NAV_LINKS, SELECTOR_LIST_ITEMS, SELECTOR_DROPDOWN_ITEMS].join(",");
      this.$offsets = [];
      this.$targets = [];
      this.$activeTarget = null;
      this.$scrollHeight = 0;
      this.$resizeTimeout = null;
      this.$scrollerObserver = null;
      this.$targetsObserver = null;
      this.$root = $root || null;
      this.$config = null;
      this.updateConfig(config);
    }
    _createClass(BVScrollspy2, [{
      key: "updateConfig",
      value: function updateConfig(config, $root) {
        if (this.$scroller) {
          this.unlisten();
          this.$scroller = null;
        }
        var cfg = _objectSpread(_objectSpread({}, this.constructor.Default), config);
        if ($root) {
          this.$root = $root;
        }
        typeCheckConfig(this.constructor.Name, cfg, this.constructor.DefaultType);
        this.$config = cfg;
        if (this.$root) {
          var self2 = this;
          this.$root.$nextTick(function() {
            self2.listen();
          });
        } else {
          this.listen();
        }
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.unlisten();
        clearTimeout(this.$resizeTimeout);
        this.$resizeTimeout = null;
        this.$el = null;
        this.$config = null;
        this.$scroller = null;
        this.$selector = null;
        this.$offsets = null;
        this.$targets = null;
        this.$activeTarget = null;
        this.$scrollHeight = null;
      }
    }, {
      key: "listen",
      value: function listen() {
        var _this = this;
        var scroller = this.getScroller();
        if (scroller && scroller.tagName !== "BODY") {
          eventOn(scroller, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
        }
        eventOn(window, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
        eventOn(window, "resize", this, EVENT_OPTIONS_NO_CAPTURE);
        eventOn(window, "orientationchange", this, EVENT_OPTIONS_NO_CAPTURE);
        TransitionEndEvents.forEach(function(eventName) {
          eventOn(window, eventName, _this, EVENT_OPTIONS_NO_CAPTURE);
        });
        this.setObservers(true);
        this.handleEvent("refresh");
      }
    }, {
      key: "unlisten",
      value: function unlisten() {
        var _this2 = this;
        var scroller = this.getScroller();
        this.setObservers(false);
        if (scroller && scroller.tagName !== "BODY") {
          eventOff(scroller, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
        }
        eventOff(window, "scroll", this, EVENT_OPTIONS_NO_CAPTURE);
        eventOff(window, "resize", this, EVENT_OPTIONS_NO_CAPTURE);
        eventOff(window, "orientationchange", this, EVENT_OPTIONS_NO_CAPTURE);
        TransitionEndEvents.forEach(function(eventName) {
          eventOff(window, eventName, _this2, EVENT_OPTIONS_NO_CAPTURE);
        });
      }
    }, {
      key: "setObservers",
      value: function setObservers(on) {
        var _this3 = this;
        this.$scrollerObserver && this.$scrollerObserver.disconnect();
        this.$targetsObserver && this.$targetsObserver.disconnect();
        this.$scrollerObserver = null;
        this.$targetsObserver = null;
        if (on) {
          this.$targetsObserver = observeDom(this.$el, function() {
            _this3.handleEvent("mutation");
          }, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: ["href"]
          });
          this.$scrollerObserver = observeDom(this.getScroller(), function() {
            _this3.handleEvent("mutation");
          }, {
            subtree: true,
            childList: true,
            characterData: true,
            attributes: true,
            attributeFilter: ["id", "style", "class"]
          });
        }
      }
      // General event handler
    }, {
      key: "handleEvent",
      value: function handleEvent(event2) {
        var type = isString(event2) ? event2 : event2.type;
        var self2 = this;
        var resizeThrottle = function resizeThrottle2() {
          if (!self2.$resizeTimeout) {
            self2.$resizeTimeout = setTimeout(function() {
              self2.refresh();
              self2.process();
              self2.$resizeTimeout = null;
            }, self2.$config.throttle);
          }
        };
        if (type === "scroll") {
          if (!this.$scrollerObserver) {
            this.listen();
          }
          this.process();
        } else if (/(resize|orientationchange|mutation|refresh)/.test(type)) {
          resizeThrottle();
        }
      }
      // Refresh the list of target links on the element we are applied to
    }, {
      key: "refresh",
      value: function refresh() {
        var _this4 = this;
        var scroller = this.getScroller();
        if (!scroller) {
          return;
        }
        var autoMethod = scroller !== scroller.window ? METHOD_POSITION : METHOD_OFFSET;
        var method = this.$config.method === "auto" ? autoMethod : this.$config.method;
        var methodFn = method === METHOD_POSITION ? position : offset$1;
        var offsetBase = method === METHOD_POSITION ? this.getScrollTop() : 0;
        this.$offsets = [];
        this.$targets = [];
        this.$scrollHeight = this.getScrollHeight();
        selectAll(this.$selector, this.$el).map(function(link) {
          return getAttr(link, "href");
        }).filter(function(href) {
          return href && RX_HREF.test(href || "");
        }).map(function(href) {
          var id = href.replace(RX_HREF, "$1").trim();
          if (!id) {
            return null;
          }
          var el = select(id, scroller);
          if (el && isVisible(el)) {
            return {
              offset: toInteger(methodFn(el).top, 0) + offsetBase,
              target: id
            };
          }
          return null;
        }).filter(identity).sort(function(a2, b) {
          return a2.offset - b.offset;
        }).reduce(function(memo, item) {
          if (!memo[item.target]) {
            _this4.$offsets.push(item.offset);
            _this4.$targets.push(item.target);
            memo[item.target] = true;
          }
          return memo;
        }, {});
        return this;
      }
      // Handle activating/clearing
    }, {
      key: "process",
      value: function process2() {
        var scrollTop = this.getScrollTop() + this.$config.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.$config.offset + scrollHeight - this.getOffsetHeight();
        if (this.$scrollHeight !== scrollHeight) {
          this.refresh();
        }
        if (scrollTop >= maxScroll) {
          var target = this.$targets[this.$targets.length - 1];
          if (this.$activeTarget !== target) {
            this.activate(target);
          }
          return;
        }
        if (this.$activeTarget && scrollTop < this.$offsets[0] && this.$offsets[0] > 0) {
          this.$activeTarget = null;
          this.clear();
          return;
        }
        for (var i = this.$offsets.length; i--; ) {
          var isActiveTarget = this.$activeTarget !== this.$targets[i] && scrollTop >= this.$offsets[i] && (isUndefined(this.$offsets[i + 1]) || scrollTop < this.$offsets[i + 1]);
          if (isActiveTarget) {
            this.activate(this.$targets[i]);
          }
        }
      }
    }, {
      key: "getScroller",
      value: function getScroller() {
        if (this.$scroller) {
          return this.$scroller;
        }
        var scroller = this.$config.element;
        if (!scroller) {
          return null;
        } else if (isElement(scroller.$el)) {
          scroller = scroller.$el;
        } else if (isString(scroller)) {
          scroller = select(scroller);
        }
        if (!scroller) {
          return null;
        }
        this.$scroller = scroller.tagName === "BODY" ? window : scroller;
        return this.$scroller;
      }
    }, {
      key: "getScrollTop",
      value: function getScrollTop() {
        var scroller = this.getScroller();
        return scroller === window ? scroller.pageYOffset : scroller.scrollTop;
      }
    }, {
      key: "getScrollHeight",
      value: function getScrollHeight() {
        return this.getScroller().scrollHeight || mathMax(document.body.scrollHeight, document.documentElement.scrollHeight);
      }
    }, {
      key: "getOffsetHeight",
      value: function getOffsetHeight() {
        var scroller = this.getScroller();
        return scroller === window ? window.innerHeight : getBCR(scroller).height;
      }
    }, {
      key: "activate",
      value: function activate(target) {
        var _this5 = this;
        this.$activeTarget = target;
        this.clear();
        var links = selectAll(this.$selector.split(",").map(function(selector) {
          return "".concat(selector, '[href$="').concat(target, '"]');
        }).join(","), this.$el);
        links.forEach(function(link) {
          if (hasClass(link, CLASS_NAME_DROPDOWN_ITEM)) {
            var dropdown = closest(SELECTOR_DROPDOWN, link);
            if (dropdown) {
              _this5.setActiveState(select(SELECTOR_DROPDOWN_TOGGLE, dropdown), true);
            }
            _this5.setActiveState(link, true);
          } else {
            _this5.setActiveState(link, true);
            if (matches(link.parentElement, SELECTOR_NAV_ITEMS)) {
              _this5.setActiveState(link.parentElement, true);
            }
            var el = link;
            while (el) {
              el = closest(SELECTOR_NAV_LIST_GROUP, el);
              var sibling = el ? el.previousElementSibling : null;
              if (sibling && matches(sibling, "".concat(SELECTOR_NAV_LINKS, ", ").concat(SELECTOR_LIST_ITEMS))) {
                _this5.setActiveState(sibling, true);
              }
              if (sibling && matches(sibling, SELECTOR_NAV_ITEMS)) {
                _this5.setActiveState(select(SELECTOR_NAV_LINKS, sibling), true);
                _this5.setActiveState(sibling, true);
              }
            }
          }
        });
        if (links && links.length > 0 && this.$root) {
          this.$root.$emit(ROOT_EVENT_NAME_ACTIVATE, target, links);
        }
      }
    }, {
      key: "clear",
      value: function clear() {
        var _this6 = this;
        selectAll("".concat(this.$selector, ", ").concat(SELECTOR_NAV_ITEMS), this.$el).filter(function(el) {
          return hasClass(el, CLASS_NAME_ACTIVE);
        }).forEach(function(el) {
          return _this6.setActiveState(el, false);
        });
      }
    }, {
      key: "setActiveState",
      value: function setActiveState(el, active) {
        if (!el) {
          return;
        }
        if (active) {
          addClass(el, CLASS_NAME_ACTIVE);
        } else {
          removeClass(el, CLASS_NAME_ACTIVE);
        }
      }
    }], [{
      key: "Name",
      get: function get2() {
        return NAME$1;
      }
    }, {
      key: "Default",
      get: function get2() {
        return Default;
      }
    }, {
      key: "DefaultType",
      get: function get2() {
        return DefaultType;
      }
    }]);
    return BVScrollspy2;
  }();
  var BV_SCROLLSPY = "__BV_Scrollspy__";
  var onlyDigitsRE = /^\d+$/;
  var offsetRE = /^(auto|position|offset)$/;
  var parseBindings = function parseBindings2(bindings) {
    var config = {};
    if (bindings.arg) {
      config.element = "#".concat(bindings.arg);
    }
    keys(bindings.modifiers).forEach(function(mod) {
      if (onlyDigitsRE.test(mod)) {
        config.offset = toInteger(mod, 0);
      } else if (offsetRE.test(mod)) {
        config.method = mod;
      }
    });
    if (isString(bindings.value)) {
      config.element = bindings.value;
    } else if (isNumber(bindings.value)) {
      config.offset = mathRound(bindings.value);
    } else if (isObject(bindings.value)) {
      keys(bindings.value).filter(function(k) {
        return !!BVScrollspy.DefaultType[k];
      }).forEach(function(k) {
        config[k] = bindings.value[k];
      });
    }
    return config;
  };
  var applyScrollspy = function applyScrollspy2(el, bindings, vnode) {
    if (!IS_BROWSER) {
      return;
    }
    var config = parseBindings(bindings);
    if (el[BV_SCROLLSPY]) {
      el[BV_SCROLLSPY].updateConfig(config, getEventRoot(getInstanceFromDirective(vnode, bindings)));
    } else {
      el[BV_SCROLLSPY] = new BVScrollspy(el, config, getEventRoot(getInstanceFromDirective(vnode, bindings)));
    }
  };
  var removeScrollspy = function removeScrollspy2(el) {
    if (el[BV_SCROLLSPY]) {
      el[BV_SCROLLSPY].dispose();
      el[BV_SCROLLSPY] = null;
      delete el[BV_SCROLLSPY];
    }
  };
  var VBScrollspy = {
    /* istanbul ignore next: not easy to test */
    bind: function bind2(el, bindings, vnode) {
      applyScrollspy(el, bindings, vnode);
    },
    /* istanbul ignore next: not easy to test */
    inserted: function inserted(el, bindings, vnode) {
      applyScrollspy(el, bindings, vnode);
    },
    /* istanbul ignore next: not easy to test */
    update: function update2(el, bindings, vnode) {
      if (bindings.value !== bindings.oldValue) {
        applyScrollspy(el, bindings, vnode);
      }
    },
    /* istanbul ignore next: not easy to test */
    componentUpdated: function componentUpdated2(el, bindings, vnode) {
      if (bindings.value !== bindings.oldValue) {
        applyScrollspy(el, bindings, vnode);
      }
    },
    /* istanbul ignore next: not easy to test */
    unbind: function unbind2(el) {
      removeScrollspy(el);
    }
  };
  var VBScrollspyPlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBScrollspy
    }
  });
  var VBVisiblePlugin = /* @__PURE__ */ pluginFactory({
    directives: {
      VBVisible
    }
  });
  var directivesPlugin = /* @__PURE__ */ pluginFactory({
    plugins: {
      VBHoverPlugin,
      VBModalPlugin,
      VBPopoverPlugin,
      VBScrollspyPlugin,
      VBTogglePlugin,
      VBTooltipPlugin,
      VBVisiblePlugin
    }
  });
  /*!
   * BootstrapVue 2.23.1
   *
   * @link https://bootstrap-vue.org
   * @source https://github.com/bootstrap-vue/bootstrap-vue
   * @copyright (c) 2016-2022 BootstrapVue
   * @license MIT
   * https://github.com/bootstrap-vue/bootstrap-vue/blob/master/LICENSE
   */
  var NAME = "BootstrapVue";
  var install = /* @__PURE__ */ installFactory({
    plugins: {
      componentsPlugin,
      directivesPlugin
    }
  });
  var BootstrapVue = {
    install,
    NAME
  };
  Vue2.use(BootstrapVue);
  const _sfc_main = Vue2.extend({
    name: "MusicPlayer",
    data() {
      return {
        message: "Hello"
      };
    }
  });
  function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier, shadowMode) {
    var options = typeof scriptExports === "function" ? scriptExports.options : scriptExports;
    {
      options.render = render;
      options.staticRenderFns = staticRenderFns;
      options._compiled = true;
    }
    return {
      exports: scriptExports,
      options
    };
  }
  var _sfc_render = function render() {
    var _vm = this, _c = _vm._self._c;
    _vm._self._setupProxy;
    return _c("div", [_c("h1", [_vm._v(_vm._s(_vm.message))])]);
  };
  var _sfc_staticRenderFns = [];
  var __component__ = /* @__PURE__ */ normalizeComponent(
    _sfc_main,
    _sfc_render,
    _sfc_staticRenderFns
  );
  const MusicPlayer = __component__.exports;
  function onLiveQueue() {
    const addMusicFn = () => {
      const blockerPopup = getLiveQueueBlockerPopup();
      if (!blockerPopup) return false;
      if (blockerPopup.style.display === "none") return false;
      const popup = getLiveQueueSelectPopup();
      if (!popup) return false;
      const box = popup.querySelector(".flex.row.hv-center");
      if (!box) return false;
      musicPlayerUI.addToAWBWPage(box, true);
      playMusicURL(SpecialTheme.COSelect);
      return true;
    };
    const checkStillActiveFn = () => {
      const blockerPopup = getLiveQueueBlockerPopup();
      return (blockerPopup == null ? void 0 : blockerPopup.style.display) !== "none";
    };
    const addPlayerIntervalID = window.setInterval(() => {
      if (getCurrentPageType() !== PageType.LiveQueue) {
        window.clearInterval(addPlayerIntervalID);
        return;
      }
      if (!addMusicFn()) return;
      window.clearInterval(addPlayerIntervalID);
      const checkInterval = window.setInterval(() => {
        if (getCurrentPageType() !== PageType.LiveQueue) {
          window.clearInterval(checkInterval);
          playThemeSong();
          return;
        }
        if (checkStillActiveFn()) playMusicURL(SpecialTheme.COSelect);
        else playThemeSong();
      }, 500);
    }, 500);
  }
  let setHashesTimeoutID;
  function preloadThemes() {
    addThemeListeners();
    preloadAllCommonAudio(() => {
      logInfo("All common audio has been pre-loaded!");
      musicSettings.themeType = getCurrentThemeType();
      musicPlayerUI.updateAllInputLabels();
      playThemeSong();
      window.setTimeout(playThemeSong, 500);
      if (!setHashesTimeoutID) {
        const checkHashesMS = 1e3 * 60 * 1;
        const checkHashesFn = () => {
          checkHashesInDB().then(() => logInfo("All music files have been checked for updates.")).catch((reason) => logError("Could not check for music file updates:", reason));
          setHashesTimeoutID = window.setTimeout(checkHashesFn, checkHashesMS);
        };
        checkHashesFn();
      }
      musicPlayerUI.checkIfNewVersionAvailable();
    });
  }
  let lastCursorCall = Date.now();
  function initializeMusicPlayer() {
    const currentPageType = getCurrentPageType();
    if (currentPageType !== PageType.ActiveGame) musicSettings.isPlaying = musicSettings.autoplayOnOtherPages;
    switch (currentPageType) {
      case PageType.LiveQueue:
        onLiveQueue();
        break;
      case PageType.Maintenance:
        musicPlayerUI.openContextMenu();
        break;
      case PageType.MovePlanner:
        musicSettings.isPlaying = true;
        break;
    }
    preloadThemes();
    allowSettingsToBeSaved();
    initializeMusicPlayerUI();
    addHandlers();
    const iframe = document.getElementById(IFRAME_ID);
    iframe == null ? void 0 : iframe.addEventListener("focus", () => {
      if (musicSettings.isPlaying) playThemeSong();
    });
    window.addEventListener("focus", () => {
      if (musicSettings.isPlaying) playThemeSong();
    });
    broadcastChannel.onmessage = (ev) => {
      logDebug("Received message from another tab:", ev.data);
      if (ev.data === "pause") stopThemeSong();
      else if (ev.data === "play") playThemeSong();
    };
    const fn = (_e) => {
      const timeSinceLastCursorCall = Date.now() - lastCursorCall;
      if (!musicSettings.sfxOnOtherPages) return;
      if (timeSinceLastCursorCall < 80) return;
      playSFX(GameSFX.uiMenuMove);
      lastCursorCall = Date.now();
    };
    const addSFXToPage = () => {
      getCurrentDocument().querySelectorAll("a").forEach(
        (link) => link.addEventListener("click", () => {
          if (!musicSettings.sfxOnOtherPages) return;
          playSFX(GameSFX.uiMenuOpen);
        })
      );
      const hoverElements = Array.from(
        getCurrentDocument().querySelectorAll("li, ul, .dropdown-menu, .co_portrait, a, input, button")
      );
      hoverElements.forEach((menu) => menu.addEventListener("mouseenter", fn));
    };
    addSFXToPage();
    let overDiv = document.querySelector("#overDiv");
    if (!overDiv) {
      overDiv = document.createElement("div");
      overDiv.id = "overDiv";
      overDiv.style.visibility = "hidden";
      overDiv.style.position = "absolute";
      overDiv.style.zIndex = "2000";
      document.appendChild(overDiv);
    }
    const overDivObserver = new MutationObserver(() => {
      if (overDiv.style.visibility === "visible") addSFXToPage();
    });
    overDivObserver.observe(overDiv, { attributes: true });
  }
  let autoplayChecked = false;
  function checkAutoplayThenInitialize() {
    logDebug("Checking if we can autoplay then initializing the music player.");
    if (autoplayChecked) {
      initializeMusicPlayer();
      return;
    }
    autoplayChecked = true;
    const ifCanAutoplay = () => {
      initializeMusicPlayer();
    };
    const ifCannotAutoplay = () => {
      var _a;
      const initfn = () => {
        window.clearInterval(autoplayIntervalID);
        initializeMusicPlayer();
      };
      musicPlayerUI.addEventListener("click", initfn, { once: true });
      (_a = document.querySelector("body")) == null ? void 0 : _a.addEventListener("click", initfn, { once: true });
    };
    const autoplayIntervalID = window.setInterval(() => {
      canAutoplay2.audio().then((response) => {
        const result = response.result;
        logDebug("Script starting, does your browser allow you to auto-play:", result);
        if (result) {
          ifCanAutoplay();
          window.clearInterval(autoplayIntervalID);
        } else ifCannotAutoplay();
      }).catch((reason) => {
        logDebug("Script starting, could not check your browser allows auto-play so assuming no: ", reason);
        ifCannotAutoplay();
      });
    }, 100);
  }
  function main() {
    if (self !== top) return;
    const isMainPage = getCurrentPageType() === PageType.MainPage;
    if (!isMainPage && !window.location.href.includes(".php")) return;
    loadSettingsFromLocalStorage();
    logInfo("Opening database to cache music files.");
    openDB().then(() => logInfo("Database opened successfully. Ready to cache music files.")).catch((reason) => logDebug(`Database Error: ${reason}. Will not be able to cache music files locally.`)).finally(() => {
      var _a, _b;
      if (getCurrentPageType() === PageType.Maintenance) {
        checkAutoplayThenInitialize();
        const maintenanceDiv = document.querySelector("#server-maintenance-alert");
        const currentText = maintenanceDiv == null ? void 0 : maintenanceDiv.textContent;
        const minutes = ((_a = currentText == null ? void 0 : currentText.match(/\d+m/)) == null ? void 0 : _a[0].replace("m", "")) ?? 0;
        const seconds = ((_b = currentText == null ? void 0 : currentText.match(/\d+s/)) == null ? void 0 : _b[0].replace("s", "")) ?? 0;
        logInfo("Maintenance page detected. Will try again in", minutes, "minutes and", seconds, "seconds.");
        return;
      }
      initializeIFrame(checkAutoplayThenInitialize);
    });
  }
  main();
  const vueElement = document.createElement("div");
  vueElement.id = "music_player_vue";
  document.body.appendChild(vueElement);
  new Vue2({
    render: (h) => h(MusicPlayer)
  }).$mount("#music_player_vue");
  exports.checkAutoplayThenInitialize = checkAutoplayThenInitialize;
  exports.initializeMusicPlayer = initializeMusicPlayer;
  exports.notifyCOSelectorListeners = notifyCOSelectorListeners;
  exports.toggleDebugOverrides = toggleDebugOverrides;
  Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
  return exports;
}({}, canAutoplay, SparkMD5, Vue);
